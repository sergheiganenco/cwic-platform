

====================================================================================================
  CWIC PLATFORM - APPLICATION CODE ONLY
====================================================================================================

Generated on: 09/06/2025 17:17:59
Includes: Business logic, API routes, components, services, models
Excludes: Config files, build tools, dependencies, assets


====================================================================================================
  API GATEWAY - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\api-gateway\src\app.ts
------------------------------------------------------------
// src/app.ts
import compression from "compression";
import cors from "cors";
import "dotenv/config";
import express, {
  type NextFunction,
  type Request,
  type RequestHandler,
  type Response,
} from "express";
import rateLimit from "express-rate-limit";
import helmet from "helmet";
import morgan from "morgan";
import { randomUUID } from "node:crypto";

import { resolveUpstreams } from "./config/upstreams.js";
import aiServiceProxy from "./proxy/aiServiceProxy.js";
import authServiceProxy from "./proxy/authServiceProxy.js";
import dataServiceProxy from "./proxy/dataServiceProxy.js";

const app = express();

const NODE_ENV = process.env.NODE_ENV || "development";
const isProd = NODE_ENV === "production";
const isDev = !isProd;

const bodyLimit = process.env.BODY_LIMIT || "1mb";
const DEV_BEARER = process.env.DEV_BEARER ?? "";

/** Parse comma-separated CORS origins from env */
function parseOrigins(val?: string): string[] {
  if (!val) return [];
  return val.split(",").map((s) => s.trim()).filter(Boolean);
}

// Allow explicit env origins; in dev, default to localhost ports if none provided
const origins = parseOrigins(
  process.env.CORS_ORIGIN ||
    (isDev
      ? "http://localhost:3000,http://localhost:5173,http://localhost:4173"
      : "")
);
/** If no origins provided or '*' present, reflect any origin */
const allowAll = origins.length === 0 || origins.includes("*");

// ────────────────────────── App hardening & basics ──────────────────────────
app.disable("x-powered-by");

// Accept a numeric hop count or boolean "true"
const trustProxy = process.env.TRUST_PROXY ?? (isProd ? "1" : "true");
app.set("trust proxy", trustProxy);

app.use(
  helmet({
    contentSecurityPolicy: false,
    crossOriginEmbedderPolicy: false,
    hsts: isProd ? undefined : false,
  })
);

// ──────────────────────── BULLETPROOF CORS PRE-FLIGHT ───────────────────────
app.use((req: Request, res: Response, next: NextFunction) => {
  if (req.method !== "OPTIONS") return next();

  const origin = (req.headers.origin as string) || "";
  const isAllowedOrigin = allowAll || origins.includes(origin);

  if (!isAllowedOrigin) return next();

  // Reflect origin (credentials-compatible)
  res.setHeader("Access-Control-Allow-Origin", origin);
  res.setHeader("Vary", "Origin");
  res.setHeader("Access-Control-Allow-Credentials", "true");

  // Reflect requested methods/headers so *any* custom headers are accepted
  const reqMethods =
    (req.headers["access-control-request-method"] as string) ||
    "GET,POST,PUT,PATCH,DELETE,OPTIONS";
  const reqHeaders =
    (req.headers["access-control-request-headers"] as string) ||
    "authorization,content-type";

  res.setHeader("Access-Control-Allow-Methods", reqMethods);
  res.setHeader("Access-Control-Allow-Headers", reqHeaders);
  res.setHeader("Access-Control-Max-Age", "86400"); // 24h

  return res.status(204).end();
});

// Standard CORS for non-OPTIONS requests
const corsOptions: cors.CorsOptions = {
  origin: allowAll ? true : origins,
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  exposedHeaders: ["X-Request-Id"],
  maxAge: 86400,
  optionsSuccessStatus: 204,
};
app.use(cors(corsOptions));

// ─────────────────────────── Rate limit (prod only) ─────────────────────────
const limiter = rateLimit({
  windowMs: 60_000,
  max: 300,
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => req.method === "OPTIONS" || !isProd,
}) as unknown as RequestHandler;
app.use(limiter);

// ─────────────────────────── Parsers & logging ──────────────────────────────
app.use(compression());
app.use(express.json({ limit: bodyLimit }));
app.use(express.urlencoded({ extended: true, limit: bodyLimit }));
app.use(morgan(isDev ? "dev" : "combined"));

// Request ID (echo/propagate downstream)
app.use((req: Request, res: Response, next: NextFunction) => {
  const rid = (req.headers["x-request-id"] as string) || randomUUID();
  req.headers["x-request-id"] = rid;
  res.setHeader("X-Request-Id", rid);
  next();
});

// ───────────────────────────── Health & debug ───────────────────────────────
app.get("/health", (_req, res) =>
  res.json({ ok: true, service: "api-gateway", env: NODE_ENV })
);
app.get("/ready", (_req, res) => res.json({ ready: true }));
app.get("/upstreams", (_req, res) =>
  res.json({ env: NODE_ENV, upstreams: resolveUpstreams() })
);

// ─────────────────────────── Dev stubs (before proxies) ─────────────────────
// NOTE: These must be registered BEFORE the proxies below.
if (isDev) {
  // Refresh endpoint stub for dev: UI posts here; we return a token
  app.post("/api/auth/refresh", (_req, res) => {
    if (!DEV_BEARER) return res.status(500).json({ error: "DEV_BEARER not set" });
    const raw = DEV_BEARER.startsWith("Bearer ") ? DEV_BEARER.slice(7) : DEV_BEARER;
    return res.json({ token: raw });
  });

  // Optional: AI health stub so UI stops 502’ing when ai-service is down
  app.get("/api/ai/health", (_req, res) => {
    res.json({ status: "ok", stub: true });
  });
}

// ───────────────────────── Dev bearer injection block ───────────────────────
// In dev, if no Authorization header, attach DEV_BEARER (do not overwrite a real one)
if (isDev) {
  app.use(["/api", "/api/ai", "/api/auth"], (req, _res, next) => {
    if (!req.headers.authorization && DEV_BEARER) {
      req.headers.authorization = DEV_BEARER.startsWith("Bearer ")
        ? DEV_BEARER
        : `Bearer ${DEV_BEARER}`;
    }
    next();
  });
}

// ──────────────────────────────── Proxies ───────────────────────────────────
// IMPORTANT: Do NOT strip the /api prefix when forwarding to the data-service.
// The data-service mounts its routes under /api/* (e.g., /api/data-sources).
// Order matters: specific first.
app.use("/api/ai", aiServiceProxy);     // rewrites ^/api/ai → /api on upstream (see file)
app.use("/api/auth", authServiceProxy); // rewrites ^/api/auth → /auth on upstream (see file)
app.use("/api", dataServiceProxy);      // forwards /api/* intact to data-service

// ───────────────────────────── 404 + error handling ─────────────────────────
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: "NOT_FOUND",
    message: `Route ${req.method} ${req.originalUrl} not found`,
  });
});

// Centralized JSON error handler
// eslint-disable-next-line @typescript-eslint/no-unused-vars
app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  const status = err.status || err.statusCode || 500;
  const code = err.code || "INTERNAL_SERVER_ERROR";
  const publicMessage =
    isProd ? err.publicMessage || "Internal server error" : err.message || "Internal server error";

  if (!res.headersSent) {
    res.status(status).json({
      success: false,
      error: { code, message: publicMessage },
    });
  }
});

export default app;



------------------------------------------------------------
FILE: backend\api-gateway\src\config\upstreams.ts
------------------------------------------------------------
// backend/api-gateway/src/config/upstreams.ts
import fs from "node:fs";
import { URL } from "node:url";

export interface Upstreams {
  dataService: string;
  aiService: string;
  authService: string;
}

function inDocker(): boolean {
  try {
    if (fs.existsSync("/.dockerenv")) return true;
    if (process.env.KUBERNETES_SERVICE_HOST) return true;
  } catch {}
  return false;
}

function sanitizeBase(u: string): string {
  try {
    const url = new URL(u);
    url.pathname = url.pathname.replace(/\/+$/, "");
    return url.toString().replace(/\/+$/, "");
  } catch {
    return (u || "").replace(/\/+$/, "");
  }
}

function normalizeServiceBase(raw: string | undefined, fallback: string) {
  let url = (raw || fallback).trim().replace(/\/+$/, "");
  if (url.endsWith("/api")) url = url.slice(0, -4);
  return sanitizeBase(url);
}

function maybeLocalize(u: string, local: string): string {
  if (inDocker()) return u;
  try {
    const url = new URL(u);
    const dockerNames = new Set([
      "data-service",
      "ai-service",
      "auth-service",
      "pipeline-service",
      "notification-service",
      "integration-service",
    ]);
    if (dockerNames.has(url.hostname)) {
      return `${url.protocol}//localhost${url.port ? ":" + url.port : ""}`;
    }
    return u;
  } catch {
    return u;
  }
}

export function resolveUpstreams(): Upstreams {
  const dataService = maybeLocalize(
    normalizeServiceBase(process.env.DATA_SERVICE_URL, "http://data-service:3002"),
    "http://localhost:3002"
  );
  const aiService = maybeLocalize(
    normalizeServiceBase(process.env.AI_SERVICE_URL, "http://ai-service:3003"),
    "http://localhost:3003"
  );
  const authService = maybeLocalize(
    normalizeServiceBase(process.env.AUTH_SERVICE_URL, "http://auth-service:8001"),
    "http://localhost:8001"
  );
  return { dataService, aiService, authService };
}



------------------------------------------------------------
FILE: backend\api-gateway\src\middleware\healthCheck.ts
------------------------------------------------------------
import { Request, Response } from 'express';
// These clients come from @cwic/shared (weâ€™ll wire them as simple axios wrappers)
import { AIServiceClient, AuthServiceClient, DataServiceClient } from '@cwic/shared';

const serviceClients = {
  auth: new AuthServiceClient(),
  data: new DataServiceClient(),
  ai: new AIServiceClient()
};

export const healthCheck = async (req: Request, res: Response): Promise<void> => {
  const startTime = Date.now();
  try {
    const serviceChecks = await Promise.allSettled([
      checkServiceHealth('auth', serviceClients.auth),
      checkServiceHealth('data', serviceClients.data),
      checkServiceHealth('ai', serviceClients.ai)
    ]);

    const services = serviceChecks.reduce((acc, result, index) => {
      const serviceName = ['auth', 'data', 'ai'][index];
      acc[serviceName] = result.status === 'fulfilled'
        ? result.value
        : { status: 'unhealthy', error: (result as any).reason?.message };
      return acc;
    }, {} as any);

    const allHealthy = Object.values(services).every((s: any) => s.status === 'healthy');

    res.status(allHealthy ? 200 : 503).json({
      status: allHealthy ? 'healthy' : 'degraded',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      responseTime: Date.now() - startTime,
      version: process.env.npm_package_version || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      services
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      responseTime: Date.now() - startTime,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
};

async function checkServiceHealth(_name: string, client: any): Promise<any> {
  try {
    const start = Date.now();
    await client.get('/health');
    return { status: 'healthy', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'unhealthy', error: error instanceof Error ? error.message : 'Unknown error' };
  }
}



------------------------------------------------------------
FILE: backend\api-gateway\src\proxy\aiServiceProxy.ts
------------------------------------------------------------
// backend/api-gateway/src/proxy/aiServiceProxy.ts
import type { Request, Response } from "express";
import { createProxyMiddleware, type Options } from "http-proxy-middleware";
import type { Socket } from "node:net";
import { resolveUpstreams } from "../config/upstreams.js";

const { aiService: target } = resolveUpstreams();
const isDev = process.env.NODE_ENV !== "production";
const devBearer = process.env.DEV_BEARER ?? "";

/**
 * Mount path: /api/ai
 * Upstream exposes /api/* â†’ trim the /api/ai prefix down to /api
 *   req.url:          '/health'
 *   originalUrl:      '/api/ai/health'
 *   proxied path ->   '/api/health'
 */
const options: Options<Request, Response> = {
  target,
  changeOrigin: true,
  xfwd: true,
  secure: !isDev,
  proxyTimeout: 30_000,
  timeout: 30_000,
  pathRewrite: (_path, req) => `/api${req.url}`,

  on: {
    proxyReq: (proxyReq: any, req: Request) => {
      if (isDev && devBearer && !req.headers.authorization) {
        proxyReq.setHeader(
          "authorization",
          devBearer.startsWith("Bearer ") ? devBearer : `Bearer ${devBearer}`
        );
        proxyReq.setHeader("x-dev-auth", "gateway");
      } else if (req.headers.authorization) {
        proxyReq.setHeader("authorization", req.headers.authorization);
      }

      const rid = (req.headers["x-request-id"] as string) || "";
      if (rid) proxyReq.setHeader("x-request-id", rid);

      if (isDev) {
        // eslint-disable-next-line no-console
        console.debug(
          `[proxyâ†’ai] ${req.method} ${req.originalUrl} â†’ ${target}/api${req.url}`
        );
      }
    },

    proxyRes: (proxyRes, req: Request) => {
      const origin = req.headers.origin as string | undefined;
      if (origin) {
        proxyRes.headers["access-control-allow-origin"] = origin;
        proxyRes.headers["access-control-allow-credentials"] = "true";
      }
      if (isDev) {
        // eslint-disable-next-line no-console
        console.debug(
          `[proxyâ†’ai] ${req.method} ${req.originalUrl} â‡ ${proxyRes.statusCode}`
        );
      }
    },

    error: (err: Error, req: Request, res: Response | Socket) => {
      if (typeof (res as Socket).destroy === "function" && !(res as any).setHeader) {
        try {
          (res as Socket).destroy();
        } catch {}
        return;
      }
      const r = res as Response;
      if (!r.headersSent) {
        r.status(502).json({
          success: false,
          error: "AI_SERVICE_UNAVAILABLE",
          message: "AI service is currently unavailable",
          details: err.message,
          upstream: target,
          timestamp: new Date().toISOString(),
        });
      }
    },
  },
};

export default createProxyMiddleware(options);



------------------------------------------------------------
FILE: backend\api-gateway\src\proxy\authServiceProxy.ts
------------------------------------------------------------
// backend/api-gateway/src/proxy/authServiceProxy.ts
import type { Request, Response } from "express";
import { createProxyMiddleware, type Options } from "http-proxy-middleware";
import type { Socket } from "node:net";
import { resolveUpstreams } from "../config/upstreams.js";

const { authService: target } = resolveUpstreams();
const isDev = process.env.NODE_ENV !== "production";

const options: Options<Request, Response> = {
  target,
  changeOrigin: true,
  xfwd: true,
  secure: !isDev,
  proxyTimeout: 30_000,
  timeout: 30_000,
  // Gateway mount: /api/auth â†’ upstream exposes /auth/*
  pathRewrite: (_path, req) => `/auth${req.url}`,

  on: {
    proxyReq: (_proxyReq: any, req: Request) => {
      if (isDev) {
        // eslint-disable-next-line no-console
        console.debug(
          `[proxyâ†’auth] ${req.method} ${req.originalUrl} â†’ ${target}/auth${req.url}`
        );
      }
    },

    error: (err: Error, req: Request, res: Response | Socket) => {
      if (typeof (res as Socket).destroy === "function" && !(res as any).setHeader) {
        try {
          (res as Socket).destroy();
        } catch {}
        return;
      }
      const r = res as Response;
      if (!r.headersSent) {
        r.status(502).json({
          success: false,
          error: "AUTH_SERVICE_UNAVAILABLE",
          message: "Auth service is currently unavailable",
          details: err.message,
          upstream: target,
          timestamp: new Date().toISOString(),
        });
      }
    },
  },
};

export default createProxyMiddleware(options);



------------------------------------------------------------
FILE: backend\api-gateway\src\proxy\dataServiceProxy.ts
------------------------------------------------------------
import type { Request, Response } from "express";
import { createProxyMiddleware, type Options } from "http-proxy-middleware";
import type { Socket } from "node:net";
import { resolveUpstreams } from "../config/upstreams.js";

const { dataService: upstreamBase } = resolveUpstreams(); // e.g. http://localhost:3002
const isDev = process.env.NODE_ENV !== "production";
const devBearer = process.env.DEV_BEARER ?? "";

/**
 * We STRIP the /api prefix here because the data-service mounts routes WITHOUT /api.
 * FE â†’ Gateway:        /api/data-sources
 * Gateway â†’ data-svc:  /data-sources
 */
const options: Options<Request, Response> = {
  target: upstreamBase,
  changeOrigin: true,
  xfwd: true,
  secure: !isDev,
  proxyTimeout: 30_000,
  timeout: 30_000,

  // ðŸ”‘ KEY FIX: remove `/api` before forwarding
  pathRewrite: { "^/api": "" },

  on: {
    proxyReq: (proxyReq: any, req: Request) => {
      // Dev bearer injection (only if client didnâ€™t send one)
      if (!req.headers.authorization && isDev && devBearer) {
        proxyReq.setHeader(
          "authorization",
          devBearer.startsWith("Bearer ") ? devBearer : `Bearer ${devBearer}`
        );
        proxyReq.setHeader("x-dev-auth", "gateway");
      } else if (req.headers.authorization) {
        proxyReq.setHeader("authorization", req.headers.authorization);
      }

      // Trace headers
      const rid = (req.headers["x-request-id"] as string) || "";
      if (rid) proxyReq.setHeader("x-request-id", rid);

      // Forward cookies if present
      const cookie = req.headers["cookie"];
      if (cookie) proxyReq.setHeader("cookie", cookie);

      // Reflect request body for non-GET
      if (req.method !== "GET" && req.method !== "HEAD" && (req as any).body) {
        const ct =
          String(
            proxyReq.getHeader("content-type") ||
              proxyReq.getHeader("Content-Type") ||
              ""
          ).toLowerCase();

        if (ct.includes("application/json")) {
          const body = JSON.stringify((req as any).body);
          proxyReq.setHeader("content-length", Buffer.byteLength(body));
          proxyReq.write(body);
        } else if (ct.includes("application/x-www-form-urlencoded")) {
          const body = new URLSearchParams(
            (req as any).body as Record<string, string>
          ).toString();
          proxyReq.setHeader("content-length", Buffer.byteLength(body));
          proxyReq.write(body);
        }
      }

      if (isDev) {
        // proxyReq.path is AFTER pathRewrite; helpful to see final upstream URL
        console.debug(
          `[proxyâ†’data] ${req.method} ${req.originalUrl} â†’ ${upstreamBase}${proxyReq.path}`
        );
      }
    },

    proxyRes: (proxyRes, req: Request) => {
      // Keep CORS aligned with gateway decision (reflect the Origin)
      const origin = req.headers.origin;
      if (origin) {
        proxyRes.headers["access-control-allow-origin"] = origin;
        proxyRes.headers["access-control-allow-credentials"] = "true";
      }

      if (isDev) {
        console.debug(
          `[proxyâ†’data] ${req.method} ${req.originalUrl} â‡ ${proxyRes.statusCode}`
        );
      }
    },

    error: (err: Error, req: Request, res: Response | Socket) => {
      console.error(
        `[proxyâ†’data] Error for ${req.method} ${req.originalUrl}:`,
        err.message
      );

      // If it's a raw socket (e.g., WS) just destroy
      if (typeof (res as Socket).destroy === "function" && !(res as any).setHeader) {
        try {
          (res as Socket).destroy();
        } catch {}
        return;
      }

      const r = res as Response;
      if (!r.headersSent) {
        const origin = req.headers.origin;
        if (origin) {
          r.setHeader("Access-Control-Allow-Origin", origin);
          r.setHeader("Access-Control-Allow-Credentials", "true");
        }
        r.status(502).json({
          success: false,
          error: "DATA_SERVICE_UNAVAILABLE",
          message: "Data service is currently unavailable",
          details: err.message,
          upstream: upstreamBase,
          timestamp: new Date().toISOString(),
        });
      }
    },
  },
};

export default createProxyMiddleware(options);



------------------------------------------------------------
FILE: backend\api-gateway\src\routes\data-proxy.ts
------------------------------------------------------------
import { Request, Response, Router } from 'express';
import { createProxyMiddleware, type Options } from 'http-proxy-middleware';

const router = Router();

// Compose sets DATA_SERVICE_URL=http://data-service:3002
const base = (process.env.DATA_SERVICE_URL || 'http://data-service:3002').replace(/\/+$/, '');
const target = `${base}/api`; // upstream base includes /api

function attachBody(proxyReq: any, req: Request): void {
  const ct = String(proxyReq.getHeader('Content-Type') || '');
  if (!req.body || req.method === 'GET' || req.method === 'HEAD') return;

  if (ct.includes('application/json')) {
    const body = JSON.stringify(req.body);
    proxyReq.setHeader('Content-Length', Buffer.byteLength(body));
    proxyReq.write(body);
  } else if (ct.includes('application/x-www-form-urlencoded')) {
    const body = new URLSearchParams(req.body as Record<string, string>).toString();
    proxyReq.setHeader('Content-Length', Buffer.byteLength(body));
    proxyReq.write(body);
  }
}

const options: Options<Request, Response> = {
  target,
  changeOrigin: true,
  on: {
    proxyReq: (proxyReq, req) => attachBody(proxyReq, req as Request),
    error: (err, _req, res) => {
      const r = res as Response;
      if (!r.headersSent) {
        r.status(502).json({
          success: false,
          error: 'BAD_GATEWAY',
          message: (err as Error).message,
          upstream: target,
        });
      }
    },
    proxyRes: (_proxyRes, req, _res) => {
      // lightweight trace in your logs
      (req as any).log?.debug?.(`Proxied ${req.method} ${req.originalUrl} -> ${target}${req.url}`);
    },
  },
};

// Handle both /api and /api/*
const proxyMw = createProxyMiddleware(options);
router.all('/', proxyMw as any);
router.all('/*', proxyMw as any);

export default router;



------------------------------------------------------------
FILE: backend\api-gateway\src\server.ts
------------------------------------------------------------
// src/server.ts
import "dotenv/config";
import app from "./app.js";

const PORT = Number(process.env.PORT ?? 8000);
const HOST = process.env.HOST ?? "0.0.0.0";

const DATA_SERVICE_URL = process.env.DATA_SERVICE_URL ?? "http://localhost:3002";
const AI_SERVICE_URL = process.env.AI_SERVICE_URL ?? "http://localhost:8003";

const server = app.listen(PORT, HOST, () => {
  console.log(`🚀 API Gateway listening on ${HOST}:${PORT}`);
  console.log(`📊 Health:           http://localhost:${PORT}/health`);
  console.log(`🔄 Proxy /api/*  →   ${DATA_SERVICE_URL}`);
  console.log(`🤖 Proxy /api/ai/* → ${AI_SERVICE_URL}`);
});

function shutdown(signal: string) {
  console.log(`[gateway] ${signal} received → closing server...`);
  server.close((err?: Error) => {
    if (err) {
      console.error("[gateway] Error during close:", err);
      process.exit(1);
    }
    console.log("[gateway] Closed cleanly.");
    process.exit(0);
  });
  // Force-exit if something hangs (open sockets, etc.)
  setTimeout(() => {
    console.warn("[gateway] Forced shutdown after 10s");
    process.exit(1);
  }, 10_000).unref();
}

process.on("SIGINT", () => shutdown("SIGINT"));
process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("unhandledRejection", (reason) => {
  console.error("[gateway] Unhandled Rejection:", reason);
});
process.on("uncaughtException", (err) => {
  console.error("[gateway] Uncaught Exception:", err);
  // In prod you may decide to exit(1); keeping alive here for dev.
  // if (process.env.NODE_ENV === "production") process.exit(1);
});

export default server;



====================================================================================================
  AUTH SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\auth-service\src\app.ts
------------------------------------------------------------
import compression from 'compression';
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';

export const app = express();

app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json());

// Health endpoint for Docker HEALTHCHECK
app.get('/health', (_req, res) => {
  res.status(200).json({ status: 'ok', service: 'auth-service' });
});



------------------------------------------------------------
FILE: backend\auth-service\src\config\env.ts
------------------------------------------------------------
import 'dotenv/config';
import { z } from 'zod';

const Env = z.object({
  NODE_ENV: z.enum(['development','test','production']).default('development'),
  PORT: z.coerce.number().default(3001),
  CORS_ORIGIN: z.string().default('http://localhost:5173'),

  DATABASE_URL: z.string(),
  REDIS_URL: z.string(),

  JWT_ACCESS_SECRET: z.string().min(16),
  JWT_REFRESH_SECRET: z.string().min(16),
  ACCESS_TTL: z.string().default('15m'),
  REFRESH_TTL: z.string().default('7d'),
});

export const env = Env.parse(process.env);
export const corsOrigins = env.CORS_ORIGIN.split(',').map(s => s.trim());



------------------------------------------------------------
FILE: backend\auth-service\src\db.ts
------------------------------------------------------------
import { Pool } from 'pg';
import { env } from './config/env.js';

export const pool = new Pool({
  connectionString: env.DATABASE_URL,
  max: 15,
  idleTimeoutMillis: 30_000,
  statement_timeout: 60_000,
});



------------------------------------------------------------
FILE: backend\auth-service\src\middleware\error.ts
------------------------------------------------------------
import type { NextFunction, Request, Response } from 'express';

export class HttpError extends Error {
  status: number; code?: string;
  constructor(status: number, message: string, code?: string) {
    super(message); this.status = status; this.code = code;
  }
}
export function errorHandler(err: any, _req: Request, res: Response, _next: NextFunction) {
  const status = err.status || 500;
  res.status(status).json({
    type: 'about:blank',
    title: err.code || 'ServerError',
    status,
    detail: err.message || 'Unexpected error'
  });
}



------------------------------------------------------------
FILE: backend\auth-service\src\middleware\requireAuth.ts
------------------------------------------------------------
import type { NextFunction, Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import { env } from '../config/env.js';

export function requireAuth(roles?: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    const h = req.headers.authorization || '';
    const token = h.startsWith('Bearer ') ? h.slice(7) : null;
    if (!token) return res.status(401).json({ detail: 'Missing token' });
    try {
      const decoded: any = jwt.verify(token, env.JWT_ACCESS_SECRET);
      (req as any).user = decoded;
      if (roles && !roles.some(r => (decoded.roles || []).includes(r))) {
        return res.status(403).json({ detail: 'Forbidden' });
      }
      next();
    } catch { return res.status(401).json({ detail: 'Invalid token' }); }
  };
}



------------------------------------------------------------
FILE: backend\auth-service\src\redis.ts
------------------------------------------------------------
import { createClient } from 'redis';
import { env } from './config/env.js';

export const redis = createClient({ url: env.REDIS_URL });

export async function initRedis() {
  redis.on('error', (e) => console.error('[redis] error', e));
  if (!redis.isOpen) {
    await redis.connect();
  }
}



------------------------------------------------------------
FILE: backend\auth-service\src\routes\auth.ts
------------------------------------------------------------
import { randomUUID } from 'crypto';
import { Router } from 'express';
import { z } from 'zod';
import { pool } from '../db.js';
import { HttpError } from '../middleware/error.js';
import { redis } from '../redis.js';
import { signAccess, signRefresh, verifyRefresh } from '../utils/jwt.js';
import { hashPassword, verifyPassword } from '../utils/password.js';

export const authRouter = Router();

const RegisterSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  display_name: z.string().min(2).max(100)
});

const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

/** POST /auth/register */
authRouter.post('/register', async (req, res, next) => {
  try {
    const { email, password, display_name } = RegisterSchema.parse(req.body);
    const pwHash = await hashPassword(password);

    const { rows } = await pool.query(
      `INSERT INTO users (email, password_hash, display_name, roles, is_verified)
       VALUES ($1, $2, $3, ARRAY['user'], false)
       ON CONFLICT (email) DO NOTHING
       RETURNING id, email, display_name, roles, is_verified, created_at`,
      [email, pwHash, display_name]
    );
    const user = rows[0];
    if (!user) throw new HttpError(409, 'Email already registered', 'EmailTaken');

    const sid = randomUUID();
    const access = signAccess({ sub: user.id, roles: user.roles, sid });
    const refresh = signRefresh({ sub: user.id, sid });
    res.status(201).json({ user, tokens: { access, refresh } });
  } catch (e) { next(e); }
});

/** POST /auth/login */
authRouter.post('/login', async (req, res, next) => {
  try {
    const { email, password } = LoginSchema.parse(req.body);
    const { rows } = await pool.query(
      'SELECT id, email, password_hash, display_name, roles, is_verified FROM users WHERE email=$1',
      [email]
    );
    const u = rows[0];
    if (!u || !(await verifyPassword(password, u.password_hash))) {
      throw new HttpError(401, 'Invalid credentials', 'AuthFailed');
    }
    const sid = randomUUID();
    const access = signAccess({ sub: u.id, roles: u.roles, sid });
    const refresh = signRefresh({ sub: u.id, sid });
    res.json({ user: { id: u.id, email: u.email, display_name: u.display_name, roles: u.roles }, tokens: { access, refresh } });
  } catch (e) { next(e); }
});

/** POST /auth/refresh */
authRouter.post('/refresh', async (req, res, next) => {
  try {
    const { refresh } = (req.body || {}) as { refresh?: string };
    if (!refresh) throw new HttpError(400, 'Missing refresh token', 'BadRequest');

    let decoded: any;
    try { decoded = verifyRefresh(refresh); }
    catch { throw new HttpError(401, 'Invalid refresh token', 'InvalidRefresh'); }

    // revoked?
    const revoked = await redis.get(`revoked:${decoded.sid}`);
    if (revoked) throw new HttpError(401, 'Refresh revoked', 'TokenRevoked');

    // rotate: revoke old session id
    await redis.setEx(`revoked:${decoded.sid}`, 60 * 60 * 24 * 8, '1');
    const newSid = randomUUID();

    // fetch roles to embed (optional)
    const { rows } = await pool.query('SELECT roles FROM users WHERE id=$1', [decoded.sub]);
    const roles = rows[0]?.roles || ['user'];

    const access = signAccess({ sub: decoded.sub, roles, sid: newSid });
    const newRefresh = signRefresh({ sub: decoded.sub, sid: newSid });
    res.json({ access, refresh: newRefresh });
  } catch (e) { next(e); }
});

/** POST /auth/logout */
authRouter.post('/logout', async (req, res, _next) => {
  try {
    const { refresh } = (req.body || {}) as { refresh?: string };
    if (refresh) {
      try {
        const decoded: any = verifyRefresh(refresh);
        await redis.setEx(`revoked:${decoded.sid}`, 60 * 60 * 24 * 8, '1');
      } catch { /* ignore */ }
    }
    res.status(204).send();
  } catch { res.status(204).send(); }
});

/** GET /auth/me (requires Authorization: Bearer <access>) */
authRouter.get('/me', async (req, res, next) => {
  try {
    const h = req.headers.authorization || '';
    const token = h.startsWith('Bearer ') ? h.slice(7) : '';
    if (!token) throw new HttpError(401, 'Missing token', 'AuthRequired');

    // Verify access; we donâ€™t need roles here
    const jwt = await import('jsonwebtoken');
    const { env } = await import('../config/env.js');
    const decoded: any = jwt.default.verify(token, env.JWT_ACCESS_SECRET);

    const { rows } = await pool.query(
      'SELECT id, email, display_name, roles, is_verified, created_at FROM users WHERE id=$1',
      [decoded.sub]
    );
    const u = rows[0];
    if (!u) throw new HttpError(404, 'User not found', 'NotFound');
    res.json(u);
  } catch (e) { next(e); }
});



------------------------------------------------------------
FILE: backend\auth-service\src\server.ts
------------------------------------------------------------
import 'dotenv/config'; // load env early
import process from 'node:process';
import { app } from './app.js'; // NodeNext: use .js for relative import

const port = Number(process.env.PORT) || 8001;
app.listen(port, () => {
  console.log(`auth-service listening on :${port}`);
});



------------------------------------------------------------
FILE: backend\auth-service\src\utils\jwt.ts
------------------------------------------------------------
import jwt, { type JwtPayload, type Secret, type SignOptions } from 'jsonwebtoken';
import type { StringValue } from 'ms';
import { env } from '../config/env.js';

const accessOpts: SignOptions = { expiresIn: env.ACCESS_TTL as StringValue };
const refreshOpts: SignOptions = { expiresIn: env.REFRESH_TTL as StringValue };

export function signAccess(payload: JwtPayload | string | object) {
  return jwt.sign(payload as any, env.JWT_ACCESS_SECRET as Secret, accessOpts);
}

export function signRefresh(payload: JwtPayload | string | object) {
  return jwt.sign(payload as any, env.JWT_REFRESH_SECRET as Secret, refreshOpts);
}

export function verifyAccess(token: string) {
  return jwt.verify(token, env.JWT_ACCESS_SECRET as Secret);
}

export function verifyRefresh(token: string) {
  return jwt.verify(token, env.JWT_REFRESH_SECRET as Secret);
}



------------------------------------------------------------
FILE: backend\auth-service\src\utils\password.ts
------------------------------------------------------------
import bcrypt from 'bcryptjs';
export async function hashPassword(pw: string) { return bcrypt.hash(pw, 12); }
export async function verifyPassword(pw: string, hash: string) { return bcrypt.compare(pw, hash); }



====================================================================================================
  DATA SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\data-service\src\app.ts
------------------------------------------------------------
import compression from 'compression';
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';

import { config, validateConfig } from './config/env';
import { logger } from './utils/logger';

// Probes & errors
import { errorHandler, notFoundHandler, requestIdMiddleware } from './middleware/error';
import { defaultRateLimit } from './middleware/rateLimit';

// Routes
import assetRoutes from './routes/assets';
import dataSourceRoutes from './routes/dataSources';
import sourceRoutes from './routes/sources';

// Services
import { DatabaseService } from './services/DatabaseService';

// Async wrapper
const asyncHandler =
  (fn: express.RequestHandler): express.RequestHandler =>
    (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next);

class App {
  public app: express.Application;
  private dbService: DatabaseService;
  public ready = false;

  constructor() {
    this.app = express();
    this.dbService = new DatabaseService();

    this.validateEnvironment();

    // 1) Probes FIRST (no external deps)
    this.registerProbes();

    // 2) Base middleware (safe)
    this.registerBaseMiddleware();

    // 3) Dependent middleware
    this.registerDependentMiddleware();

    // 4) API routes
    this.registerApiRoutes();

    // 5) Errors
    this.registerErrorHandlers();
  }

  private validateEnvironment(): void {
    try {
      validateConfig();
      logger.info('Environment validation passed');
    } catch (error) {
      logger.error('Environment validation failed:', error);
      process.exit(1);
    }
  }

  /** Liveness/readiness */
  private registerProbes(): void {
    this.app.get('/health', (_req, res) => {
      res.status(200).json({
        status: 'ok',
        service: 'cwic-data-service',
        env: config.server.env,
        uptimeSec: Math.round(process.uptime()),
      });
    });
    this.app.head('/health', (_req, res) => res.sendStatus(200));

    this.app.get('/ready', asyncHandler(async (_req, res) => {
      const dbHealth = await this.dbService.healthCheck().catch((e: any) => ({
        status: 'unhealthy',
        error: e?.message || String(e),
      }));
      const good = dbHealth.status === 'healthy';
      this.ready = good;
      res.status(good ? 200 : 503).json({ status: good ? 'ready' : 'not_ready', database: dbHealth });
    }));
    this.app.head('/ready', asyncHandler(async (_req, res) => {
      const dbHealth = await this.dbService.healthCheck().catch(() => ({ status: 'unhealthy' }));
      res.sendStatus(dbHealth.status === 'healthy' ? 200 : 503);
    }));
  }

  private registerBaseMiddleware(): void {
    this.app.use(helmet(config.security.helmet));

    const origins =
      Array.isArray(config.server.corsOrigin) ? config.server.corsOrigin : [config.server.corsOrigin || '']
        .concat((process.env.CORS_ORIGIN || '').split(','))
        .map(s => s.trim()).filter(Boolean);

    this.app.use(cors({
      origin: origins.length ? origins : true,
      credentials: true,
      methods: ['GET','POST','PUT','DELETE','PATCH','OPTIONS'],
      allowedHeaders: [
        'Content-Type','Authorization','X-Request-ID','X-API-Key',
        'X-Client-Env','X-Client-Version','X-Client-Type','X-Platform','X-Health-Check','X-Dev-Auth'
      ],
      exposedHeaders: ['X-Request-Id'],
      maxAge: 86400,
    }));

    this.app.use(compression());
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));
  }

  private registerDependentMiddleware(): void {
    this.app.use(requestIdMiddleware);
    this.app.use(defaultRateLimit);

    this.app.use((req, res, next) => {
      const t0 = Date.now();
      res.on('finish', () => {
        logger.info('HTTP Request', {
          method: req.method,
          url: req.originalUrl || req.url,
          statusCode: res.statusCode,
          durationMs: Date.now() - t0,
          requestId: (req as any).requestId,
          userAgent: req.get('User-Agent'),
          ip: req.ip,
        });
      });
      next();
    });
  }

  private registerApiRoutes(): void {
    // Prometheus metrics (optional)
    if (config.monitoring.enableMetrics) {
      this.app.get('/metrics', asyncHandler(async (_req, res) => {
        let pool = { total: 0, idle: 0, waiting: 0 };
        try { pool = this.dbService.getPoolStats(); } catch {}
        const mu = process.memoryUsage();
        const lines = [
          '# HELP cwic_data_service_uptime_seconds Total uptime of the service',
          '# TYPE cwic_data_service_uptime_seconds counter',
          `cwic_data_service_uptime_seconds ${process.uptime()}`,
          '# HELP cwic_data_service_memory_usage_bytes Memory usage in bytes',
          '# TYPE cwic_data_service_memory_usage_bytes gauge',
          `cwic_data_service_memory_usage_bytes{type="rss"} ${mu.rss}`,
          `cwic_data_service_memory_usage_bytes{type="heapTotal"} ${mu.heapTotal}`,
          `cwic_data_service_memory_usage_bytes{type="heapUsed"} ${mu.heapUsed}`,
          '# HELP cwic_data_service_db_connections Database connection pool stats',
          '# TYPE cwic_data_service_db_connections gauge',
          `cwic_data_service_db_connections{state="total"} ${pool.total}`,
          `cwic_data_service_db_connections{state="idle"} ${pool.idle}`,
          `cwic_data_service_db_connections{state="waiting"} ${pool.waiting}`,
        ];
        res.set('Content-Type','text/plain; version=0.0.4');
        res.send(lines.join('\n'));
      }));
    }

    /**
     * IMPORTANT: Your gateway sometimes **strips `/api`** in dev.
     * Mount at BOTH `/api/*` and root to be robust.
     */
    // Data sources
    this.app.use('/api/data-sources', dataSourceRoutes);
    this.app.use('/data-sources',     dataSourceRoutes);

    // Assets
    this.app.use('/api/assets', assetRoutes);
    this.app.use('/assets',     assetRoutes);

    // Sources
    this.app.use('/api/sources', sourceRoutes);
    this.app.use('/sources',     sourceRoutes);

    // Index
    const indexHandler: express.RequestHandler = (_req, res) => {
      res.json({
        service: 'CWIC Data Service',
        version: process.env.npm_package_version || '1.0.0',
        docs: {
          '/api/data-sources': 'Data source management',
          '/api/assets':       'Data asset management',
          '/api/sources':      'Source configuration',
          '/health':           'Liveness (no deps)',
          '/ready':            'Readiness (checks DB)',
          '/metrics':          'Prometheus metrics',
        },
      });
    };
    this.app.get('/api', indexHandler);
    this.app.get('/', indexHandler);
  }

  private registerErrorHandlers(): void {
    this.app.use(notFoundHandler);
    this.app.use(errorHandler);
  }

  public async initialize(): Promise<void> {
    try {
      logger.info('Initializing database (migrations + connectivity)...');
      await this.dbService.runMigrations();
      const dbHealth = await this.dbService.healthCheck();
      if (dbHealth.status !== 'healthy') {
        throw new Error(`Database is not healthy: ${dbHealth.error}`);
      }
      this.ready = true;
      logger.info('Database initialized; service READY.');
    } catch (err) {
      this.ready = false;
      logger.error('App initialization failed (service NOT ready):', err);
    }
  }

  public getExpressApp(): express.Application { return this.app; }
  public getDbService(): DatabaseService { return this.dbService; }
}

export default App;



------------------------------------------------------------
FILE: backend\data-service\src\config\env.ts
------------------------------------------------------------
// backend/data-service/src/config/env.ts
import dotenv from 'dotenv';
import path from 'path';
import { URL } from 'url';

dotenv.config({ path: path.resolve(process.cwd(), '.env') });

export interface Config {
  server: {
    port: number;
    host: string;
    env: string;
    corsOrigin: string | string[];
    serviceName: string;
  };
  database: {
    url: string;
    host: string;
    port: number;
    name: string;
    user: string;
    password: string;
    ssl: boolean;
    poolMax: number;
    poolMin: number;
    idleTimeout: number;
    connectionTimeout: number;
  };
  security: {
    jwtSecret: string;
    jwtExpiresIn: string;
    helmet: {
      contentSecurityPolicy: boolean;
      crossOriginEmbedderPolicy: boolean;
    };
  };
  monitoring: {
    enableMetrics: boolean;
    enableHealthCheck: boolean;
  };
  logging: {
    level: string;
    enableFileLogging: boolean;
  };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function coerceBool(v: unknown, def = false): boolean {
  const s = String(v ?? '').trim().toLowerCase();
  if (!s) return def;
  return s === '1' || s === 'true' || s === 'yes' || s === 'on';
}

function coerceInt(v: unknown, def: number): number {
  const n = Number(v);
  return Number.isFinite(n) ? n : def;
}

/** Accept CSV or leave string; if empty, default to dev origins */
function resolveCorsOrigin(raw?: string): string | string[] {
  if (!raw) return ['http://localhost:5173', 'http://localhost:3000', 'http://localhost:8000'];
  const parts = raw.split(',').map((o) => o.trim()).filter(Boolean);
  return parts.length <= 1 ? (parts[0] ?? '') : parts;
}

/** Strip accidental "DATABASE_URL=" prefix and surrounding quotes */
function normalizeDatabaseUrl(input?: string): string {
  let v = (input ?? '').trim();
  if (!v) return '';
  if (/^DATABASE_URL=/i.test(v)) v = v.replace(/^DATABASE_URL=/i, '').trim();
  if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) {
    v = v.slice(1, -1);
  }
  return v;
}

/** Parse PostgreSQL/MySQL/MSSQL-style URL */
function parseDatabaseUrl(url: string): {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
} {
  const normalized = normalizeDatabaseUrl(url);
  try {
    const u = new URL(normalized);
    return {
      host: u.hostname,
      port: parseInt(u.port) || 5432,
      database: u.pathname.replace(/^\//, ''),
      user: decodeURIComponent(u.username),
      password: decodeURIComponent(u.password),
    };
  } catch {
    throw new Error(`Invalid DATABASE_URL format: ${normalized}`);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ load & build config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const rawDbUrl = process.env.DATABASE_URL || 'postgresql://cwic_user:cwic_secure_pass@localhost:5432/cwic_platform';
const databaseUrl = normalizeDatabaseUrl(rawDbUrl);
const parsedDb = parseDatabaseUrl(databaseUrl);

export const config: Config = {
  server: {
    port: coerceInt(process.env.PORT, 3002),
    host: process.env.HOST || '0.0.0.0',
    env: process.env.NODE_ENV || 'development',
    corsOrigin: resolveCorsOrigin(process.env.CORS_ORIGIN),
    serviceName: process.env.SERVICE_NAME || 'data-service',
  },
  database: {
    url: databaseUrl,
    host: parsedDb.host,
    port: parsedDb.port,
    name: parsedDb.database,
    user: parsedDb.user,
    password: parsedDb.password,
    ssl: coerceBool(process.env.DB_SSL, process.env.NODE_ENV === 'production'),
    poolMax: coerceInt(process.env.DB_POOL_MAX, 20),
    poolMin: coerceInt(process.env.DB_POOL_MIN, 2),
    idleTimeout: coerceInt(process.env.DB_IDLE_TIMEOUT, 30_000),
    connectionTimeout: coerceInt(process.env.DB_CONNECTION_TIMEOUT, 10_000),
  },
  security: {
    jwtSecret: process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '7d',
    helmet: {
      contentSecurityPolicy: process.env.NODE_ENV === 'production',
      crossOriginEmbedderPolicy: false,
    },
  },
  monitoring: {
    enableMetrics: coerceBool(process.env.ENABLE_METRICS, process.env.NODE_ENV === 'production'),
    enableHealthCheck: process.env.ENABLE_HEALTH_CHECK !== 'false',
  },
  logging: {
    level: process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug'),
    enableFileLogging: coerceBool(process.env.ENABLE_FILE_LOGGING, process.env.NODE_ENV === 'production'),
  },
};

export const isProduction = config.server.env === 'production';

/** Small shim for modules that expect `env.JWT_SECRET` etc. */
export const env = {
  NODE_ENV: config.server.env,
  PORT: String(config.server.port),
  HOST: config.server.host,
  SERVICE_NAME: config.server.serviceName,
  JWT_SECRET: config.security.jwtSecret,
  JWT_EXPIRES_IN: config.security.jwtExpiresIn,
  DATABASE_URL: config.database.url,
  LOG_LEVEL: config.logging.level,
  CORS_ORIGIN: Array.isArray(config.server.corsOrigin)
    ? config.server.corsOrigin.join(',')
    : config.server.corsOrigin,
} as const;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ validation & logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export const validateConfig = (): void => {
  if (!config.database.url) throw new Error('DATABASE_URL environment variable is required');

  // Re-validate URL (throws with normalized string if bad)
  parseDatabaseUrl(config.database.url);

  // Ports
  if (config.server.port < 1 || config.server.port > 65535) {
    throw new Error('Server port must be between 1 and 65535');
  }
  if (config.database.port < 1 || config.database.port > 65535) {
    throw new Error('Database port must be between 1 and 65535');
  }

  // JWT secret length in prod
  if (isProduction && config.security.jwtSecret.length < 32) {
    throw new Error('JWT secret must be at least 32 characters long in production');
  }

  // Pool sizes
  if (config.database.poolMax < config.database.poolMin) {
    throw new Error('Database pool max must be greater than or equal to pool min');
  }

  // CORS origins are URLs if provided as strings; arrays can include plain origins
  const origins = Array.isArray(config.server.corsOrigin)
    ? config.server.corsOrigin
    : [config.server.corsOrigin];
  origins.forEach((origin) => {
    if (!origin) return;
    try {
      // Allow wildcard-like strings only if exactly "*"
      if (origin === '*') return;
      new URL(origin);
    } catch {
      throw new Error(`Invalid CORS_ORIGIN URL: ${origin}`);
    }
  });
};

export const logConfig = (): void => {
  console.log('ðŸ”§ Service Configuration:');
  console.log(`   Service: ${config.server.serviceName}`);
  console.log(`   Port: ${config.server.port}`);
  console.log(`   Host: ${config.server.host}`);
  console.log(`   Environment: ${config.server.env}`);
  console.log(
    `   CORS Origin: ${
      Array.isArray(config.server.corsOrigin) ? config.server.corsOrigin.join(', ') : config.server.corsOrigin
    }`
  );
  console.log(`   Database: ${config.database.host}:${config.database.port}/${config.database.name}`);
  console.log(`   Database User: ${config.database.user}`);
  console.log(`   SSL: ${config.database.ssl ? 'enabled' : 'disabled'}`);
  console.log(`   Pool Max: ${config.database.poolMax}`);
  console.log(`   Pool Min: ${config.database.poolMin}`);
  console.log(`   Metrics: ${config.monitoring.enableMetrics ? 'enabled' : 'disabled'}`);
  console.log(`   Log Level: ${config.logging.level}`);
  console.log('');
};



------------------------------------------------------------
FILE: backend\data-service\src\controllers\AssetController.ts
------------------------------------------------------------
// backend/data-service/src/controllers/AssetController.ts
import { Request, Response } from 'express';
import { AssetService } from '../services/AssetService';
import { logger, loggerUtils } from '../utils/logger';

export interface AssetRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

export interface Column {
  name: string;
  type: string;
  nullable: boolean;
  primaryKey: boolean;
  foreignKey?: { table: string; column: string };
  description?: string;
  tags?: string[];
}

export interface Asset {
  id: string;
  name: string;
  type:
    | 'table'
    | 'view'
    | 'procedure'
    | 'function'
    | 'schema'
    | 'file'
    | 'api_endpoint'
    | 'stream'
    | 'model';
  dataSourceId: string;
  schemaName?: string;
  tableName?: string;
  description?: string;
  columns?: Column[];
  tags?: string[];
  status: 'active' | 'inactive' | 'deprecated';
  classification?: 'public' | 'internal' | 'confidential' | 'restricted';
  createdAt: Date;
  updatedAt: Date;
  metadata?: {
    rowCount?: number;
    size?: string;
    lastAccessed?: Date;
    sensitivity?: 'public' | 'internal' | 'confidential' | 'restricted';
  };
}

type LineageDirection = 'upstream' | 'downstream' | 'both';

type ListFilters = {
  search?: string;
  type?: string;
  dataSourceId?: string;
  status?: string;
  tags?: string[];
  sensitivity?: string;
};

type Pagination = { page: number; limit: number };

export class AssetController {
  private assetService: AssetService;

  constructor() {
    this.assetService = new AssetService();
  }

  /**
   * GET /api/assets
   */
  public getAllAssets = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const {
        page = '1',
        limit = '20',
        search,
        type,
        dataSourceId,
        status,
        tags,
        sensitivity,
      } = req.query;

      const filters: ListFilters = {
        search: typeof search === 'string' ? search : undefined,
        type: typeof type === 'string' ? type : undefined,
        dataSourceId: typeof dataSourceId === 'string' ? dataSourceId : undefined,
        status: typeof status === 'string' ? status : undefined,
        tags:
          typeof tags === 'string'
            ? tags
                .split(',')
                .map((s) => s.trim())
                .filter(Boolean)
            : undefined,
        sensitivity: typeof sensitivity === 'string' ? sensitivity : undefined,
      };

      const pagination: Pagination = {
        page: Number(page) || 1,
        limit: Number(limit) || 20,
      };

      const t0 = Date.now();
      const result = await this.assetService.getAssets(filters, pagination);
      const dt = Date.now() - t0;

      loggerUtils.logDbOperation('select', 'assets', dt, true);

      res.status(200).json({
        success: true,
        data: result.assets,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages,
        },
        meta: {
          processingTime: `${dt}ms`,
          filters,
        },
      });
    } catch (error) {
      logger.error('Error fetching assets:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_ASSETS_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/:id
   */
  public getAssetById = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;

      const t0 = Date.now();
      const asset = await this.assetService.getAssetById(id);
      const dt = Date.now() - t0;

      if (!asset) {
        res.status(404).json({ success: false, error: 'NOT_FOUND', message: 'Asset not found' });
        return;
      }

      loggerUtils.logDbOperation('select', 'assets', dt, true);

      res.status(200).json({
        success: true,
        data: asset,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error fetching asset:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_ASSET_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/:id/schema
   */
  public getAssetSchema = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;

      const t0 = Date.now();
      const schema = await this.assetService.getAssetSchema(id);
      const dt = Date.now() - t0;

      if (!schema) {
        res.status(404).json({ success: false, error: 'NOT_FOUND', message: 'Asset schema not found' });
        return;
      }

      res.status(200).json({
        success: true,
        data: schema,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error fetching asset schema:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_SCHEMA_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/:id/lineage
   */
  public getAssetLineage = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const direction = (req.query.direction as LineageDirection) || 'both';

      const t0 = Date.now();
      const lineage = await this.assetService.getAssetLineage(id, direction);
      const dt = Date.now() - t0;

      res.status(200).json({
        success: true,
        data: lineage,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error fetching asset lineage:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_LINEAGE_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/:id/profile
   */
  public getAssetProfile = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;

      const t0 = Date.now();
      const profile = await this.assetService.getAssetProfile(id);
      const dt = Date.now() - t0;

      if (!profile) {
        res.status(404).json({
          success: false,
          error: 'NOT_FOUND',
          message: 'Asset profile not found',
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: profile,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error fetching asset profile:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_PROFILE_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * POST /api/assets
   */
  public createAsset = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const assetData = req.body;

      const t0 = Date.now();
      const newAsset = await this.assetService.createAsset(assetData);
      const dt = Date.now() - t0;

      loggerUtils.logDbOperation('insert', 'assets', dt, true);
      logger.info(`Asset created: ${newAsset?.id}`, { userId: req.user?.id });

      res.status(201).json({
        success: true,
        data: newAsset,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error creating asset:', error);
      res.status(500).json({
        success: false,
        error: 'CREATE_ASSET_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * PUT /api/assets/:id
   */
  public updateAsset = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const t0 = Date.now();
      const updatedAsset = await this.assetService.updateAsset(id, updateData);
      const dt = Date.now() - t0;

      if (!updatedAsset) {
        res.status(404).json({ success: false, error: 'NOT_FOUND', message: 'Asset not found' });
        return;
      }

      loggerUtils.logDbOperation('update', 'assets', dt, true);
      logger.info(`Asset updated: ${id}`, { userId: req.user?.id });

      res.status(200).json({
        success: true,
        data: updatedAsset,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error updating asset:', error);
      res.status(500).json({
        success: false,
        error: 'UPDATE_ASSET_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * PUT /api/assets/:id/classification
   */
  public updateClassification = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { classification } = req.body as { classification: Asset['classification'] };

      const t0 = Date.now();
      const updated =
        typeof (this.assetService as any).updateClassification === 'function'
          ? await (this.assetService as any).updateClassification(id, { classification })
          : await this.assetService.updateAsset(id, { classification });
      const dt = Date.now() - t0;

      if (!updated) {
        res.status(404).json({ success: false, error: 'NOT_FOUND', message: 'Asset not found' });
        return;
      }

      loggerUtils.logDbOperation('update', 'assets', dt, true);

      res.status(200).json({
        success: true,
        data: updated,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error updating asset classification:', error);
      res.status(500).json({
        success: false,
        error: 'UPDATE_CLASSIFICATION_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * POST /api/assets/:id/tag
   */
  public addTags = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { tags } = req.body as { tags: string[] };

      if (!Array.isArray(tags)) {
        res
          .status(400)
          .json({ success: false, error: 'VALIDATION_ERROR', message: 'Tags must be an array' });
        return;
      }

      const t0 = Date.now();
      const result = await this.assetService.addTags(id, tags);
      const dt = Date.now() - t0;

      loggerUtils.logDbOperation('update', 'asset_tags', dt, true);

      res.status(200).json({
        success: true,
        data: result,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error adding tags:', error);
      res.status(500).json({
        success: false,
        error: 'ADD_TAGS_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * DELETE /api/assets/:id/tag
   */
  public removeTags = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { tags } = req.body as { tags: string[] };

      if (!Array.isArray(tags)) {
        res
          .status(400)
          .json({ success: false, error: 'VALIDATION_ERROR', message: 'Tags must be an array' });
        return;
      }

      const t0 = Date.now();
      const result = await this.assetService.removeTags(id, tags);
      const dt = Date.now() - t0;

      loggerUtils.logDbOperation('update', 'asset_tags', dt, true);

      res.status(200).json({
        success: true,
        data: result,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error removing tags:', error);
      res.status(500).json({
        success: false,
        error: 'REMOVE_TAGS_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/stats  (global)
   */
  public getAssetStats = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { period = '30d' } = req.query as { period?: string };

      const t0 = Date.now();
      // Prefer a dedicated overview method if it exists
      const stats =
        typeof (this.assetService as any).getOverviewStats === 'function'
          ? await (this.assetService as any).getOverviewStats(period)
          : await this.assetService.getAssets({}, { page: 1, limit: 1 }).then((r) => ({
              totalAssets: r.total,
            }));

      const dt = Date.now() - t0;

      res.status(200).json({
        success: true,
        data: stats,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error fetching asset stats:', error);
      res.status(500).json({
        success: false,
        error: 'FETCH_STATS_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * POST /api/assets/:id/scan
   */
  public scanAsset = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const { type = 'full', force = false } = req.body as {
        type?: 'full' | 'incremental' | 'schema_only' | 'profile_only';
        force?: boolean;
      };

      const t0 = Date.now();
      const result =
        typeof (this.assetService as any).scanAsset === 'function'
          ? await (this.assetService as any).scanAsset(id, { type, force })
          : await (this.assetService as any).syncAsset(id, { type, force }); // cast to any to avoid arity/type mismatch
      const dt = Date.now() - t0;

      logger.info(`Asset scan triggered: ${id}`, { userId: req.user?.id, type, force, duration: `${dt}ms` });

      res.status(200).json({
        success: true,
        data: result,
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error scanning asset:', error);
      res.status(500).json({
        success: false,
        error: 'SCAN_ASSET_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * DELETE /api/assets/:id
   */
  public deleteAsset = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { id } = req.params;

      const t0 = Date.now();
      const deleted =
        typeof (this.assetService as any).deleteAsset === 'function'
          ? await (this.assetService as any).deleteAsset(id)
          : await this.assetService.updateAsset(id, { status: 'inactive' as Asset['status'] });
      const dt = Date.now() - t0;

      if (!deleted) {
        res.status(404).json({ success: false, error: 'NOT_FOUND', message: 'Asset not found' });
        return;
      }

      loggerUtils.logDbOperation('delete', 'assets', dt, true);

      res.status(200).json({
        success: true,
        data: { id, deleted: true },
        meta: { processingTime: `${dt}ms` },
      });
    } catch (error) {
      logger.error('Error deleting asset:', error);
      res.status(500).json({
        success: false,
        error: 'DELETE_ASSET_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  /**
   * GET /api/assets/search
   */
  public searchAssets = async (req: AssetRequest, res: Response): Promise<void> => {
    try {
      const { q, type, limit = '20', page = '1' } = req.query;

      // Ensure `search` is a string (service expects a required string)
      const searchTerm: string = typeof q === 'string' ? q : '';

      const filters: { search: string; type?: string } = {
        search: searchTerm,
        type: typeof type === 'string' ? type : undefined,
      };

      const pagination: Pagination = {
        page: Number(page) || 1,
        limit: Number(limit) || 20,
      };

      const t0 = Date.now();
      const result = await this.assetService.searchAssets(filters, pagination);
      const dt = Date.now() - t0;

      loggerUtils.logDbOperation('select', 'assets', dt, true);

      res.status(200).json({
        success: true,
        data: result.assets,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages,
        },
        meta: {
          processingTime: `${dt}ms`,
          query: filters.search,
        },
      });
    } catch (error) {
      logger.error('Error searching assets:', error);
      res.status(500).json({
        success: false,
        error: 'SEARCH_ASSETS_FAILED',
        message: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };
}

export default AssetController;



------------------------------------------------------------
FILE: backend\data-service\src\controllers\DataSourceController.ts
------------------------------------------------------------
// backend/data-service/src/controllers/DataSourceController.ts
import { Request, Response } from 'express';
import { ConnectionTestService } from '../services/ConnectionTestService';
import { DataSourceService } from '../services/DataSourceService';
import { logger } from '../utils/logger';

import type {
  DataSource,
  DataSourceFilters,
  DataSourceStatus,
  DataSourceType,
} from '../models/DataSource';

type ReqWithUser = Request & { user?: { id?: string; email?: string; role?: string } };

const normalizeType = (t?: string): DataSourceType | undefined => {
  if (!t) return undefined;
  const x = String(t).toLowerCase();
  if (['azure_sql','azure-sql','sqlserver','sql-server'].includes(x)) return 'mssql' as DataSourceType;
  if (x === 'postgres') return 'postgresql' as DataSourceType;
  return x as DataSourceType;
};

const buildFilters = (q: Request['query']): DataSourceFilters => {
  const filters: DataSourceFilters = {};
  if (typeof q.status === 'string' && q.status.trim()) {
    filters.status = q.status.toLowerCase() as DataSourceStatus;
  }
  if (typeof q.type === 'string' && q.type.trim()) {
    filters.type = normalizeType(q.type) as DataSourceType;
  }
  if (typeof q.createdBy === 'string' && q.createdBy.trim()) {
    filters.createdBy = q.createdBy;
  }
  if (typeof q.search === 'string' && q.search.trim()) {
    filters.search = q.search.trim();
  }
  return filters;
};

const toInt = (v: unknown, def: number): number => {
  const n = Number(v);
  return Number.isFinite(n) && n > 0 ? n : def;
};

const allowedSortBy = new Set(['updatedAt','createdAt','name','status','type'] as const);
const normSortBy = (v: unknown): 'updatedAt'|'createdAt'|'name'|'status'|'type' =>
  allowedSortBy.has(String(v || '') as any) ? (String(v) as any) : 'updatedAt';
const normSortOrder = (v: unknown): 'asc'|'desc' =>
  String(v || '').toLowerCase() === 'asc' ? 'asc' : 'desc';

export class DataSourceController {
  private dataSourceService = new DataSourceService();
  private connectionTestService = new ConnectionTestService();

  getAllDataSources = async (req: Request, res: Response) => {
    try {
      const page = toInt(req.query.page, 1);
      const limit = toInt(req.query.limit, 20);
      const filters = buildFilters(req.query);
      const sortBy = normSortBy(req.query.sortBy);
      const sortOrder = normSortOrder(req.query.sortOrder);

      const result = await this.dataSourceService.getAllDataSources({
        page, limit, filters, sortBy, sortOrder,
      });

      res.json({
        success: true,
        data: result.dataSources,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages,
          sortBy, sortOrder,
        },
      });
    } catch (error) {
      logger.error('Error fetching data sources:', error);
      res.status(500).json({ success: false, error: { code: 'FETCH_ERROR', message: 'Failed to fetch data sources' } });
    }
  };

  getDataSourceById = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const ds = await this.dataSourceService.getDataSourceById(id);
      if (!ds) {
        res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Data source not found' } });
        return;
      }
      res.json({ success: true, data: ds });
    } catch (error) {
      logger.error('Error fetching data source:', error);
      res.status(500).json({ success: false, error: { code: 'FETCH_ERROR', message: 'Failed to fetch data source' } });
    }
  };

  createDataSource = async (req: Request, res: Response) => {
    try {
      const payload = req.body;

      const err = this.validateDataSourceData(payload);
      if (err) {
        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: err } });
        return;
      }

      const test = await this.connectionTestService.testConnection(payload);
      if (!test.success) {
        res.status(400).json({
          success: false,
          error: { code: 'CONNECTION_FAILED', message: 'Failed to connect to data source', details: test.error },
        });
        return;
      }

      const userId = (req as ReqWithUser).user?.id ?? 'system';

      const created = await this.dataSourceService.createDataSource({
        ...payload,
        type: normalizeType(payload.type) ?? payload.type,
        status: 'connected',
        lastTestAt: new Date(),
        createdBy: userId,
      });

      res.status(201).json({ success: true, data: created });
    } catch (error) {
      logger.error('Error creating data source:', error);
      res.status(500).json({ success: false, error: { code: 'CREATE_ERROR', message: 'Failed to create data source' } });
    }
  };

  updateDataSource = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const patch = req.body;
      const userId = (req as ReqWithUser).user?.id ?? 'system';

      const updated = await this.dataSourceService.updateDataSource(id, {
        ...patch,
        ...(patch.type ? { type: normalizeType(patch.type) } : {}),
        updatedBy: userId,
        updatedAt: new Date(),
      });

      if (!updated) {
        res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Data source not found' } });
        return;
      }
      res.json({ success: true, data: updated });
    } catch (error) {
      logger.error('Error updating data source:', error);
      res.status(500).json({ success: false, error: { code: 'UPDATE_ERROR', message: 'Failed to update data source' } });
    }
  };

  deleteDataSource = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const ok = await this.dataSourceService.deleteDataSource(id);
      if (!ok) {
        res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Data source not found' } });
        return;
      }
      res.json({ success: true, message: 'Data source deleted successfully' });
    } catch (error) {
      logger.error('Error deleting data source:', error);
      res.status(500).json({ success: false, error: { code: 'DELETE_ERROR', message: 'Failed to delete data source' } });
    }
  };

  testConnection = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const ds = await this.dataSourceService.getDataSourceById(id);
      if (!ds) {
        res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Data source not found' } });
        return;
      }

      const result = await this.connectionTestService.testConnection(ds);
      const patch: Partial<DataSource> = {
        lastTestAt: new Date(),
        status: (result.success ? 'connected' : 'error') as DataSourceStatus,
      };
      if (!result.success) patch.lastError = result.error || 'Connection test failed';

      await this.dataSourceService.updateDataSource(id, patch);

      res.json({
        success: true,
        data: {
          connectionStatus: result.success ? 'connected' : 'failed',
          responseTime: result.responseTime,
          details: result.details,
          error: result.error,
          testedAt: new Date(),
        },
      });
    } catch (error) {
      logger.error('Error testing connection:', error);
      res.status(500).json({ success: false, error: { code: 'TEST_ERROR', message: 'Failed to test connection' } });
    }
  };

  getHealthSummary = async (_req: Request, res: Response) => {
    try {
      const summary = await this.dataSourceService.getHealthSummary();
      res.json({ success: true, data: summary });
    } catch (error) {
      logger.error('Error fetching health summary:', error);
      res.status(500).json({ success: false, error: { code: 'HEALTH_ERROR', message: 'Failed to fetch health summary' } });
    }
  };

  getDataSourceSchema = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const schema = await this.dataSourceService.getDataSourceSchema(id);
      res.json({ success: true, data: schema });
    } catch (error) {
      logger.error('Error fetching schema:', error);
      res.status(500).json({ success: false, error: { code: 'SCHEMA_ERROR', message: 'Failed to fetch data source schema' } });
    }
  };

  syncDataSource = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { force = false } = req.body ?? {};
      const result = await this.dataSourceService.syncDataSource(id, { force: !!force });
      res.json({ success: true, data: result });
    } catch (error) {
      logger.error('Error syncing data source:', error);
      res.status(500).json({ success: false, error: { code: 'SYNC_ERROR', message: 'Failed to sync data source' } });
    }
  };

  private validateDataSourceData(data: any): string | null {
  if (!data?.name) return 'Name is required';
  if (!data?.type) return 'Type is required';
  if (!data?.connectionConfig) return 'Connection configuration is required';

  const t = normalizeType(data.type);

  const hasConnStr = !!data.connectionConfig.connectionString;
  const hasHostDb  = !!(data.connectionConfig.host && data.connectionConfig.database);

  switch (t) {
    case 'postgresql':
    case 'mysql':
    case 'mssql':
    case 'oracle':
    case 'redshift':
      if (!hasConnStr && !hasHostDb) {
        return 'Provide either connectionString OR host + database for relational connections';
      }
      break;

    case 'mongodb':
      if (!hasConnStr && !data.connectionConfig.host) {
        return 'Provide connectionString or host for MongoDB';
      }
      break;

    case 's3':
      if (!data.connectionConfig.bucket) return 'Bucket is required for S3';
      break;

    case 'api':
      if (!data.connectionConfig.baseUrl) return 'Base URL is required for API connections';
      break;

    // other types: rely on connector-specific validation
  }

  return null;
}

}


------------------------------------------------------------
FILE: backend\data-service\src\db.ts
------------------------------------------------------------
// backend/data-service/src/db.ts - Updated with correct imports
import { Pool, PoolConfig } from 'pg';
import { config } from './config/env';
import { logger } from './utils/logger';

export interface DatabaseConfig extends PoolConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  ssl?: boolean | object;
  max?: number;
  min?: number;
  idleTimeoutMillis?: number;
  connectionTimeoutMillis?: number;
}

class Database {
  private pool: Pool;
  private static instance: Database;

  constructor() {
    const dbConfig: DatabaseConfig = {
      host: config.database.host,
      port: config.database.port,
      database: config.database.name,
      user: config.database.user,
      password: config.database.password,
      ssl: config.database.ssl ? { rejectUnauthorized: false } : false,
      max: config.database.poolMax,
      min: config.database.poolMin,
      idleTimeoutMillis: config.database.idleTimeout,
      connectionTimeoutMillis: config.database.connectionTimeout,
    };

    this.pool = new Pool(dbConfig);

    // Handle pool events
    this.pool.on('connect', (client) => {
      logger.debug('New database client connected', {
        totalConnections: this.pool.totalCount,
        idleConnections: this.pool.idleCount,
      });
    });

    this.pool.on('acquire', (client) => {
      logger.debug('Database client acquired from pool', {
        totalConnections: this.pool.totalCount,
        idleConnections: this.pool.idleCount,
        waitingClients: this.pool.waitingCount,
      });
    });

    this.pool.on('remove', (client) => {
      logger.debug('Database client removed from pool', {
        totalConnections: this.pool.totalCount,
        idleConnections: this.pool.idleCount,
      });
    });

    this.pool.on('error', (err, client) => {
      logger.error('Database pool error:', {
        error: err.message,
        stack: err.stack,
        totalConnections: this.pool.totalCount,
        idleConnections: this.pool.idleCount,
      });
    });

    logger.info('Database pool initialized', {
      host: dbConfig.host,
      port: dbConfig.port,
      database: dbConfig.database,
      maxConnections: dbConfig.max,
      minConnections: dbConfig.min,
      ssl: !!dbConfig.ssl,
    });
  }

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  public getPool(): Pool {
    return this.pool;
  }

  public async query(text: string, params?: any[]): Promise<any> {
    const start = Date.now();
    const queryId = Math.random().toString(36).substring(7);
    
    try {
      logger.debug('Database query started', {
        queryId,
        query: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
        paramCount: params?.length || 0,
      });

      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      
      logger.debug('Database query completed', {
        queryId,
        duration: `${duration}ms`,
        rowCount: result.rowCount,
        command: result.command,
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      logger.error('Database query failed', {
        queryId,
        query: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
        duration: `${duration}ms`,
        error: error instanceof Error ? error.message : 'Unknown error',
        paramCount: params?.length || 0,
      });
      throw error;
    }
  }

  public async transaction<T>(callback: (client: any) => Promise<T>): Promise<T> {
    const client = await this.pool.connect();
    const transactionId = Math.random().toString(36).substring(7);
    
    try {
      await client.query('BEGIN');
      logger.debug('Database transaction started', { transactionId });
      
      const result = await callback(client);
      
      await client.query('COMMIT');
      logger.debug('Database transaction committed', { transactionId });
      
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      logger.error('Database transaction rolled back', {
        transactionId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    } finally {
      client.release();
      logger.debug('Database transaction client released', { transactionId });
    }
  }

  public async healthCheck(): Promise<{
    status: 'healthy' | 'unhealthy';
    latency?: number;
    connections?: {
      total: number;
      idle: number;
      waiting: number;
    };
    error?: string;
    timestamp: string;
  }> {
    const start = Date.now();
    
    try {
      // Simple connectivity test
      await this.pool.query('SELECT 1 as health_check');
      const latency = Date.now() - start;
      
      return {
        status: 'healthy',
        latency,
        connections: {
          total: this.pool.totalCount,
          idle: this.pool.idleCount,
          waiting: this.pool.waitingCount
        },
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const latency = Date.now() - start;
      return {
        status: 'unhealthy',
        latency,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      };
    }
  }

  public async deepHealthCheck(): Promise<{
    status: 'healthy' | 'unhealthy';
    checks: {
      connectivity: boolean;
      writeable: boolean;
      performant: boolean;
    };
    latency: number;
    error?: string;
  }> {
    const start = Date.now();
    const checks = {
      connectivity: false,
      writeable: false,
      performant: false,
    };

    try {
      // Test connectivity
      await this.pool.query('SELECT 1');
      checks.connectivity = true;

      // Test write capability (create temp table and drop it)
      const tempTableName = `health_check_${Date.now()}`;
      await this.pool.query(`CREATE TEMP TABLE ${tempTableName} (id INTEGER)`);
      await this.pool.query(`INSERT INTO ${tempTableName} VALUES (1)`);
      await this.pool.query(`DROP TABLE ${tempTableName}`);
      checks.writeable = true;

      const latency = Date.now() - start;
      
      // Check if performance is acceptable (under 1 second)
      checks.performant = latency < 1000;

      return {
        status: Object.values(checks).every(Boolean) ? 'healthy' : 'unhealthy',
        checks,
        latency,
      };
    } catch (error) {
      const latency = Date.now() - start;
      return {
        status: 'unhealthy',
        checks,
        latency,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  public getStats(): {
    totalCount: number;
    idleCount: number;
    waitingCount: number;
  } {
    return {
      totalCount: this.pool.totalCount,
      idleCount: this.pool.idleCount,
      waitingCount: this.pool.waitingCount,
    };
  }

  public async getDetailedStats(): Promise<{
    pool: {
      totalCount: number;
      idleCount: number;
      waitingCount: number;
      maxConnections: number;
      minConnections: number;
    };
    database: {
      version: string;
      size: string;
      activeConnections: number;
    };
  }> {
    try {
      // Get database version
      const versionResult = await this.pool.query('SELECT version()');
      const version = versionResult.rows[0].version;

      // Get database size
      const sizeResult = await this.pool.query(`
        SELECT pg_size_pretty(pg_database_size(current_database())) as size
      `);
      const size = sizeResult.rows[0].size;

      // Get active connections count
      const connectionsResult = await this.pool.query(`
        SELECT count(*) as active_connections 
        FROM pg_stat_activity 
        WHERE state = 'active'
      `);
      const activeConnections = parseInt(connectionsResult.rows[0].active_connections);

      return {
        pool: {
          totalCount: this.pool.totalCount,
          idleCount: this.pool.idleCount,
          waitingCount: this.pool.waitingCount,
          maxConnections: config.database.poolMax,
          minConnections: config.database.poolMin,
        },
        database: {
          version: version.split(' ')[1], // Extract version number
          size,
          activeConnections,
        },
      };
    } catch (error) {
      logger.error('Error getting detailed database stats:', error);
      throw error;
    }
  }

  public async close(): Promise<void> {
    try {
      logger.info('Closing database pool...');
      await this.pool.end();
      logger.info('Database pool closed successfully');
    } catch (error) {
      logger.error('Error closing database pool:', error);
      throw error;
    }
  }

  // Migration and schema management
  public async runMigrations(): Promise<void> {
    try {
      logger.info('Running database migrations...');

      // Create migrations table if it doesn't exist
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS migrations (
          id SERIAL PRIMARY KEY,
          name VARCHAR(255) NOT NULL UNIQUE,
          executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);

      // List of migrations to run
      const migrations = [
        {
          name: '001_create_data_sources_table',
          sql: `
            CREATE TABLE IF NOT EXISTS data_sources (
              id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
              name VARCHAR(100) NOT NULL,
              type VARCHAR(50) NOT NULL,
              host VARCHAR(255),
              port INTEGER,
              database_name VARCHAR(100),
              username VARCHAR(100),
              password_encrypted TEXT,
              ssl BOOLEAN DEFAULT FALSE,
              connection_string TEXT,
              description TEXT,
              tags TEXT[] DEFAULT '{}',
              status VARCHAR(20) DEFAULT 'active',
              metadata JSONB DEFAULT '{}',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );
            CREATE INDEX IF NOT EXISTS idx_data_sources_type ON data_sources(type);
            CREATE INDEX IF NOT EXISTS idx_data_sources_status ON data_sources(status);
          `
        },
        {
          name: '002_create_assets_table',
          sql: `
            CREATE TABLE IF NOT EXISTS assets (
              id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
              name VARCHAR(100) NOT NULL,
              type VARCHAR(50) NOT NULL,
              data_source_id UUID NOT NULL REFERENCES data_sources(id) ON DELETE CASCADE,
              schema_name VARCHAR(100),
              table_name VARCHAR(100),
              description TEXT,
              columns JSONB DEFAULT '[]',
              tags TEXT[] DEFAULT '{}',
              status VARCHAR(20) DEFAULT 'active',
              metadata JSONB DEFAULT '{}',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );
            CREATE INDEX IF NOT EXISTS idx_assets_data_source_id ON assets(data_source_id);
            CREATE INDEX IF NOT EXISTS idx_assets_type ON assets(type);
            CREATE INDEX IF NOT EXISTS idx_assets_status ON assets(status);
          `
        },
        {
          name: '003_create_asset_lineage_table',
          sql: `
            CREATE TABLE IF NOT EXISTS asset_lineage (
              id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
              upstream_asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
              downstream_asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
              relationship_type VARCHAR(50) NOT NULL,
              description TEXT,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );
            CREATE INDEX IF NOT EXISTS idx_asset_lineage_upstream ON asset_lineage(upstream_asset_id);
            CREATE INDEX IF NOT EXISTS idx_asset_lineage_downstream ON asset_lineage(downstream_asset_id);
          `
        }
      ];

      for (const migration of migrations) {
        // Check if migration has already been run
        const result = await this.pool.query(
          'SELECT id FROM migrations WHERE name = $1',
          [migration.name]
        );

        if (result.rows.length === 0) {
          logger.info(`Running migration: ${migration.name}`);
          
          // Run migration in a transaction
          await this.transaction(async (client) => {
            await client.query(migration.sql);
            await client.query(
              'INSERT INTO migrations (name) VALUES ($1)',
              [migration.name]
            );
          });

          logger.info(`Migration completed: ${migration.name}`);
        } else {
          logger.debug(`Migration already applied: ${migration.name}`);
        }
      }

      logger.info('All migrations completed successfully');
    } catch (error) {
      logger.error('Migration failed:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const db = Database.getInstance();
export default db;


------------------------------------------------------------
FILE: backend\data-service\src\db\pool.ts
------------------------------------------------------------
// backend/data-service/src/db/pool.ts
import { Pool } from "pg";

const {
  DATABASE_URL,
  DB_POOL_MAX = "20",
  DB_IDLE_TIMEOUT = "30000",
  DB_CONNECTION_TIMEOUT = "10000",
  DB_SSL = "false",
} = process.env;

if (!DATABASE_URL) {
  throw new Error("DATABASE_URL is not set for data-service");
}

export const pool = new Pool({
  connectionString: DATABASE_URL,
  max: Number(DB_POOL_MAX),
  idleTimeoutMillis: Number(DB_IDLE_TIMEOUT),
  connectionTimeoutMillis: Number(DB_CONNECTION_TIMEOUT),
  ssl: String(DB_SSL).toLowerCase() === "true" ? { rejectUnauthorized: false } : undefined,
});

pool.on("error", (err) => {
  // Do not crash the process on idle client error; log and continue.
  console.error("[pg] Pool error:", err);
});



------------------------------------------------------------
FILE: backend\data-service\src\middleware\auth.ts
------------------------------------------------------------
// backend/data-service/src/middleware/auth.ts
import type { NextFunction, Request, Response } from 'express';
import jwt from 'jsonwebtoken';

const IS_PROD = (process.env.NODE_ENV || '').toLowerCase() === 'production';

function devBypass(req: Request): boolean {
  const hdr = (req.get('X-Dev-Auth') || req.get('x-dev-auth') || '').trim();
  const envSkip = (process.env.SKIP_AUTH || '').toLowerCase() === 'true';
  const envMock = (process.env.MOCK_AUTH || '').toLowerCase() === 'true';
  return !IS_PROD && (envSkip || envMock || hdr === '1');
}

function getJwtSecret(): string {
  const s = (process.env.JWT_SECRET || '').trim();
  if (s) return s;
  if (!IS_PROD) return 'devsecret';
  throw new Error('JWT is not configured (missing JWT_SECRET).');
}

function extractToken(req: Request): string | undefined {
  const h = (req.headers.authorization || req.headers.Authorization) as string | undefined;
  if (typeof h === 'string' && h.startsWith('Bearer ')) return h.slice(7).trim();
  const c = req.headers.cookie;
  if (c) {
    const m = c.match(/(?:^|;\s*)access_token=([^;]+)/i);
    if (m) return decodeURIComponent(m[1]);
  }
  return undefined;
}

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  if (devBypass(req)) return next();
  const token = extractToken(req);
  if (!token) return res.status(401).json({ success: false, error: 'Access denied. No token provided.' });
  try {
    const decoded = jwt.verify(token, getJwtSecret(), { algorithms: ['HS256'] });
    (req as any).user = decoded;
    next();
  } catch {
    return res.status(401).json({ success: false, error: 'Access denied. Invalid or expired token.' });
  }
}

export function optionalAuthMiddleware(req: Request, _res: Response, next: NextFunction) {
  if (devBypass(req)) return next();
  const token = extractToken(req);
  if (!token) return next();
  try {
    const decoded = jwt.verify(token, getJwtSecret(), { algorithms: ['HS256'] });
    (req as any).user = decoded;
  } catch {/* ignore */}
  next();
}



------------------------------------------------------------
FILE: backend\data-service\src\middleware\error.ts
------------------------------------------------------------
// backend/data-service/src/middleware/error.ts
import { NextFunction, Request, Response } from 'express';
import { isProduction } from '../config/env';
import { logger } from '../utils/logger';

export interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
    timestamp: string;
    requestId?: string;
  };
}

export class AppError extends Error {
  public statusCode: number;
  public code: string;
  public isOperational: boolean;
  public details?: any;

  constructor(
    message: string,
    statusCode: number = 500,
    code: string = 'INTERNAL_ERROR',
    isOperational: boolean = true,
    details?: any
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;
    this.details = details;
    Error.captureStackTrace?.(this, this.constructor);
  }
}

/** Factory used by other middleware/controllers */
export const createError = (
  message: string,
  statusCode: number = 500,
  code: string = 'INTERNAL_ERROR',
  details?: any
): AppError => new AppError(message, statusCode, code, true, details);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Common error types
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super(message, 400, 'VALIDATION_ERROR', true, details);
  }
}
export class NotFoundError extends AppError {
  constructor(resource: string = 'Resource') {
    super(`${resource} not found`, 404, 'NOT_FOUND', true);
  }
}
export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401, 'UNAUTHORIZED', true);
  }
}
export class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden') {
    super(message, 403, 'FORBIDDEN', true);
  }
}
export class ConflictError extends AppError {
  constructor(message: string = 'Resource already exists') {
    super(message, 409, 'CONFLICT', true);
  }
}
export class DatabaseError extends AppError {
  constructor(message: string, details?: any) {
    super(message, 500, 'DATABASE_ERROR', true, details);
  }
}
export class ExternalServiceError extends AppError {
  constructor(service: string, message: string, details?: any) {
    super(`External service error (${service}): ${message}`, 502, 'EXTERNAL_SERVICE_ERROR', true, details);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Error handler
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const errorHandler = (
  error: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (res.headersSent) return next(error);

  // Defaults
  let statusCode = 500;
  let code = 'INTERNAL_ERROR';
  let message = 'Internal server error';
  let details: any;

  if (error instanceof AppError) {
    statusCode = error.statusCode;
    code = error.code;
    message = error.message;
    details = error.details;
  } else if (error.name === 'ValidationError') {
    statusCode = 400;
    code = 'VALIDATION_ERROR';
    message = error.message;
  } else if (error.name === 'JsonWebTokenError') {
    statusCode = 401;
    code = 'INVALID_TOKEN';
    message = 'Invalid token';
  } else if (error.name === 'TokenExpiredError') {
    statusCode = 401;
    code = 'TOKEN_EXPIRED';
    message = 'Token expired';
  } else if ((error as any).code === '23505') {
    statusCode = 409;
    code = 'DUPLICATE_ENTRY';
    message = 'Resource already exists';
  } else if ((error as any).code === '23503') {
    statusCode = 400;
    code = 'FOREIGN_KEY_VIOLATION';
    message = 'Referenced resource does not exist';
  } else if ((error as any).code === 'ECONNREFUSED') {
    statusCode = 503;
    code = 'SERVICE_UNAVAILABLE';
    message = 'External service unavailable';
  } else if ((error as any).code === 'ENOTFOUND') {
    statusCode = 503;
    code = 'SERVICE_UNREACHABLE';
    message = 'External service unreachable';
  } else if ((error as any).code === 'ETIMEDOUT') {
    statusCode = 504;
    code = 'SERVICE_TIMEOUT';
    message = 'External service timeout';
  }

  const requestId =
    (req as any).requestId ||
    req.get('X-Request-ID') ||
    `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

  const logPayload = {
    requestId,
    method: req.method,
    url: req.originalUrl || req.url,
    statusCode,
    code,
    message: (error as any).message,
    stack: (error as any).stack,
    body: req.body,
    params: req.params,
    query: req.query,
    userAgent: req.get('User-Agent'),
    ip: req.ip,
  };

  if (statusCode >= 500) {
    logger.error('Server error:', logPayload);
  } else {
    logger.warn('Client error:', logPayload);
  }

  const payload: ErrorResponse = {
    success: false,
    error: {
      code,
      message,
      timestamp: new Date().toISOString(),
      requestId,
    },
  };

  // Only include details/stack outside production
  if (!isProduction) {
    if (details) payload.error.details = details;
    payload.error.details = {
      ...(payload.error.details || {}),
      stack: (error as any).stack,
    };
  }

  res.status(statusCode).json(payload);
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const notFoundHandler = (req: Request, res: Response): void => {
  const requestId =
    (req as any).requestId ||
    req.get('X-Request-ID') ||
    `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

  const payload: ErrorResponse = {
    success: false,
    error: {
      code: 'NOT_FOUND',
      message: `Route ${req.method} ${req.originalUrl} not found`,
      timestamp: new Date().toISOString(),
      requestId,
    },
  };

  logger.warn('Route not found:', {
    method: req.method,
    url: req.originalUrl,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    requestId,
  });

  res.status(404).json(payload);
};

// Wrap async route handlers
export const asyncHandler = (fn: (...args: any[]) => Promise<any>) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Attach/propagate a request ID for tracing
export const requestIdMiddleware = (req: Request, res: Response, next: NextFunction): void => {
  const requestId = req.get('X-Request-ID') || `req_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  (req as any).requestId = requestId;
  res.set('X-Request-ID', requestId);
  next();
};

export default errorHandler;



------------------------------------------------------------
FILE: backend\data-service\src\middleware\rateLimit.ts
------------------------------------------------------------
import type { RequestHandler } from 'express';
import rateLimit from 'express-rate-limit';
import { logger, loggerUtils } from '../utils/logger';

// helper to coerce the rate-limit handler to Express's RequestHandler
const asExpressHandler = (h: unknown) => h as unknown as RequestHandler;

/** Default rate limiting middleware for general use */
const _defaultRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 1000,
  message: {
    success: false,
    error: 'RATE_LIMIT_EXCEEDED',
    message: 'Too many requests from this IP, please try again later.',
    retryAfter: '15 minutes',
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req: any, res: any) => {
    logger.warn('Default rate limit exceeded', {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      path: req.path,
    });
    res.status(429).json({
      success: false,
      error: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests from this IP, please try again later.',
      retryAfter: res.get('Retry-After'),
      timestamp: new Date().toISOString(),
    });
  },
});
export const defaultRateLimit: RequestHandler = asExpressHandler(_defaultRateLimit);

/** Custom key generator */
const keyGenerator = (req: any): string => {
  const user = req.user;
  return user ? `user:${user.id}` : `ip:${req.ip}`;
};

/** Common response body */
const rateLimitMessage = (req: any, res: any) => {
  const user = req.user;
  loggerUtils.logAuth('rate_limit_exceeded', user?.id, req.ip, req.get('User-Agent'));
  return {
    success: false,
    error: 'RATE_LIMIT_EXCEEDED',
    message: 'Too many requests. Please try again later.',
    retryAfter: res.get('Retry-After'),
    timestamp: new Date().toISOString(),
  };
};

// Skip function (keep any to avoid cross-tree type binding)
const skipSuccessfulRequests = (req: any, res: any): boolean =>
  res.statusCode < 400 && req.path === '/health';

/** General rate limiting middleware */
export const rateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    skip: skipSuccessfulRequests,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Strict auth limiter */
export const strictRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req: any) => `auth:${req.ip}`,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** API limiter */
export const apiRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 60 * 1000,
    max: 20,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    skip: skipSuccessfulRequests,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Connection test limiter */
export const connectionTestRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 5 * 60 * 1000,
    max: 10,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Search limiter */
export const searchRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 60 * 1000,
    max: 30,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    skip: skipSuccessfulRequests,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Export limiter */
export const exportRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 60 * 60 * 1000,
    max: 5,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Upload limiter */
export const uploadRateLimitMiddleware: RequestHandler = asExpressHandler(
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 10,
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator,
    handler: (req: any, res: any) => {
      res.status(429).json(rateLimitMessage(req, res));
    },
  })
);

/** Factory */
export const createRateLimit = (options: {
  windowMs: number;
  max: number;
  message?: string;
  skipSuccessfulRequests?: boolean;
}): RequestHandler =>
  asExpressHandler(
    rateLimit({
      windowMs: options.windowMs,
      max: options.max,
      message: options.message
        ? {
            success: false,
            error: 'RATE_LIMIT_EXCEEDED',
            message: options.message,
            timestamp: new Date().toISOString(),
          }
        : undefined,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator,
      skip: options.skipSuccessfulRequests ? skipSuccessfulRequests : undefined,
      handler: (req: any, res: any) => {
        res.status(429).json(rateLimitMessage(req, res));
      },
    })
  );

export const RATE_LIMITS = {
  GENERAL: { windowMs: 15 * 60 * 1000, max: 100 },
  AUTH: { windowMs: 15 * 60 * 1000, max: 5 },
  API: { windowMs: 1 * 60 * 1000, max: 20 },
  CONNECTION_TEST: { windowMs: 5 * 60 * 1000, max: 10 },
  SEARCH: { windowMs: 1 * 60 * 1000, max: 30 },
  EXPORT: { windowMs: 60 * 60 * 1000, max: 5 },
  UPLOAD: { windowMs: 15 * 60 * 1000, max: 10 },
} as const;



------------------------------------------------------------
FILE: backend\data-service\src\middleware\validation.ts
------------------------------------------------------------
// src/middleware/validation.ts - Data source validation rules
import { NextFunction, Request, Response } from 'express';
import { body, param, query, validationResult } from 'express-validator';

/**
 * Validate request and return errors if any
 */
export const validateRequest = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const errorMessage = formatValidationError(errors.array());
    return res.status(400).json({
      success: false,
      error: 'VALIDATION_ERROR',
      message: errorMessage,
      details: errors.array(),
      timestamp: new Date().toISOString(),
    });
  }
  
  next();
};

/**
 * Validation error formatter
 */
export const formatValidationError = (errors: any[]): string => {
  return errors.map(error => {
    if (error.type === 'field') {
      return `${error.path}: ${error.msg}`;
    }
    return error.msg;
  }).join(', ');
};

/**
 * Data source validation rules
 */
export const validateDataSource = [
  body('name')
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Name must be between 1 and 100 characters'),
  
  body('type')
    .isIn(['postgres', 'mysql', 'sqlserver', 'mongodb', 's3', 'api', 'file'])
    .withMessage('Invalid data source type'),
  
  body('host')
    .optional()
    .isLength({ min: 1, max: 255 })
    .withMessage('Host must be between 1 and 255 characters'),
  
  body('port')
    .optional()
    .isInt({ min: 1, max: 65535 })
    .withMessage('Port must be between 1 and 65535'),
  
  body('database')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Database name must be between 1 and 100 characters'),
  
  body('username')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Username must be between 1 and 100 characters'),
  
  body('password')
    .optional()
    .isLength({ min: 1, max: 255 })
    .withMessage('Password must be between 1 and 255 characters'),
  
  body('ssl')
    .optional()
    .isBoolean()
    .withMessage('SSL must be a boolean value'),
  
  body('description')
    .optional()
    .isLength({ max: 500 })
    .withMessage('Description must be less than 500 characters'),
  
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  
  body('tags.*')
    .optional()
    .isString()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Each tag must be between 1 and 50 characters'),

  validateRequest
];

/**
 * Data source update validation rules
 */
export const validateDataSourceUpdate = [
  param('id')
    .isUUID()
    .withMessage('Invalid data source ID'),
  
  body('name')
    .optional()
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Name must be between 1 and 100 characters'),
  
  body('host')
    .optional()
    .isLength({ min: 1, max: 255 })
    .withMessage('Host must be between 1 and 255 characters'),
  
  body('port')
    .optional()
    .isInt({ min: 1, max: 65535 })
    .withMessage('Port must be between 1 and 65535'),
  
  body('database')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Database name must be between 1 and 100 characters'),
  
  body('username')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Username must be between 1 and 100 characters'),
  
  body('password')
    .optional()
    .isLength({ min: 1, max: 255 })
    .withMessage('Password must be between 1 and 255 characters'),
  
  body('ssl')
    .optional()
    .isBoolean()
    .withMessage('SSL must be a boolean value'),
  
  body('description')
    .optional()
    .isLength({ max: 500 })
    .withMessage('Description must be less than 500 characters'),
  
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),

  validateRequest
];

/**
 * Asset validation rules
 */
export const validateAsset = [
  body('name')
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('Name must be between 1 and 100 characters'),
  
  body('type')
    .isIn(['table', 'view', 'procedure', 'function', 'schema'])
    .withMessage('Invalid asset type'),
  
  body('dataSourceId')
    .isUUID()
    .withMessage('Invalid data source ID'),
  
  body('schemaName')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Schema name must be between 1 and 100 characters'),
  
  body('tableName')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Table name must be between 1 and 100 characters'),
  
  body('description')
    .optional()
    .isLength({ max: 500 })
    .withMessage('Description must be less than 500 characters'),
  
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  
  body('status')
    .optional()
    .isIn(['active', 'inactive', 'deprecated'])
    .withMessage('Invalid status'),

  validateRequest
];

/**
 * ID parameter validation
 */
export const validateId = [
  param('id')
    .isUUID()
    .withMessage('Invalid ID format'),
  
  validateRequest
];

/**
 * Pagination validation
 */
export const validatePagination = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100'),
  
  query('search')
    .optional()
    .isString()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Search term must be less than 100 characters'),

  validateRequest
];

/**
 * Connection test validation
 */
export const validateConnectionTest = [
  body('type')
    .isIn(['postgres', 'mysql', 'sqlserver', 'mongodb', 's3', 'api'])
    .withMessage('Invalid connection type'),
  
  body('host')
    .isLength({ min: 1, max: 255 })
    .withMessage('Host is required and must be less than 255 characters'),
  
  body('port')
    .isInt({ min: 1, max: 65535 })
    .withMessage('Port must be between 1 and 65535'),
  
  body('database')
    .optional()
    .isLength({ min: 1, max: 100 })
    .withMessage('Database name must be between 1 and 100 characters'),
  
  body('username')
    .isLength({ min: 1, max: 100 })
    .withMessage('Username is required and must be less than 100 characters'),
  
  body('password')
    .isLength({ min: 1, max: 255 })
    .withMessage('Password is required and must be less than 255 characters'),

  validateRequest
];

/**
 * Tags validation
 */
export const validateTags = [
  body('tags')
    .isArray({ min: 1 })
    .withMessage('Tags must be a non-empty array'),
  
  body('tags.*')
    .isString()
    .trim()
    .isLength({ min: 1, max: 50 })
    .withMessage('Each tag must be between 1 and 50 characters'),

  validateRequest
];


------------------------------------------------------------
FILE: backend\data-service\src\models\Connection.ts
------------------------------------------------------------
// backend/data-service/src/models/Connection.ts
// Back-compat shim: re-export the canonical connection types from DataSource.
// This prevents drift between modules and ensures 'mssql' etc. exist here too.

export type {
  APIConnection, AzureBlobConnection, BigQueryConnection, ConnectionConfig, ConnectionTestResult, DatabricksConnection, ElasticsearchConnection, FileConnection, GCSConnection, KafkaConnection, MongoDBConnection, MSSQLConnection, MySQLConnection, OracleConnection, PostgreSQLConnection, RedisConnection, RedshiftConnection, S3Connection, SnowflakeConnection
} from './DataSource';




------------------------------------------------------------
FILE: backend\data-service\src\models\ConnectionRuntime.ts
------------------------------------------------------------
// backend/data-service/src/models/ConnectionRuntime.ts

export interface ConnectionPool {
  id: string;
  dataSourceId: string;
  poolSize: number;
  activeConnections: number;
  idleConnections: number;
  waitingConnections: number;
  createdAt: Date;
  lastUsedAt: Date;
}

export interface ConnectionMetrics {
  dataSourceId: string;
  totalConnections: number;
  successfulConnections: number;
  failedConnections: number;
  averageResponseTime: number;
  lastConnectionAt?: Date;
  lastFailureAt?: Date;
  lastErrorMessage?: string;
  uptime: number;       // percentage
  availability: number; // percentage
}

export interface ConnectionHistory {
  id: string;
  dataSourceId: string;
  connectionStatus: 'success' | 'failed' | 'timeout' | 'refused';
  responseTime?: number; // ms
  errorCode?: string;
  errorMessage?: string;
  connectionDetails?: {
    host?: string;
    port?: number;
    database?: string;
    serverVersion?: string;
    serverInfo?: Record<string, any>;
  };
  testedAt: Date;
  testedBy?: string;
  testType: 'manual' | 'scheduled' | 'health_check' | 'startup';
}

export interface ConnectionCredentials {
  username?: string;
  password?: string;
  apiKey?: string;
  secretKey?: string;
  accessToken?: string;
  refreshToken?: string;
  tokenType?: string;
  certificate?: string;
  privateKey?: string;
  passphrase?: string;
  accessKeyId?: string;
  secretAccessKey?: string;
  serviceAccountKey?: string;
  authMethod?: 'basic' | 'bearer' | 'oauth2' | 'certificate' | 'api-key' | 'iam';
  authUrl?: string;
  tokenUrl?: string;
  scope?: string[];
}

export interface RuntimeConnectionSecurity {
  ssl: boolean;
  sslMode?: 'disable' | 'allow' | 'prefer' | 'require' | 'verify-ca' | 'verify-full';
  sslCert?: string;
  sslKey?: string;
  sslRootCert?: string;
  verifyCertificate: boolean;
  allowSelfSigned: boolean;
  encryption?: 'none' | 'tls' | 'ssl';
  tlsVersion?: string;
}

export interface RuntimeConnectionOptions {
  connectionTimeout: number; // ms
  queryTimeout: number;      // ms
  idleTimeout: number;       // ms
  minConnections: number;
  maxConnections: number;
  acquireTimeout: number;    // ms
  retryAttempts: number;
  retryDelay: number;        // ms
  exponentialBackoff: boolean;
  keepAlive: boolean;
  keepAliveInterval?: number; // ms
  charset?: string;
  timezone?: string;
  applicationName?: string;
  customOptions: Record<string, any>;
}

export interface ConnectionTest {
  id: string;
  dataSourceId: string;
  testType: 'basic' | 'advanced' | 'schema' | 'performance';
  status: 'pending' | 'running' | 'completed' | 'failed';
  testQueries?: string[];
  expectedResults?: any[];
  performanceThresholds?: {
    maxResponseTime: number;
    minThroughput: number;
  };
  results?: {
    connectionSuccessful: boolean;
    responseTime: number;
    queryResults?: any[];
    performanceMetrics?: {
      throughput: number;
      latency: number;
      errorRate: number;
    };
    schemaInfo?: {
      databases?: string[];
      tables?: string[];
      columns?: string[];
    };
  };
  startedAt: Date;
  completedAt?: Date;
  duration?: number; // ms
  errorMessage?: string;
  testedBy: string;
}

export interface ConnectionFactory {
  createConnection(dataSourceId: string): Promise<any>;
  testConnection(dataSourceId: string): Promise<ConnectionTest>;
  closeConnection(dataSourceId: string): Promise<void>;
  getConnectionMetrics(dataSourceId: string): Promise<ConnectionMetrics>;
}

export const defaultConnectionOptions: RuntimeConnectionOptions = {
  connectionTimeout: 30000,
  queryTimeout: 60000,
  idleTimeout: 300000,
  minConnections: 1,
  maxConnections: 10,
  acquireTimeout: 30000,
  retryAttempts: 3,
  retryDelay: 1000,
  exponentialBackoff: true,
  keepAlive: true,
  keepAliveInterval: 30000,
  customOptions: {},
};

// helper (only for telemetry layer â€” separate from canonical config)
export function getDefaultPort(type: string): number {
  const ports: Record<string, number> = {
    postgresql: 5432,
    mysql: 3306,
    mssql: 1433,
    oracle: 1521,
    mongodb: 27017,
    redis: 6379,
    elasticsearch: 9200,
    cassandra: 9042,
    clickhouse: 8123,
  };
  return ports[type] || 0;
}



------------------------------------------------------------
FILE: backend\data-service\src\models\DataSource.ts
------------------------------------------------------------
/* ===========================================================================
 * DataSource models & helpers (canonical, production-ready)
 * =========================================================================== */

export type DataSourceType =
  | 'postgresql'
  | 'mysql'
  | 'mssql'
  | 'oracle'
  | 'mongodb'
  | 'redis'
  | 's3'
  | 'azure-blob'
  | 'gcs'
  | 'snowflake'
  | 'bigquery'
  | 'redshift'
  | 'databricks'
  | 'api'
  | 'file'
  | 'kafka'
  | 'elasticsearch';

export type DataSourceStatus =
  | 'pending'
  | 'connected'
  | 'disconnected'
  | 'error'
  | 'warning'
  | 'syncing'
  | 'testing'
  // back-compat / ops-friendly synonyms
  | 'active'
  | 'inactive';

/* ---------------------------------------------------------------------------
 * TLS / SSL
 * --------------------------------------------------------------------------- */
export interface ConnectionSecurity {
  enabled?: boolean;
  rejectUnauthorized?: boolean;
  ca?: string;
  cert?: string;
  key?: string;
  mode?: 'disable' | 'allow' | 'prefer' | 'require' | 'verify-ca' | 'verify-full';
}

/* ---------------------------------------------------------------------------
 * Shared base for all connectors
 * --------------------------------------------------------------------------- */
export interface CommonConnectionFields {
  host?: string;
  port?: number;
  database?: string | number;
  username?: string;
  password?: string;
  schema?: string;
  connectionString?: string;
  ssl?: boolean | ConnectionSecurity;

  timeout?: number;
  maxConnections?: number;
  retryAttempts?: number;
}

/* ---------------------------------------------------------------------------
 * Per-connector configs (discriminated by `type`)
 * --------------------------------------------------------------------------- */
// Relational
export interface PostgreSQLConnection extends CommonConnectionFields { type: 'postgresql' }
export interface MySQLConnection     extends CommonConnectionFields { type: 'mysql' }
export interface MSSQLConnection     extends CommonConnectionFields { type: 'mssql' }
export interface OracleConnection    extends CommonConnectionFields { type: 'oracle' }
export interface RedshiftConnection  extends CommonConnectionFields { type: 'redshift' }
export interface DatabricksConnection extends CommonConnectionFields {
  type: 'databricks';
  httpPath?: string;
  token?: string;
}

// Doc/KV
export interface MongoDBConnection extends CommonConnectionFields { type: 'mongodb' }
export interface RedisConnection extends CommonConnectionFields {
  type: 'redis';
  cluster?: boolean;
  nodes?: Array<{ host: string; port: number }>;
}

// Object storage
export interface S3Connection extends CommonConnectionFields {
  type: 's3';
  bucket?: string;
  region?: string;
  accessKeyId?: string;
  secretAccessKey?: string;
  prefix?: string;
}
export interface AzureBlobConnection extends CommonConnectionFields {
  type: 'azure-blob';
  container?: string;
  accountName?: string;
  accountKey?: string;
  connectionString?: string; // Azure style
  prefix?: string;
}
export interface GCSConnection extends CommonConnectionFields {
  type: 'gcs';
  bucket?: string;
  serviceAccountKey?: string; // JSON
  prefix?: string;
}

// SaaS DW / Analytics
export interface SnowflakeConnection extends CommonConnectionFields {
  type: 'snowflake';
  warehouse?: string;
  role?: string;
}
export interface BigQueryConnection extends CommonConnectionFields {
  type: 'bigquery';
  projectId?: string;
  dataset?: string;
  location?: string;
  serviceAccountKey?: string; // JSON
}

// REST / File / Streaming / Search
export interface APIConnection extends CommonConnectionFields {
  type: 'api';
  baseUrl?: string;
  apiKey?: string;
  headers?: Record<string, string>;
  authentication?: {
    type: 'basic' | 'bearer' | 'oauth2' | 'api-key';
    credentials: Record<string, string>;
  };
}
export interface FileConnection extends CommonConnectionFields {
  type: 'file';
  path?: string;
  format?: 'csv' | 'json' | 'parquet' | 'avro' | 'xml';
}
export interface KafkaConnection extends CommonConnectionFields {
  type: 'kafka';
  brokers?: string[];  // host:port
  topics?: string[];
  consumerGroup?: string;
  sasl?: {
    mechanism: 'plain' | 'scram-sha-256' | 'scram-sha-512';
    username: string;
    password: string;
  };
  ssl?: boolean | ConnectionSecurity;
}
export interface ElasticsearchConnection extends CommonConnectionFields { type: 'elasticsearch' }

/* ---------------------------------------------------------------------------
 * Canonical union
 * --------------------------------------------------------------------------- */
export type ConnectionConfig =
  | PostgreSQLConnection
  | MySQLConnection
  | MSSQLConnection
  | OracleConnection
  | MongoDBConnection
  | RedisConnection
  | S3Connection
  | AzureBlobConnection
  | GCSConnection
  | SnowflakeConnection
  | BigQueryConnection
  | RedshiftConnection
  | DatabricksConnection
  | APIConnection
  | FileConnection
  | KafkaConnection
  | ElasticsearchConnection;

/* ---------------------------------------------------------------------------
 * Filters & pagination
 * --------------------------------------------------------------------------- */
export interface DataSourceFilters {
  status?: DataSourceStatus;
  type?: DataSourceType;
  search?: string;
  tags?: string[];
  createdBy?: string;              // â† added (fixes controller/service usage)
}

export type SortBy = 'updatedAt' | 'createdAt' | 'name' | 'status' | 'type';
export interface ListOptions {
  page?: number;
  limit?: number;
  filters?: DataSourceFilters;
  sortBy?: SortBy;
  sortOrder?: 'asc' | 'desc';
}

export interface ListOptions {
  page?: number;
  limit?: number;
  filters?: DataSourceFilters;
  sortBy?: 'createdAt' | 'updatedAt' | 'name' | 'type' | 'status';  // â† added
  sortOrder?: 'asc' | 'desc';                                        // â† added
}

/* ---------------------------------------------------------------------------
 * DataSource record
 * --------------------------------------------------------------------------- */
export interface DataSourceMetadata {
  version?: string;
  driver?: string;
  encoding?: string;
  timezone?: string;
  tableCount?: number;
  estimatedSize?: string;
  lastSchemaUpdate?: Date;
  customFields?: Record<string, any>;
}

export interface DataSource {
  id: string; // UUID string
  name: string;
  description?: string;
  type: DataSourceType;
  status: DataSourceStatus;
  connectionConfig: ConnectionConfig;
  tags: string[];
  metadata: DataSourceMetadata;

  createdAt: Date;
  updatedAt: Date;
  createdBy: string;
  updatedBy?: string;
  deletedAt?: Date;

  lastTestAt?: Date;
  lastSyncAt?: Date;
  lastError?: string;

  publicId?: string | null;

  // optional live metrics
  responseTime?: number;
  availability?: number;

  // sync & ingestion scheduling
  syncEnabled?: boolean;
  syncSchedule?: string; // cron
  syncOptions?: {
    fullSync?: boolean;
    incrementalField?: string;
    batchSize?: number;
  };
}

/* ---------------------------------------------------------------------------
 * PostgreSQL DDL (idempotent)
 * --------------------------------------------------------------------------- */
export const createDataSourcesTable = `
  CREATE TABLE IF NOT EXISTS data_sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    connection_config JSONB NOT NULL,
    tags TEXT[] DEFAULT '{}',               -- TEXT[] (not JSONB)
    metadata JSONB DEFAULT '{}',

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by VARCHAR(255),
    updated_by VARCHAR(255),
    deleted_at TIMESTAMPTZ,

    last_test_at TIMESTAMPTZ,
    last_tested_at TIMESTAMPTZ,             -- legacy tolerated (COALESCE)
    last_sync_at TIMESTAMPTZ,
    last_error TEXT,

    public_id VARCHAR(100),

    response_time INTEGER,
    availability DECIMAL(5,2),

    sync_enabled BOOLEAN DEFAULT false,
    sync_schedule VARCHAR(255),
    sync_options JSONB DEFAULT '{}'
  );

  CREATE INDEX IF NOT EXISTS idx_ds_type ON data_sources(type);
  CREATE INDEX IF NOT EXISTS idx_ds_status ON data_sources(status);
  CREATE INDEX IF NOT EXISTS idx_ds_created_by ON data_sources(created_by);
  CREATE INDEX IF NOT EXISTS idx_ds_deleted_at ON data_sources(deleted_at);
  CREATE INDEX IF NOT EXISTS idx_ds_last_sync ON data_sources(last_sync_at);
  CREATE INDEX IF NOT EXISTS idx_ds_updated_at ON data_sources(updated_at);

  DO $$
  BEGIN
    IF NOT EXISTS (
      SELECT 1 FROM pg_indexes
      WHERE schemaname = 'public' AND indexname = 'uq_data_sources_public_id'
    ) THEN
      CREATE UNIQUE INDEX uq_data_sources_public_id
        ON data_sources((public_id)) WHERE public_id IS NOT NULL;
    END IF;
  END $$;
`;

/* ---------------------------------------------------------------------------
 * Result & stats
 * --------------------------------------------------------------------------- */
export interface ConnectionTestResult {
  success: boolean;
  responseTime?: number;
  error?: string;
  details?: {
    version?: string;
    serverInfo?: Record<string, any>;
    capabilities?: string[];
  };
  testedAt: Date;
}

export interface DataSourceStats {
  dataSourceId: string;
  totalTables: number;
  totalColumns: number;
  totalRows: number;
  estimatedSize: string;
  lastUpdated: Date;
  tableStats: TableStats[];
}
export interface TableStats {
  name: string;
  schema?: string;
  rowCount: number;
  columnCount: number;
  sizeBytes: number;
  lastModified?: Date;
}

/* ---------------------------------------------------------------------------
 * Helpers
 * --------------------------------------------------------------------------- */
export function validateDataSourceType(s: string): s is DataSourceType {
  const all: readonly DataSourceType[] = [
    'postgresql','mysql','mssql','oracle','mongodb','redis',
    's3','azure-blob','gcs','snowflake','bigquery','redshift',
    'databricks','api','file','kafka','elasticsearch',
  ];
  return (all as readonly string[]).includes(s);
}

export function validateDataSourceStatus(s: string): s is DataSourceStatus {
  const all: readonly DataSourceStatus[] = [
    'pending','connected','disconnected','error','warning','syncing','testing','active','inactive',
  ];
  return (all as readonly string[]).includes(s);
}

/** Map common aliases to canonical types */
export function normalizeDataSourceType(t: string): DataSourceType {
  const x = (t || '').toLowerCase();
  if (x === 'azure_sql' || x === 'azure-sql' || x === 'sqlserver' || x === 'sql-server') return 'mssql';
  return validateDataSourceType(x) ? (x as DataSourceType) : (x as DataSourceType);
}

export function getDefaultPort(type: DataSourceType): number | undefined {
  switch (type) {
    case 'postgresql': return 5432;
    case 'mysql': return 3306;
    case 'mssql': return 1433;
    case 'oracle': return 1521;
    case 'mongodb': return 27017;
    case 'redis': return 6379;
    case 'elasticsearch': return 9200;
    default: return undefined;
  }
}

/** Strong validation per connector (narrow, then read special props). */
export function validateConnectionConfig(type: DataSourceType, cfg: Partial<ConnectionConfig>): string[] {
  const errors: string[] = [];
  const t = normalizeDataSourceType(type);
  const need = (ok: boolean, msg: string) => { if (!ok) errors.push(msg); };

  switch (t) {
    case 'postgresql':
    case 'mysql':
    case 'mssql':
    case 'oracle':
    case 'redshift':
    case 'databricks': {
      need(!!(cfg.connectionString || cfg.host), 'Host or connection string is required');
      need(!!(cfg.connectionString || (cfg as any).database), 'Database is required');
      break;
    }

    case 'mongodb': {
      need(!!(cfg.connectionString || cfg.host), 'Host or connection string is required');
      break;
    }

    case 'redis': {
      const rc = cfg as any;
      if (!rc.cluster) {
        need(!!(rc.host || rc.connectionString), 'Host or connection string is required');
      } else {
        need(Array.isArray(rc.nodes) && rc.nodes.length > 0, 'At least one cluster node is required');
      }
      break;
    }

    case 's3': {
      const sc = cfg as any;
      need(!!sc.bucket, 'Bucket is required');
      need(!!sc.region, 'Region is required');
      break;
    }

    case 'azure-blob': {
      const ac = cfg as any;
      need(!!ac.container, 'Container is required');
      break;
    }

    case 'gcs': {
      const gc = cfg as any;
      need(!!gc.bucket, 'Bucket is required');
      break;
    }

    case 'snowflake': {
      const sn = cfg as any;
      need(!!sn.host, 'Account URL/host is required');
      need(!!sn.username, 'Username is required');
      need(!!sn.database, 'Database is required');
      break;
    }

    case 'bigquery': {
      const bq = cfg as any;
      need(!!bq.serviceAccountKey, 'Service account key is required');
      break;
    }

    case 'api': {
      const api = cfg as any;
      need(!!api.baseUrl, 'Base URL is required');
      if (api.baseUrl) {
        try { new URL(api.baseUrl); } catch { errors.push('Base URL must be a valid URL'); }
      }
      break;
    }

    case 'file': {
      const fc = cfg as any;
      need(!!fc.path, 'File path is required');
      break;
    }

    case 'kafka': {
      const kc = cfg as any;
      need(Array.isArray(kc.brokers) && kc.brokers.length > 0, 'At least one broker is required');
      break;
    }

    case 'elasticsearch': {
      need(!!(cfg.host || cfg.connectionString), 'Host or connection string is required');
      break;
    }
  }

  if (cfg.port !== undefined && (cfg.port < 1 || cfg.port > 65535)) {
    errors.push('Port must be between 1 and 65535');
  }
  return errors;
}

/* ---------------------------------------------------------------------------
 * UI helpers
 * --------------------------------------------------------------------------- */
export function getDataSourceDisplayName(type: DataSourceType): string {
  const t = normalizeDataSourceType(type);
  const display: Record<DataSourceType, string> = {
    postgresql: 'PostgreSQL',
    mysql: 'MySQL',
    mssql: 'SQL Server',
    oracle: 'Oracle',
    mongodb: 'MongoDB',
    redis: 'Redis',
    s3: 'Amazon S3',
    'azure-blob': 'Azure Blob Storage',
    gcs: 'Google Cloud Storage',
    snowflake: 'Snowflake',
    bigquery: 'Google BigQuery',
    redshift: 'Amazon Redshift',
    databricks: 'Databricks',
    api: 'REST API',
    file: 'File System',
    kafka: 'Apache Kafka',
    elasticsearch: 'Elasticsearch',
  };
  return display[t] || t;
}

export function getDataSourceIcon(type: DataSourceType): string {
  const t = normalizeDataSourceType(type);
  const icons: Record<DataSourceType, string> = {
    postgresql: 'ðŸ˜',
    mysql: 'ðŸ¬',
    mssql: 'ðŸ¢',
    oracle: 'ðŸ›ï¸',
    mongodb: 'ðŸƒ',
    redis: 'ðŸ“¦',
    s3: 'â˜ï¸',
    'azure-blob': 'â˜ï¸',
    gcs: 'â˜ï¸',
    snowflake: 'â„ï¸',
    bigquery: 'ðŸ“Š',
    redshift: 'ðŸ“Š',
    databricks: 'ðŸ§±',
    api: 'ðŸ”Œ',
    file: 'ðŸ“',
    kafka: 'ðŸš€',
    elasticsearch: 'ðŸ”',
  };
  return icons[t] || 'ðŸ’¾';
}

export function getStatusColor(status: DataSourceStatus): string {
  const colors: Record<DataSourceStatus, string> = {
    pending: '#fbbf24',
    connected: '#10b981',
    disconnected: '#6b7280',
    error: '#ef4444',
    warning: '#f59e0b',
    syncing: '#3b82f6',
    testing: '#8b5cf6',
    active: '#10b981',    // synonym of connected
    inactive: '#6b7280',  // synonym of disconnected
  };
  return colors[status];
}

/* ---------------------------------------------------------------------------
 * Safe creation template for UI flows
 * --------------------------------------------------------------------------- */
export type NewDataSourceTemplate =
  Partial<Omit<DataSource, 'connectionConfig'>> & {
    connectionConfig: Partial<ConnectionConfig>;
  };

export function createDataSourceTemplate(kind: DataSourceType): NewDataSourceTemplate {
  const t = normalizeDataSourceType(kind);
  return {
    type: t,
    status: 'pending',
    tags: [],
    metadata: {},
    connectionConfig: {
      port: getDefaultPort(t),
      timeout: 30_000,
      maxConnections: 10,
      retryAttempts: 3,
    },
    syncEnabled: false,
    syncOptions: {
      fullSync: true,
      batchSize: 1000,
    },
  };
}

/* ---------------------------------------------------------------------------
 * Type guards
 * --------------------------------------------------------------------------- */
export const isAPIConfig = (c: Partial<ConnectionConfig>): c is APIConnection =>
  (c as APIConnection).type === 'api' || typeof (c as APIConnection).baseUrl === 'string';

export const isS3Config = (c: Partial<ConnectionConfig>): c is S3Connection =>
  (c as S3Connection).type === 's3' || !!(c as S3Connection).accessKeyId || !!(c as S3Connection).secretAccessKey;

export const isSnowflakeConfig = (c: Partial<ConnectionConfig>): c is SnowflakeConnection =>
  (c as SnowflakeConnection).type === 'snowflake';

export const isBigQueryConfig = (c: Partial<ConnectionConfig>): c is BigQueryConnection =>
  (c as BigQueryConnection).type === 'bigquery' || typeof (c as BigQueryConnection).serviceAccountKey === 'string';

/* ---------------------------------------------------------------------------
 * Back-compat type aliases (old names used elsewhere)
 * --------------------------------------------------------------------------- */
export type APIConfig        = APIConnection;
export type BigQueryConfig   = BigQueryConnection;
export type S3Config         = S3Connection;
export type SnowflakeConfig  = SnowflakeConnection;
// For places that refer to "AzureSQLConnection", use MSSQL config
export type AzureSQLConnection = MSSQLConnection;



------------------------------------------------------------
FILE: backend\data-service\src\repositories\dataSourcesRepo.ts
------------------------------------------------------------
// backend/data-service/src/repositories/dataSourcesRepo.ts
import { pool } from "../db/pool";

export type SortBy =
  | "name"
  | "type"
  | "status"
  | "createdAt"
  | "updatedAt"
  | "lastSyncAt"
  | "lastTestAt";

const SORT_MAP: Record<SortBy, string> = {
  name: "name",
  type: "type",
  status: "status",
  createdAt: "created_at",
  updatedAt: "updated_at",
  lastSyncAt: "last_sync_at",
  lastTestAt: "last_test_at",
};

export async function listDataSources(opts: {
  page?: number;
  limit?: number;
  sortBy?: SortBy;
  sortOrder?: "asc" | "desc";
}) {
  const page = Math.max(1, Number(opts.page ?? 1));
  const limit = Math.min(100, Math.max(1, Number(opts.limit ?? 20)));
  const offset = (page - 1) * limit;

  const sortBy = (opts.sortBy ?? "updatedAt") as SortBy;
  const sortCol = SORT_MAP[sortBy] ?? "updated_at";
  const sortOrder = (opts.sortOrder ?? "desc").toLowerCase() === "asc" ? "asc" : "desc";

  const client = await pool.connect();
  try {
    const countSql = `SELECT COUNT(*)::int AS total FROM data_sources WHERE deleted_at IS NULL`;
    const countRes = await client.query<{ total: number }>(countSql);
    const total = countRes.rows[0]?.total ?? 0;

    const sql = `
      SELECT
        id,
        name,
        description,
        type,
        status,
        connection_config           AS "connectionConfig",
        tags,
        metadata,
        created_at                  AS "createdAt",
        updated_at                  AS "updatedAt",
        created_by                  AS "createdBy",
        updated_by                  AS "updatedBy",
        deleted_at                  AS "deletedAt",
        last_test_at                AS "lastTestAt",
        last_sync_at                AS "lastSyncAt",
        last_error                  AS "lastError",
        response_time               AS "responseTime",
        availability,
        sync_enabled                AS "syncEnabled",
        sync_schedule               AS "syncSchedule",
        sync_options                AS "syncOptions"
      FROM data_sources
      WHERE deleted_at IS NULL
      ORDER BY ${sortCol} ${sortOrder}
      LIMIT $1 OFFSET $2
    `;
    const res = await client.query(sql, [limit, offset]);

    return {
      success: true as const,
      data: res.rows,
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      sortBy,
      sortOrder,
    };
  } finally {
    client.release();
  }
}



------------------------------------------------------------
FILE: backend\data-service\src\routes\assets.ts
------------------------------------------------------------
// backend/data-service/src/routes/assets.ts
import { Router, type RequestHandler } from 'express';
import { body, param, query } from 'express-validator';
import { AssetController } from '../controllers/AssetController';
import { authMiddleware } from '../middleware/auth';
import { asyncHandler } from '../middleware/error';
import { createRateLimit } from '../middleware/rateLimit';
import { validateRequest } from '../middleware/validation';

const router = Router();
const assetController = new AssetController();

// Apply authentication to all routes
router.use(authMiddleware as unknown as RequestHandler);

// Validation schemas
const createAssetValidation = [
  body('name').isString().isLength({ min: 1, max: 255 }).withMessage('Name must be between 1 and 255 characters'),
  body('type')
    .isIn(['table', 'view', 'file', 'api_endpoint', 'stream', 'model'])
    .withMessage('Invalid asset type'),
  body('dataSourceId').isString().withMessage('Data source ID is required'),
  body('path').isString().withMessage('Asset path is required'),
  body('description').optional().isString().isLength({ max: 1000 }).withMessage('Description must be less than 1000 characters'),
  body('metadata').optional().isObject().withMessage('Metadata must be an object'),
  body('tags').optional().isArray().withMessage('Tags must be an array'),
  body('classification')
    .optional()
    .isIn(['public', 'internal', 'confidential', 'restricted'])
    .withMessage('Invalid classification level'),
];

const updateAssetValidation = [
  param('id').isString().withMessage('Asset ID must be a string'),
  body('name').optional().isString().isLength({ min: 1, max: 255 }).withMessage('Name must be between 1 and 255 characters'),
  body('description').optional().isString().isLength({ max: 1000 }).withMessage('Description must be less than 1000 characters'),
  body('metadata').optional().isObject().withMessage('Metadata must be an object'),
  body('tags').optional().isArray().withMessage('Tags must be an array'),
  body('classification')
    .optional()
    .isIn(['public', 'internal', 'confidential', 'restricted'])
    .withMessage('Invalid classification level'),
];

const paginationValidation = [
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  query('type')
    .optional()
    .isIn(['table', 'view', 'file', 'api_endpoint', 'stream', 'model'])
    .withMessage('Invalid asset type filter'),
  query('dataSourceId').optional().isString().withMessage('Data source ID must be a string'),
  query('classification')
    .optional()
    .isIn(['public', 'internal', 'confidential', 'restricted'])
    .withMessage('Invalid classification filter'),
  query('search').optional().isString().isLength({ min: 1, max: 100 }).withMessage('Search term must be between 1 and 100 characters'),
];

const idValidation = [param('id').isString().withMessage('Asset ID must be a string')];

// --- Rate limiters (cast to RequestHandler to avoid type incompatibilities) ---
const asHandler = (h: any) => h as unknown as RequestHandler;

const listAssetsLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 100 }));
const searchAssetsLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 50 }));
const getAssetStatsLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const getAssetLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 200 }));
const getSchemaLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const getLineageLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 20 }));
const getProfileLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 10 }));
const createAssetLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 20 }));
const scanAssetLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 5 }));
const tagOperationsLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const updateAssetLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const updateClassificationLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 20 }));
const deleteAssetLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 10 }));

/**
 * @route GET /api/assets
 * @desc Get all assets with pagination, filtering, and search
 * @access Private
 */
router.get('/', paginationValidation, validateRequest, listAssetsLimit, asyncHandler(assetController.getAllAssets));

/**
 * @route GET /api/assets/search
 * @desc Search assets by name, description, or metadata
 * @access Private
 */
router.get(
  '/search',
  [
    query('q').isString().isLength({ min: 1, max: 100 }).withMessage('Search query must be between 1 and 100 characters'),
    query('type')
      .optional()
      .isIn(['table', 'view', 'file', 'api_endpoint', 'stream', 'model'])
      .withMessage('Invalid asset type filter'),
    query('limit').optional().isInt({ min: 1, max: 50 }).withMessage('Limit must be between 1 and 50'),
  ],
  validateRequest,
  searchAssetsLimit,
  asyncHandler(assetController.searchAssets),
);

/**
 * @route GET /api/assets/stats
 * @desc Get asset statistics and overview (global)
 * @access Private
 */
router.get('/stats', getAssetStatsLimit, asyncHandler(assetController.getAssetStats));

/**
 * @route GET /api/assets/:id
 * @desc Get a specific asset by ID
 * @access Private
 */
router.get('/:id', idValidation, validateRequest, getAssetLimit, asyncHandler(assetController.getAssetById));

/**
 * @route GET /api/assets/:id/schema
 * @desc Get schema information for an asset
 * @access Private
 */
router.get('/:id/schema', idValidation, validateRequest, getSchemaLimit, asyncHandler(assetController.getAssetSchema));

/**
 * @route GET /api/assets/:id/lineage
 * @desc Get data lineage for an asset
 * @access Private
 */
router.get('/:id/lineage', idValidation, validateRequest, getLineageLimit, asyncHandler(assetController.getAssetLineage));

/**
 * @route GET /api/assets/:id/profile
 * @desc Get data profile for an asset
 * @access Private
 */
router.get('/:id/profile', idValidation, validateRequest, getProfileLimit, asyncHandler(assetController.getAssetProfile));

/**
 * @route GET /api/assets/:id/stats
 * @desc Get usage statistics for a specific asset
 * @access Private
 */
router.get('/:id/stats', idValidation, validateRequest, getAssetStatsLimit, asyncHandler(assetController.getAssetStats));

/**
 * @route POST /api/assets
 * @desc Create a new asset
 * @access Private
 */
router.post('/', createAssetValidation, validateRequest, createAssetLimit, asyncHandler(assetController.createAsset));

/**
 * @route POST /api/assets/:id/scan
 * @desc Trigger a scan/discovery for an asset
 * @access Private
 */
router.post(
  '/:id/scan',
  idValidation,
  [
    body('type').optional().isIn(['full', 'incremental', 'schema_only', 'profile_only']).withMessage('Invalid scan type'),
    body('force').optional().isBoolean().withMessage('Force must be a boolean'),
  ],
  validateRequest,
  scanAssetLimit,
  asyncHandler(assetController.scanAsset),
);

/**
 * @route POST /api/assets/:id/tags
 * @desc Add tags to an asset
 * @access Private
 */
router.post(
  '/:id/tags',
  idValidation,
  [
    body('tags').isArray({ min: 1 }).withMessage('Tags must be a non-empty array'),
    body('tags.*').isString().isLength({ min: 1, max: 50 }).withMessage('Each tag must be between 1 and 50 characters'),
  ],
  validateRequest,
  tagOperationsLimit,
  asyncHandler(assetController.addTags),
);

/**
 * @route PUT /api/assets/:id
 * @desc Update an asset
 * @access Private
 */
router.put('/:id', updateAssetValidation, validateRequest, updateAssetLimit, asyncHandler(assetController.updateAsset));

/**
 * @route PUT /api/assets/:id/classification
 * @desc Update asset classification
 * @access Private
 */
router.put(
  '/:id/classification',
  idValidation,
  [
    body('classification')
      .isIn(['public', 'internal', 'confidential', 'restricted'])
      .withMessage('Invalid classification level'),
    body('reason').optional().isString().isLength({ max: 500 }).withMessage('Reason must be less than 500 characters'),
  ],
  validateRequest,
  updateClassificationLimit,
  asyncHandler(assetController.updateClassification),
);

/**
 * @route DELETE /api/assets/:id
 * @desc Delete an asset (soft delete)
 * @access Private
 */
router.delete('/:id', idValidation, validateRequest, deleteAssetLimit, asyncHandler(assetController.deleteAsset));

/**
 * @route DELETE /api/assets/:id/tags
 * @desc Remove tags from an asset
 * @access Private
 */
router.delete(
  '/:id/tags',
  idValidation,
  [body('tags').isArray({ min: 1 }).withMessage('Tags must be a non-empty array'), body('tags.*').isString().withMessage('Each tag must be a string')],
  validateRequest,
  tagOperationsLimit,
  asyncHandler(assetController.removeTags),
);

export default router;



------------------------------------------------------------
FILE: backend\data-service\src\routes\dataSources.routes.ts
------------------------------------------------------------
import { Router } from 'express';
import { DataSourceController } from '../controllers/DataSourceController';
import { authMiddleware, optionalAuthMiddleware } from '../middleware/auth';

const r = Router();
const ctrl = new DataSourceController();

// READ (no hard auth; optional in dev)
r.get('/data-sources', optionalAuthMiddleware, ctrl.getAllDataSources);
r.get('/data-sources/health', optionalAuthMiddleware, ctrl.getHealthSummary);
r.get('/data-sources/:id', optionalAuthMiddleware, ctrl.getDataSourceById);
r.get('/data-sources/:id/schema', optionalAuthMiddleware, ctrl.getDataSourceSchema);

// WRITE (protected; in dev SKIP_AUTH=true bypasses)
r.post('/data-sources', authMiddleware, ctrl.createDataSource);
r.put('/data-sources/:id', authMiddleware, ctrl.updateDataSource);
r.delete('/data-sources/:id', authMiddleware, ctrl.deleteDataSource);
r.post('/data-sources/:id/test', authMiddleware, ctrl.testConnection);
r.post('/data-sources/:id/sync', authMiddleware, ctrl.syncDataSource);

export default r;



------------------------------------------------------------
FILE: backend\data-service\src\routes\dataSources.ts
------------------------------------------------------------
import { Router, type RequestHandler } from 'express';
import { body, param, query } from 'express-validator';
import { DataSourceController } from '../controllers/DataSourceController';
import { authMiddleware } from '../middleware/auth';
import { asyncHandler } from '../middleware/error';
import { createRateLimit } from '../middleware/rateLimit';
import { validateRequest } from '../middleware/validation';

// Use this ONE router file. Delete/ignore DataSources.routes.ts.
const router = Router();
const ctrl = new DataSourceController();

const asHandler = (h: any) => h as unknown as RequestHandler;
const IS_PROD = (process.env.NODE_ENV || '').toLowerCase() === 'production';

/** Type normalizers (inputs -> canonical) */
const CANONICAL_TYPES = [
  'postgresql','mysql','mssql','oracle','mongodb','redis',
  's3','azure-blob','gcs','snowflake','bigquery','redshift',
  'databricks','api','file','kafka','elasticsearch',
] as const;
type CanonicalType = (typeof CANONICAL_TYPES)[number];

const INPUT_TYPES = new Set<string>([...CANONICAL_TYPES, 'postgres']);
const normalizeType = (t?: string): CanonicalType | undefined => {
  if (!t) return undefined;
  const x = t.toLowerCase();
  const mapped = x === 'postgres' ? 'postgresql' : x;
  return (CANONICAL_TYPES as readonly string[]).includes(mapped)
    ? (mapped as CanonicalType)
    : undefined;
};

const INPUT_STATUSES = new Set<string>([
  'active','inactive','pending','error','testing','connected','disconnected','warning','syncing',
]);

/** Sort keys we allow from the UI */
const ALLOWED_SORT_BY = new Set(['updatedAt','createdAt','name','status','type'] as const);
const normalizeListParams: RequestHandler = (req, _res, next) => {
  // pagination
  const page = Math.max(parseInt(String(req.query.page ?? '1'), 10) || 1, 1);
  const limitRaw = Math.max(parseInt(String(req.query.limit ?? '20'), 10) || 20, 1);
  const limit = Math.min(limitRaw, 100);

  // sorting (keep UI names; service maps -> DB columns)
  const sortByRaw = String(req.query.sortBy ?? '').trim();
  const sortOrderRaw = String(req.query.sortOrder ?? '').trim().toLowerCase();
  const sortBy = ALLOWED_SORT_BY.has(sortByRaw as any) ? sortByRaw : 'updatedAt';
  const sortOrder = sortOrderRaw === 'asc' ? 'asc' : 'desc';

  // filters (normalized)
  const status = typeof req.query.status === 'string' && INPUT_STATUSES.has(req.query.status.toLowerCase())
    ? req.query.status.toLowerCase()
    : undefined;
  const type = normalizeType(req.query.type as string | undefined);

  req.query.page = String(page);
  req.query.limit = String(limit);
  req.query.sortBy = sortBy;
  req.query.sortOrder = sortOrder;
  if (status) req.query.status = status; else delete req.query.status;
  if (type) req.query.type = type; else delete req.query.type;

  next();
};

// Rate limits
const listLimit    = asHandler(createRateLimit({ windowMs: 60_000, max: 100 }));
const healthLimit  = asHandler(createRateLimit({ windowMs: 60_000, max: 60  }));
const getByIdLimit = asHandler(createRateLimit({ windowMs: 60_000, max: 200 }));
const schemaLimit  = asHandler(createRateLimit({ windowMs: 60_000, max: 30  }));
const createLimit  = asHandler(createRateLimit({ windowMs: 60_000, max: 20  }));
const testLimit    = asHandler(createRateLimit({ windowMs: 60_000, max: 10  }));
const syncLimit    = asHandler(createRateLimit({ windowMs: 60_000, max: 5   }));
const updateLimit  = asHandler(createRateLimit({ windowMs: 60_000, max: 30  }));
const deleteLimit  = asHandler(createRateLimit({ windowMs: 60_000, max: 10  }));

// Validation
const paginationValidation = [
  query('page').optional().isInt({ min: 1 }),
  query('limit').optional().isInt({ min: 1, max: 100 }),
  query('status').optional().isString().custom((v) => INPUT_STATUSES.has(String(v).toLowerCase())),
  query('type').optional().isString().custom((v) => INPUT_TYPES.has(String(v).toLowerCase())),
  query('sortBy').optional().isString(),
  query('sortOrder').optional().isIn(['asc','desc']),
  query('search').optional().isString(),
  query('createdBy').optional().isString(),
];

const idValidation = [param('id').isString()];

const createDataSourceValidation = [
  body('name').isString().isLength({ min: 1, max: 255 }),
  body('description').optional().isString().isLength({ max: 1000 }),
  body('type').isString()
    .custom((val) => INPUT_TYPES.has(String(val).toLowerCase()))
    .customSanitizer((val) => normalizeType(String(val))),
  body('connectionConfig').isObject(),
  body('tags').optional().isArray(),
  body('metadata').optional().isObject(),
];

const updateDataSourceValidation = [
  param('id').isString(),
  body('name').optional().isString().isLength({ min: 1, max: 255 }),
  body('description').optional().isString().isLength({ max: 1000 }),
  body('type').optional().isString()
    .custom((val) => INPUT_TYPES.has(String(val).toLowerCase()))
    .customSanitizer((val) => normalizeType(String(val))),
  body('connectionConfig').optional().isObject(),
  body('tags').optional().isArray(),
  body('metadata').optional().isObject(),
];

/** Guard: in dev accept SKIP_AUTH=true or header X-Dev-Auth: 1 */
const guard: RequestHandler = (req, res, next) => {
  const devBypass =
    !IS_PROD &&
    (
      (process.env.SKIP_AUTH || '').toLowerCase() === 'true' ||
      (process.env.MOCK_AUTH || '').toLowerCase() === 'true' ||
      req.header('x-dev-auth') === '1'
    );
  if (devBypass) return next();
  return authMiddleware(req, res, next);
};

/** ROUTES (relative!) â€” app.ts adds the /api/data-sources & /data-sources prefixes */
router.get(
  '/',
  guard,
  paginationValidation,
  validateRequest,
  normalizeListParams,
  listLimit,
  asyncHandler(ctrl.getAllDataSources),
);

router.get('/health', guard, healthLimit, asyncHandler(ctrl.getHealthSummary));

router.get('/:id', guard, idValidation, validateRequest, getByIdLimit, asyncHandler(ctrl.getDataSourceById));
router.get('/:id/schema', guard, idValidation, validateRequest, schemaLimit, asyncHandler(ctrl.getDataSourceSchema));

router.post('/', guard, createDataSourceValidation, validateRequest, createLimit, asyncHandler(ctrl.createDataSource));
router.put('/:id', guard, updateDataSourceValidation, validateRequest, updateLimit, asyncHandler(ctrl.updateDataSource));
router.delete('/:id', guard, idValidation, validateRequest, deleteLimit, asyncHandler(ctrl.deleteDataSource));

router.post('/:id/test', guard, idValidation, validateRequest, testLimit, asyncHandler(ctrl.testConnection));
router.post('/:id/sync',
  guard,
  idValidation,
  body('force').optional().isBoolean(),
  validateRequest,
  syncLimit,
  asyncHandler(ctrl.syncDataSource),
);

export default router;



------------------------------------------------------------
FILE: backend\data-service\src\routes\index.ts
------------------------------------------------------------
import { Router } from 'express';
import dataSourceRoutes from './dataSources';

const api = Router();

// mount exactly as the frontend/gateway calls it
api.use('/data-sources', dataSourceRoutes);

export default api;



------------------------------------------------------------
FILE: backend\data-service\src\routes\sources.ts
------------------------------------------------------------
// backend/data-service/src/routes/sources.ts
import { Router, type RequestHandler } from 'express';
import { body, param, query } from 'express-validator';
import { DataSourceController } from '../controllers/DataSourceController';
import { authMiddleware } from '../middleware/auth';
import { asyncHandler } from '../middleware/error';
import { createRateLimit } from '../middleware/rateLimit';
import { validateDataSource, validateDataSourceUpdate, validateRequest } from '../middleware/validation';

const router = Router();
const dataSourceController = new DataSourceController();

// Helper to coerce mixed-type middlewares into Express' RequestHandler
const asHandler = (h: any) => h as unknown as RequestHandler;

// ðŸ” Auth on every route
router.use(asHandler(authMiddleware));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Validation
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const paginationValidation = [
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  query('type')
    .optional()
    .isIn([
      'postgresql', 'mysql', 'mssql', 'oracle', 'mongodb', 'redis',
      's3', 'azure-blob', 'gcs', 'snowflake', 'bigquery', 'redshift',
      'databricks', 'api', 'file', 'kafka', 'elasticsearch',
    ])
    .withMessage('Invalid source type filter'),
  query('status')
    .optional()
    .isIn(['pending', 'connected', 'disconnected', 'error', 'warning', 'syncing', 'testing'])
    .withMessage('Invalid status filter'),
];

const idValidation = [param('id').isUUID().withMessage('Source ID must be a valid UUID')];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Per-route rate limiters (use the factory; donâ€™t â€œcallâ€ a handler as a fn)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const listSourcesLimit          = asHandler(createRateLimit({ windowMs: 60_000, max: 100 }));
const healthLimit               = asHandler(createRateLimit({ windowMs: 60_000, max: 60 }));
const getSourceLimit            = asHandler(createRateLimit({ windowMs: 60_000, max: 200 }));
const schemaLimit               = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const createSourceLimit         = asHandler(createRateLimit({ windowMs: 60_000, max: 20 }));
const testLimit                 = asHandler(createRateLimit({ windowMs: 60_000, max: 10 }));
const discoverSourceLimit       = asHandler(createRateLimit({ windowMs: 60_000, max: 5 }));
const updateSourceLimit         = asHandler(createRateLimit({ windowMs: 60_000, max: 30 }));
const updateStatusLimit         = asHandler(createRateLimit({ windowMs: 60_000, max: 20 }));
const deleteSourceLimit         = asHandler(createRateLimit({ windowMs: 60_000, max: 10 }));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Routes â€“ only methods that exist on DataSourceController
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * @route GET /api/sources
 * @desc Get all data sources with pagination & filters
 */
router.get(
  '/',
  paginationValidation,
  validateRequest,
  listSourcesLimit,
  asyncHandler(dataSourceController.getAllDataSources),
);

/**
 * @route GET /api/sources/health
 * @desc Health summary of all data sources
 */
router.get(
  '/health',
  healthLimit,
  asyncHandler(dataSourceController.getHealthSummary),
);

/**
 * @route GET /api/sources/:id
 * @desc Get a data source by ID
 */
router.get(
  '/:id',
  idValidation,
  validateRequest,
  getSourceLimit,
  asyncHandler(dataSourceController.getDataSourceById),
);

/**
 * @route GET /api/sources/:id/schema
 * @desc Get schema for a data source
 */
router.get(
  '/:id/schema',
  idValidation,
  validateRequest,
  schemaLimit,
  asyncHandler(dataSourceController.getDataSourceSchema),
);

/**
 * @route POST /api/sources
 * @desc Create a new data source
 */
router.post(
  '/',
  validateDataSource,
  validateRequest,
  createSourceLimit,
  asyncHandler(dataSourceController.createDataSource),
);

/**
 * @route POST /api/sources/:id/test
 * @desc Test connection for an existing source
 * (if you want a â€œtest without creatingâ€ endpoint, add a controller method first)
 */
router.post(
  '/:id/test',
  idValidation,
  validateRequest,
  testLimit,
  asyncHandler(dataSourceController.testConnection),
);

/**
 * @route POST /api/sources/:id/discover
 * @desc Trigger discovery/sync on a source
 */
router.post(
  '/:id/discover',
  idValidation,
  [
    body('force').optional().isBoolean().withMessage('Force must be a boolean'),
  ],
  validateRequest,
  discoverSourceLimit,
  asyncHandler(dataSourceController.syncDataSource),
);

/**
 * @route PUT /api/sources/:id
 * @desc Update a data source
 */
router.put(
  '/:id',
  validateDataSourceUpdate,
  validateRequest,
  updateSourceLimit,
  asyncHandler(dataSourceController.updateDataSource),
);

/**
 * @route PUT /api/sources/:id/status
 * @desc Update status for a data source (reuses updateDataSource)
 */
router.put(
  '/:id/status',
  idValidation,
  [
    body('status')
      .isIn(['pending', 'connected', 'disconnected', 'error', 'warning', 'syncing', 'testing'])
      .withMessage('Invalid status'),
    body('reason').optional().isString().isLength({ max: 500 }).withMessage('Reason must be less than 500 characters'),
  ],
  validateRequest,
  updateStatusLimit,
  asyncHandler(dataSourceController.updateDataSource),
);

/**
 * @route DELETE /api/sources/:id
 * @desc Delete a data source
 */
router.delete(
  '/:id',
  idValidation,
  validateRequest,
  deleteSourceLimit,
  asyncHandler(dataSourceController.deleteDataSource),
);

export default router;



------------------------------------------------------------
FILE: backend\data-service\src\server.ts
------------------------------------------------------------
// src/server.ts
import 'dotenv/config';
import App from './app';
import { config, logConfig } from './config/env';
import { logger } from './utils/logger';

type AppLifecycle = {
  initialize?: () => Promise<void> | void;
  cleanup?: () => Promise<void> | void;
  getExpressApp: () => import('express').Express;
};

class Server {
  private app: App;
  private server: any;

  constructor() {
    this.app = new (App as any)();
  }

  public async start(): Promise<void> {
    try {
      // Log env at boot (safe if logConfig is a no-op)
      try { logConfig?.(); } catch (e) { logger.warn('[data-service] logConfig failed', e as any); }

      // Start listening first so /health is available ASAP
      const host = config?.server?.host || process.env.HOST || '0.0.0.0';
      const port = Number(config?.server?.port || process.env.PORT || 3002);

      const expressApp = (this.app as unknown as AppLifecycle).getExpressApp();
      this.server = expressApp.listen(port, host, () => {
        logger.info(`🚀 data-service listening on http://${host}:${port}`);
        logger.info(`📍 liveness:  GET /health`);
        logger.info(`📍 readiness: GET /ready`);
        logger.info(`🌱 NODE_ENV=${process.env.NODE_ENV || 'development'}`);
      });

      // Visibility if bind fails
      this.server.on('error', (err: any) => {
        logger.error('[data-service] HTTP server error', {
          message: err?.message,
          code: err?.code,
          stack: err?.stack,
        });
      });

      // Initialize dependencies (DB/redis/etc.) without blocking health
      const lifecycle = this.app as unknown as AppLifecycle;
      Promise.resolve(lifecycle.initialize?.()).catch((err: any) => {
        logger.error('[data-service] App init failed', { message: err?.message, stack: err?.stack });
      });

      // Graceful shutdown
      const shutdown = (signal: string) => {
        logger.warn(`[data-service] ${signal} received. Shutting down...`);
        this.server?.close(async (err?: Error) => {
          if (err) {
            logger.error('[data-service] Error during close', { message: err.message, stack: err.stack });
            process.exit(1);
            return;
          }
          logger.info('[data-service] HTTP server closed');

          try {
            if (typeof lifecycle.cleanup === 'function') {
              await Promise.resolve(lifecycle.cleanup());
            }
          } catch (e: any) {
            logger.error('[data-service] cleanup failed', { message: e?.message, stack: e?.stack });
          } finally {
            process.exit(0);
          }
        });

        // Failsafe timer
        setTimeout(() => {
          logger.warn('[data-service] Forced shutdown after 10s');
          process.exit(1);
        }, 10_000).unref();
      };

      process.on('SIGINT', () => shutdown('SIGINT'));
      process.on('SIGTERM', () => shutdown('SIGTERM'));
      process.on('uncaughtException', (err: any) => {
        logger.error('[data-service] Uncaught exception', { message: err?.message, stack: err?.stack });
      });
      process.on('unhandledRejection', (reason: any) => {
        logger.error('[data-service] Unhandled rejection', {
          reason: reason?.message || String(reason),
          stack: reason?.stack,
        });
      });
    } catch (e: any) {
      logger.error('[data-service] Startup failed', { message: e?.message, stack: e?.stack });
      process.exit(1);
    }
  }
}

if (require.main === module) {
  new Server()
    .start()
    .catch((err) => {
      logger.error('[data-service] Failed to start server', { message: err?.message, stack: err?.stack });
      process.exit(1);
    });
}

export default Server;



------------------------------------------------------------
FILE: backend\data-service\src\services\AssetService.ts
------------------------------------------------------------
// src/services/AssetService.ts
import { Asset, Column } from '../controllers/AssetController';
import { logger } from '../utils/logger';
import { DatabaseService } from './DatabaseService';

export interface AssetFilters {
  search?: string;
  type?: string;
  dataSourceId?: string;
  status?: string;
  tags?: string[];
  sensitivity?: string;
}

export interface AssetPagination {
  page: number;
  limit: number;
}

export interface AssetResult {
  assets: Asset[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface AssetLineage {
  upstream: Asset[];
  downstream: Asset[];
  relationships: LineageRelationship[];
}

export interface LineageRelationship {
  fromAsset: string;
  toAsset: string;
  type: 'table_to_view' | 'procedure_call' | 'data_flow' | 'dependency';
  description?: string;
}

export interface AssetStats {
  accessCount: number;
  lastAccessed: Date | null;
  avgQueryTime: number;
  dataVolume: {
    current: number;
    trend: 'increasing' | 'decreasing' | 'stable';
    changePercent: number;
  };
  qualityScore: number;
  usageMetrics: {
    date: string;
    count: number;
  }[];
}

export class AssetService {
  private db: DatabaseService;

  constructor() {
    this.db = new DatabaseService();
  }

  /**
   * Get assets with filtering and pagination
   */
  public async getAssets(filters: AssetFilters, pagination: AssetPagination): Promise<AssetResult> {
    try {
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;

      // Build dynamic WHERE clause
      const conditions: string[] = [];
      const params: any[] = [];
      let paramIndex = 1;

      if (filters.search) {
        conditions.push(`(a.name ILIKE $${paramIndex} OR a.description ILIKE $${paramIndex})`);
        params.push(`%${filters.search}%`);
        paramIndex++;
      }

      if (filters.type) {
        conditions.push(`a.type = $${paramIndex}`);
        params.push(filters.type);
        paramIndex++;
      }

      if (filters.dataSourceId) {
        conditions.push(`a.data_source_id = $${paramIndex}`);
        params.push(filters.dataSourceId);
        paramIndex++;
      }

      if (filters.status) {
        conditions.push(`a.status = $${paramIndex}`);
        params.push(filters.status);
        paramIndex++;
      }

      if (filters.sensitivity) {
        conditions.push(`a.metadata->>'sensitivity' = $${paramIndex}`);
        params.push(filters.sensitivity);
        paramIndex++;
      }

      if (filters.tags && filters.tags.length > 0) {
        conditions.push(`a.tags && $${paramIndex}`);
        params.push(filters.tags);
        paramIndex++;
      }

      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      // Count query
      const countQuery = `
        SELECT COUNT(*) as total
        FROM assets a
        ${whereClause}
      `;

      // Data query
      const dataQuery = `
        SELECT 
          a.*,
          ds.name as data_source_name,
          ds.type as data_source_type
        FROM assets a
        LEFT JOIN data_sources ds ON a.data_source_id = ds.id
        ${whereClause}
        ORDER BY a.updated_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      params.push(limit, offset);

      const [countResult, dataResult] = await Promise.all([
        this.db.query(countQuery, params.slice(0, -2)),
        this.db.query(dataQuery, params)
      ]);

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      const assets: Asset[] = dataResult.rows.map(row => ({
        id: row.id,
        name: row.name,
        type: row.type,
        dataSourceId: row.data_source_id,
        schemaName: row.schema_name,
        tableName: row.table_name,
        description: row.description,
        columns: row.columns || [],
        tags: row.tags || [],
        status: row.status,
        createdAt: new Date(row.created_at),
        updatedAt: new Date(row.updated_at),
        metadata: row.metadata || {},
      }));

      return {
        assets,
        total,
        page,
        limit,
        totalPages,
      };
    } catch (error) {
      logger.error('Error in getAssets:', error);
      throw new Error('Failed to fetch assets');
    }
  }

  /**
   * Get asset by ID
   */
  public async getAssetById(id: string): Promise<Asset | null> {
    try {
      const query = `
        SELECT 
          a.*,
          ds.name as data_source_name,
          ds.type as data_source_type
        FROM assets a
        LEFT JOIN data_sources ds ON a.data_source_id = ds.id
        WHERE a.id = $1
      `;

      const result = await this.db.query(query, [id]);

      if (result.rows.length === 0) {
        return null;
      }

      const row = result.rows[0];
      return {
        id: row.id,
        name: row.name,
        type: row.type,
        dataSourceId: row.data_source_id,
        schemaName: row.schema_name,
        tableName: row.table_name,
        description: row.description,
        columns: row.columns || [],
        tags: row.tags || [],
        status: row.status,
        createdAt: new Date(row.created_at),
        updatedAt: new Date(row.updated_at),
        metadata: row.metadata || {},
      };
    } catch (error) {
      logger.error('Error in getAssetById:', error);
      throw new Error('Failed to fetch asset');
    }
  }

  /**
   * Create a new asset
   */
  public async createAsset(assetData: Partial<Asset>): Promise<Asset> {
    try {
      const {
        name,
        type,
        dataSourceId,
        schemaName,
        tableName,
        description,
        columns,
        tags,
        status = 'active',
        metadata = {}
      } = assetData;

      const query = `
        INSERT INTO assets (
          name, type, data_source_id, schema_name, table_name,
          description, columns, tags, status, metadata
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *
      `;

      const values = [
        name,
        type,
        dataSourceId,
        schemaName,
        tableName,
        description,
        JSON.stringify(columns || []),
        tags || [],
        status,
        JSON.stringify(metadata)
      ];

      const result = await this.db.query(query, values);
      return this.mapRowToAsset(result.rows[0]);
    } catch (error) {
      logger.error('Error in createAsset:', error);
      throw new Error('Failed to create asset');
    }
  }

  /**
   * Search assets
   */
  public async searchAssets(
    filters: { search: string; type?: string },
    pagination: AssetPagination
  ): Promise<AssetResult> {
    try {
      const { page, limit } = pagination;
      const offset = (page - 1) * limit;

      // Build search query with full-text search
      const conditions: string[] = [];
      const params: any[] = [];
      let paramIndex = 1;

      if (filters.search) {
        conditions.push(`(
          to_tsvector('english', coalesce(a.name, '') || ' ' || coalesce(a.description, '')) 
          @@ plainto_tsquery('english', $${paramIndex})
          OR a.name ILIKE $${paramIndex + 1}
          OR a.description ILIKE $${paramIndex + 1}
        )`);
        params.push(filters.search, `%${filters.search}%`);
        paramIndex += 2;
      }

      if (filters.type) {
        conditions.push(`a.type = $${paramIndex}`);
        params.push(filters.type);
        paramIndex++;
      }

      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      // Count query
      const countQuery = `
        SELECT COUNT(*) as total
        FROM assets a
        ${whereClause}
      `;

      // Data query
      const dataQuery = `
        SELECT 
          a.*,
          ds.name as data_source_name,
          ds.type as data_source_type,
          ts_rank(to_tsvector('english', coalesce(a.name, '') || ' ' || coalesce(a.description, '')), 
                   plainto_tsquery('english', $1)) as search_rank
        FROM assets a
        LEFT JOIN data_sources ds ON a.data_source_id = ds.id
        ${whereClause}
        ORDER BY ${filters.search ? 'search_rank DESC,' : ''} a.updated_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      params.push(limit, offset);

      const [countResult, dataResult] = await Promise.all([
        this.db.query(countQuery, params.slice(0, -2)),
        this.db.query(dataQuery, params)
      ]);

      const total = parseInt(countResult.rows[0].total);
      const totalPages = Math.ceil(total / limit);

      const assets: Asset[] = dataResult.rows.map(row => this.mapRowToAsset(row));

      return {
        assets,
        total,
        page,
        limit,
        totalPages,
      };
    } catch (error) {
      logger.error('Error in searchAssets:', error);
      throw new Error('Failed to search assets');
    }
  }

  /**
   * Get asset schema details
   */
  public async getAssetSchema(id: string): Promise<Column[] | null> {
    try {
      const query = `
        SELECT columns
        FROM assets
        WHERE id = $1
      `;

      const result = await this.db.query(query, [id]);

      if (result.rows.length === 0) {
        return null;
      }

      return result.rows[0].columns || [];
    } catch (error) {
      logger.error('Error in getAssetSchema:', error);
      throw new Error('Failed to fetch asset schema');
    }
  }

  /**
   * Get asset lineage
   */
  public async getAssetLineage(id: string, direction: 'upstream' | 'downstream' | 'both'): Promise<AssetLineage> {
    try {
      // Mock implementation - in real scenario, you'd analyze SQL queries, ETL processes, etc.
      const upstreamQuery = `
        SELECT DISTINCT a.*
        FROM assets a
        JOIN asset_lineage al ON a.id = al.upstream_asset_id
        WHERE al.downstream_asset_id = $1
      `;

      const downstreamQuery = `
        SELECT DISTINCT a.*
        FROM assets a
        JOIN asset_lineage al ON a.id = al.downstream_asset_id
        WHERE al.upstream_asset_id = $1
      `;

      const relationshipsQuery = `
        SELECT *
        FROM asset_lineage
        WHERE upstream_asset_id = $1 OR downstream_asset_id = $1
      `;

      let upstream: Asset[] = [];
      let downstream: Asset[] = [];

      if (direction === 'upstream' || direction === 'both') {
        const upstreamResult = await this.db.query(upstreamQuery, [id]);
        upstream = upstreamResult.rows.map(this.mapRowToAsset);
      }

      if (direction === 'downstream' || direction === 'both') {
        const downstreamResult = await this.db.query(downstreamQuery, [id]);
        downstream = downstreamResult.rows.map(this.mapRowToAsset);
      }

      const relationshipsResult = await this.db.query(relationshipsQuery, [id]);
      const relationships: LineageRelationship[] = relationshipsResult.rows.map(row => ({
        fromAsset: row.upstream_asset_id,
        toAsset: row.downstream_asset_id,
        type: row.relationship_type,
        description: row.description,
      }));

      return {
        upstream,
        downstream,
        relationships,
      };
    } catch (error) {
      logger.error('Error in getAssetLineage:', error);
      throw new Error('Failed to fetch asset lineage');
    }
  }

  /**
   * Update asset
   */
  public async updateAsset(id: string, updateData: Partial<Asset>): Promise<Asset | null> {
    try {
      const setClause: string[] = [];
      const params: any[] = [];
      let paramIndex = 1;

      if (updateData.name) {
        setClause.push(`name = $${paramIndex++}`);
        params.push(updateData.name);
      }

      if (updateData.description) {
        setClause.push(`description = $${paramIndex++}`);
        params.push(updateData.description);
      }

      if (updateData.status) {
        setClause.push(`status = $${paramIndex++}`);
        params.push(updateData.status);
      }

      if (updateData.tags) {
        setClause.push(`tags = $${paramIndex++}`);
        params.push(updateData.tags);
      }

      if (updateData.metadata) {
        setClause.push(`metadata = $${paramIndex++}`);
        params.push(JSON.stringify(updateData.metadata));
      }

      setClause.push(`updated_at = NOW()`);
      params.push(id);

      const query = `
        UPDATE assets
        SET ${setClause.join(', ')}
        WHERE id = $${paramIndex}
        RETURNING *
      `;

      const result = await this.db.query(query, params);

      if (result.rows.length === 0) {
        return null;
      }

      return this.mapRowToAsset(result.rows[0]);
    } catch (error) {
      logger.error('Error in updateAsset:', error);
      throw new Error('Failed to update asset');
    }
  }

  /**
   * Add tags to asset
   */
  public async addTags(id: string, tags: string[]): Promise<Asset | null> {
    try {
      const query = `
        UPDATE assets
        SET tags = COALESCE(tags, '{}') || $1::text[],
            updated_at = NOW()
        WHERE id = $2
        RETURNING *
      `;

      const result = await this.db.query(query, [tags, id]);

      if (result.rows.length === 0) {
        return null;
      }

      return this.mapRowToAsset(result.rows[0]);
    } catch (error) {
      logger.error('Error in addTags:', error);
      throw new Error('Failed to add tags');
    }
  }

  /**
   * Remove tags from asset
   */
  public async removeTags(id: string, tags: string[]): Promise<Asset | null> {
    try {
      const query = `
        UPDATE assets
        SET tags = ARRAY(SELECT unnest(tags) EXCEPT SELECT unnest($1::text[])),
            updated_at = NOW()
        WHERE id = $2
        RETURNING *
      `;

      const result = await this.db.query(query, [tags, id]);

      if (result.rows.length === 0) {
        return null;
      }

      return this.mapRowToAsset(result.rows[0]);
    } catch (error) {
      logger.error('Error in removeTags:', error);
      throw new Error('Failed to remove tags');
    }
  }

  /**
   * Get asset usage statistics
   */
  public async getAssetStats(id: string, period: string): Promise<AssetStats> {
    try {
      // Mock implementation - in real scenario, you'd aggregate from usage logs
      const statsQuery = `
        SELECT 
          COALESCE(usage.access_count, 0) as access_count,
          usage.last_accessed,
          COALESCE(usage.avg_query_time, 0) as avg_query_time,
          COALESCE(metadata->>'rowCount', '0')::bigint as current_volume,
          COALESCE((metadata->>'qualityScore')::numeric, 85) as quality_score
        FROM assets a
        LEFT JOIN asset_usage_stats usage ON a.id = usage.asset_id
        WHERE a.id = $1
      `;

      const result = await this.db.query(statsQuery, [id]);
      
      if (result.rows.length === 0) {
        throw new Error('Asset not found');
      }

      const row = result.rows[0];

      // Mock usage metrics for the period
      const usageMetrics = this.generateMockUsageMetrics(period);

      return {
        accessCount: row.access_count,
        lastAccessed: row.last_accessed ? new Date(row.last_accessed) : null,
        avgQueryTime: row.avg_query_time,
        dataVolume: {
          current: row.current_volume,
          trend: 'increasing',
          changePercent: 12.5,
        },
        qualityScore: row.quality_score,
        usageMetrics,
      };
    } catch (error) {
      logger.error('Error in getAssetStats:', error);
      throw new Error('Failed to fetch asset stats');
    }
  }

  /**
   * Get asset profile/data preview
   */
  public async getAssetProfile(id: string): Promise<{
    asset: Asset;
    profile: {
      rowCount: number;
      columnCount: number;
      dataTypes: Record<string, number>;
      nullCounts: Record<string, number>;
      sampleData: any[];
      lastProfiledAt: Date;
    };
  } | null> {
    try {
      const asset = await this.getAssetById(id);
      if (!asset) {
        return null;
      }

      // Mock profile data - in real implementation, this would connect to the data source
      const profile = {
        rowCount: Math.floor(Math.random() * 1000000) + 1000,
        columnCount: asset.columns?.length || 0,
        dataTypes: {
          'string': Math.floor(Math.random() * 10) + 1,
          'integer': Math.floor(Math.random() * 5) + 1,
          'decimal': Math.floor(Math.random() * 3) + 1,
          'date': Math.floor(Math.random() * 2) + 1,
          'boolean': Math.floor(Math.random() * 2),
        },
        nullCounts: asset.columns?.reduce((acc, col) => {
          acc[col.name] = Math.floor(Math.random() * 100);
          return acc;
        }, {} as Record<string, number>) || {},
        sampleData: [
          // Mock sample data
          { id: 1, name: 'Sample Row 1', value: 100 },
          { id: 2, name: 'Sample Row 2', value: 200 },
          { id: 3, name: 'Sample Row 3', value: 300 },
        ],
        lastProfiledAt: new Date(),
      };

      return {
        asset,
        profile,
      };
    } catch (error) {
      logger.error('Error in getAssetProfile:', error);
      throw new Error('Failed to get asset profile');
    }
  }

  /**
   * Sync asset metadata from data source
   */
  public async syncAsset(id: string): Promise<{ success: boolean; updatedFields: string[] }> {
    try {
      // Mock implementation - in real scenario, you'd connect to the data source
      // and refresh metadata (row counts, schema changes, etc.)
      
      const updateQuery = `
        UPDATE assets
        SET 
          metadata = metadata || '{"lastSyncAt": "' || NOW() || '", "syncStatus": "completed"}',
          updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `;

      const result = await this.db.query(updateQuery, [id]);

      if (result.rows.length === 0) {
        throw new Error('Asset not found');
      }

      return {
        success: true,
        updatedFields: ['metadata', 'rowCount', 'lastSyncAt'],
      };
    } catch (error) {
      logger.error('Error in syncAsset:', error);
      throw new Error('Failed to sync asset');
    }
  }

  /**
   * Delete asset
   */
  public async deleteAsset(id: string): Promise<boolean> {
    try {
      const query = `
        DELETE FROM assets
        WHERE id = $1
        RETURNING id
      `;

      const result = await this.db.query(query, [id]);
      return result.rows.length > 0;
    } catch (error) {
      logger.error('Error in deleteAsset:', error);
      throw new Error('Failed to delete asset');
    }
  }

  /**
   * Helper method to map database row to Asset object
   */
  private mapRowToAsset(row: any): Asset {
    return {
      id: row.id,
      name: row.name,
      type: row.type,
      dataSourceId: row.data_source_id,
      schemaName: row.schema_name,
      tableName: row.table_name,
      description: row.description,
      columns: row.columns || [],
      tags: row.tags || [],
      status: row.status,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      metadata: row.metadata || {},
    };
  }

  /**
   * Generate mock usage metrics for testing
   */
  private generateMockUsageMetrics(period: string): { date: string; count: number }[] {
    const days = period === '7d' ? 7 : period === '30d' ? 30 : 90;
    const metrics: { date: string; count: number }[] = [];

    for (let i = days - 1; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      
      metrics.push({
        date: date.toISOString().split('T')[0],
        count: Math.floor(Math.random() * 50) + 10,
      });
    }

    return metrics;
  }
}


------------------------------------------------------------
FILE: backend\data-service\src\services\connectors\azureSql.ts
------------------------------------------------------------
import { ConnectionPool, config as MSSQLConfig, Request } from 'mssql';
import type { ConnectionConfig, ConnectionTestResult } from '../../models/Connection';
import { logger } from '../../utils/logger';
import {
  BaseConnector,
  type Column,
  type QueryResult,
  type Schema,
  type SchemaInfo,
  type Table,
  type View,
} from './base';

export interface AzureSqlConfig {
  server: string;
  database: string;
  user: string;
  password: string;
  port?: number;
  options?: {
    encrypt?: boolean;
    trustServerCertificate?: boolean;
    enableArithAbort?: boolean;
    connectionTimeout?: number;
    requestTimeout?: number;
  };
  pool?: {
    max?: number;
    min?: number;
    idleTimeoutMillis?: number;
  };
}

export class AzureSqlConnector extends BaseConnector {
  private pool: ConnectionPool | null = null;
  private config: AzureSqlConfig;

  constructor(conn: ConnectionConfig) {
    super('azure-sql', conn);
    this.config = this.parseConfig(conn);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ config parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  private parseConfig(c: ConnectionConfig): AzureSqlConfig {
    const anyC = c as any;
    const trustServerCertificate =
      typeof anyC.trustServerCertificate === 'boolean'
        ? anyC.trustServerCertificate
        : typeof c.ssl === 'object'
        ? (c.ssl as any)?.rejectUnauthorized === false
        : false;

    return {
      server: c.host ?? anyC.server ?? '',
      database: (c.database as string) ?? anyC.db ?? '',
      user: (c.username as string) ?? anyC.user ?? '',
      password: (c.password as string) ?? '',
      port: c.port ?? 1433,
      options: {
        encrypt: true, // Azure SQL requires encrypt
        trustServerCertificate,
        enableArithAbort: true,
        connectionTimeout: anyC.connectionTimeout ?? c.timeout ?? 30_000,
        requestTimeout: anyC.requestTimeout ?? c.timeout ?? 30_000,
      },
      pool: {
        max: anyC.maxConnections ?? 10,
        min: anyC.minConnections ?? 1,
        idleTimeoutMillis: anyC.idleTimeout ?? 30_000,
        ...(anyC.poolOptions ?? {}),
      },
    };
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ connect / disconnect â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  override async connect(): Promise<void> {
    try {
      if (this.pool?.connected) return;

      const poolConfig: MSSQLConfig = {
        server: this.config.server,
        database: this.config.database,
        user: this.config.user,
        password: this.config.password,
        port: this.config.port,
        options: this.config.options,
        pool: this.config.pool,
      };

      this.pool = new ConnectionPool(poolConfig);

      this.pool.on('error', (err: Error) => {
        logger.error('Azure SQL pool error:', err);
        this.emitConnectionEvent('error', err);
      });

      await this.pool.connect();

      (this as any).metrics.connected = true;
      this.emitConnectionEvent('connected', {
        server: this.config.server,
        database: this.config.database,
      });

      logger.info(`Connected to Azure SQL: ${this.config.server}/${this.config.database}`);
    } catch (error) {
      (this as any).metrics.connected = false;
      logger.error('Failed to connect to Azure SQL:', error);
      throw this.createConnectionError(error);
    }
  }

  override async disconnect(): Promise<void> {
    try {
      if (this.pool) {
        this.pool.removeAllListeners?.('error');
        await this.pool.close();
        this.pool = null;
        (this as any).metrics.connected = false;
        this.emitConnectionEvent('disconnected');
        logger.info('Disconnected from Azure SQL');
      }
    } catch (error) {
      logger.error('Error disconnecting from Azure SQL:', error);
      throw error;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ basic ops â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  override async testConnection(): Promise<ConnectionTestResult> {
    const t0 = Date.now();
    try {
      await this.connect();
      const req = new Request(this.pool!);
      const result = await req.query('SELECT @@VERSION AS version, DB_NAME() AS database_name');
      return {
        success: true,
        responseTime: Date.now() - t0,
        details: {
          version: (result as any)?.recordset?.[0]?.version,
          serverInfo: {
            type: 'Azure SQL Database',
            database: (result as any)?.recordset?.[0]?.database_name,
            server: this.config.server,
          },
          capabilities: ['SQL', 'ACID', 'Transactions', 'Stored Procedures', 'Functions'],
        },
        testedAt: new Date(),
      };
    } catch (error: any) {
      return {
        success: false,
        responseTime: Date.now() - t0,
        error: error?.message || 'Unknown error',
        testedAt: new Date(),
      };
    }
  }

  override async executeQuery(query: string, params?: any[]): Promise<QueryResult> {
    return this.executeWithMetrics(async () => {
      await this.ensureConnected();
      const req = new Request(this.pool!);

      if (params?.length) {
        params.forEach((p, i) => req.input(`p${i}`, p));
        let idx = 0;
        query = query.replace(/\?/g, () => `@p${idx++}`);
      }

      const r = await req.query(query);
      return {
        rows: (r as any).recordset ?? [],
        rowCount: (r as any).rowsAffected?.[0] ?? ((r as any).recordset?.length || 0),
        columns: (r as any).recordset?.columns || {},
      };
    });
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ schema & metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  override async getSchema(): Promise<SchemaInfo> {
    await this.ensureConnected();

    const schemaQuery = `
      SELECT 
        t.TABLE_SCHEMA,
        t.TABLE_NAME,
        t.TABLE_TYPE,
        c.COLUMN_NAME,
        c.DATA_TYPE,
        c.IS_NULLABLE,
        c.COLUMN_DEFAULT,
        c.CHARACTER_MAXIMUM_LENGTH,
        c.NUMERIC_PRECISION,
        c.NUMERIC_SCALE,
        CASE WHEN pk.COLUMN_NAME IS NOT NULL THEN 1 ELSE 0 END AS IS_PRIMARY_KEY
      FROM INFORMATION_SCHEMA.TABLES t
      LEFT JOIN INFORMATION_SCHEMA.COLUMNS c
        ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA
      LEFT JOIN (
        SELECT ku.TABLE_SCHEMA, ku.TABLE_NAME, ku.COLUMN_NAME
        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
        INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE ku
          ON tc.CONSTRAINT_NAME = ku.CONSTRAINT_NAME
          AND tc.TABLE_SCHEMA = ku.TABLE_SCHEMA
        WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
      ) pk ON c.TABLE_SCHEMA = pk.TABLE_SCHEMA 
         AND c.TABLE_NAME   = pk.TABLE_NAME 
         AND c.COLUMN_NAME  = pk.COLUMN_NAME
      WHERE t.TABLE_TYPE IN ('BASE TABLE', 'VIEW')
      ORDER BY t.TABLE_SCHEMA, t.TABLE_NAME, c.ORDINAL_POSITION
    `;

    const res = await this.executeQuery(schemaQuery);
    return this.buildSchemaInfo(res.rows as any[]);
  }

  private buildSchemaInfo(rows: any[]): SchemaInfo {
    const bySchema = new Map<string, { tables: Map<string, Table>; views: Map<string, View> }>();

    for (const r of rows) {
      const sName = r.TABLE_SCHEMA as string;
      const tName = r.TABLE_NAME as string;
      const isView = (r.TABLE_TYPE as string) === 'VIEW';

      if (!bySchema.has(sName)) bySchema.set(sName, { tables: new Map(), views: new Map() });
      const bucket = bySchema.get(sName)!;

      if (isView) {
        const vmap = bucket.views;
        if (!vmap.has(tName)) {
          vmap.set(tName, { name: tName, schema: sName, columns: [], definition: undefined });
        }
        if (r.COLUMN_NAME) {
          const col: Column = {
            name: r.COLUMN_NAME,
            dataType: r.DATA_TYPE,
            nullable: r.IS_NULLABLE === 'YES',
            defaultValue: r.COLUMN_DEFAULT ?? undefined,
            maxLength: r.CHARACTER_MAXIMUM_LENGTH ?? undefined,
            precision: r.NUMERIC_PRECISION ?? undefined,
            scale: r.NUMERIC_SCALE ?? undefined,
            isPrimaryKey: r.IS_PRIMARY_KEY === 1,
          };
          vmap.get(tName)!.columns.push(col);
        }
      } else {
        const tmap = bucket.tables;
        if (!tmap.has(tName)) {
          tmap.set(tName, { name: tName, schema: sName, columns: [], primaryKeys: [], foreignKeys: [], indexes: [] });
        }
        if (r.COLUMN_NAME) {
          const col: Column = {
            name: r.COLUMN_NAME,
            dataType: r.DATA_TYPE,
            nullable: r.IS_NULLABLE === 'YES',
            defaultValue: r.COLUMN_DEFAULT ?? undefined,
            maxLength: r.CHARACTER_MAXIMUM_LENGTH ?? undefined,
            precision: r.NUMERIC_PRECISION ?? undefined,
            scale: r.NUMERIC_SCALE ?? undefined,
            isPrimaryKey: r.IS_PRIMARY_KEY === 1,
          };
          const tbl = tmap.get(tName)!;
          tbl.columns.push(col);
          if (col.isPrimaryKey) tbl.primaryKeys.push(col.name);
        }
      }
    }

    const schemas: Schema[] = [];
    let totalTables = 0;
    let totalViews = 0;
    let totalColumns = 0;

    for (const [name, { tables, views }] of bySchema) {
      const tablesArr = Array.from(tables.values());
      const viewsArr = Array.from(views.values());
      totalTables += tablesArr.length;
      totalViews += viewsArr.length;
      totalColumns +=
        tablesArr.reduce((n, t) => n + t.columns.length, 0) +
        viewsArr.reduce((n, v) => n + v.columns.length, 0);
      schemas.push({ name, tables: tablesArr, views: viewsArr });
    }

    return { schemas, totalTables, totalViews, totalColumns };
  }

  override async validateQuery(query: string): Promise<{ valid: boolean; error?: string }> {
    try {
      await this.ensureConnected();
      const req = new Request(this.pool!);
      await req.batch('SET PARSEONLY ON;');
      try {
        await req.query(query);
        await req.batch('SET PARSEONLY OFF;');
        return { valid: true };
      } catch (err: any) {
        await req.batch('SET PARSEONLY OFF;');
        return { valid: false, error: err?.message || 'Invalid query' };
      }
    } catch (e: any) {
      return { valid: false, error: e?.message || 'Connection error during validation' };
    }
  }

  override async getSampleData(tableName: string, schemaName: string = 'dbo', limit: number = 100): Promise<QueryResult> {
    await this.ensureConnected();
    const full = `${this.escapeIdentifier(schemaName)}.${this.escapeIdentifier(tableName)}`;
    const q = `SELECT TOP (${limit}) * FROM ${full}`;
    return this.executeQuery(q);
  }

  async getConnectionInfo(): Promise<any> {
    await this.ensureConnected();
    const q = `
      SELECT 
        @@VERSION AS version,
        @@SERVERNAME AS server_name,
        DB_NAME() AS database_name,
        SUSER_NAME() AS login_name,
        @@LANGUAGE AS language,
        GETDATE() AS server_time
    `;
    const r = await this.executeQuery(q);
    return (r.rows as any[])?.[0];
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ internals â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  private async ensureConnected(): Promise<void> {
    if (!this.pool || !this.pool.connected) await this.connect();
  }

  protected override escapeIdentifier(identifier: string): string {
    return `[${String(identifier).replace(/]/g, ']]')}]`;
  }

  private createConnectionError(error: any): Error {
    const message = error instanceof Error ? error.message : 'Connection failed';
    return new Error(`Azure SQL connection error: ${message}`);
  }

  private createQueryError(error: any, query: string): Error {
    const message = error instanceof Error ? error.message : 'Query failed';
    return new Error(`Azure SQL query error: ${message} (Query: ${query.substring(0, 120)}...)`);
  }

  override getMetrics(): any {
    const p: any = this.pool as any;
    const poolStats = p?.pool ?? p;
    return {
      type: 'azure-sql',
      connected: !!this.pool?.connected,
      server: this.config.server,
      database: this.config.database,
      poolSize: poolStats?.size ?? 0,
      poolAvailable: poolStats?.available ?? 0,
      poolPending: poolStats?.pending ?? 0,
    };
  }
}

export default AzureSqlConnector;



------------------------------------------------------------
FILE: backend\data-service\src\services\connectors\base.ts
------------------------------------------------------------
import { EventEmitter } from "events";
import type { ConnectionConfig } from "../../models/Connection";
import type { ConnectionTestResult } from "../../models/DataSource";

export interface ConnectorMetrics {
  type: string;
  connected: boolean;
  totalQueries: number;
  successfulQueries: number;
  failedQueries: number;
  averageQueryTime: number;
  lastQueryAt?: Date;
  lastErrorAt?: Date;
  uptime: number;
}

export interface QueryResult {
  rows: any[];
  rowCount: number;
  columns?: any;
  executionTime?: number;
  metadata?: any;
}

export interface SchemaInfo {
  schemas: Schema[];
  totalTables: number;
  totalViews: number;
  totalColumns: number;
}

export interface Schema {
  name: string;
  tables: Table[];
  views: View[];
}

export interface Table {
  name: string;
  schema: string;
  columns: Column[];
  primaryKeys: string[];
  foreignKeys: ForeignKey[];
  indexes: Index[];
  rowCount?: number;
  sizeBytes?: number;
  lastModified?: Date;
}

export interface View {
  name: string;
  schema: string;
  columns: Column[];
  definition?: string;
}

export interface Column {
  name: string;
  dataType: string;
  nullable: boolean;
  defaultValue?: string;
  maxLength?: number;
  precision?: number;
  scale?: number;
  isPrimaryKey?: boolean;
  isForeignKey?: boolean;
  isUnique?: boolean;
  comment?: string;
}

export interface ForeignKey {
  name: string;
  column: string;
  referencedTable: string;
  referencedColumn: string;
  referencedSchema?: string;
}

export interface Index {
  name: string;
  columns: string[];
  unique: boolean;
  type: string;
  clustered?: boolean;
}

export abstract class BaseConnector<C extends ConnectionConfig = ConnectionConfig> extends EventEmitter {
  protected type: string;
  protected connectionConfig: C;
  protected metrics: ConnectorMetrics;
  protected startTime: Date;

  constructor(type: string, connectionConfig: C) {
    super();
    this.type = type;
    this.connectionConfig = connectionConfig;
    this.startTime = new Date();
    this.metrics = {
      type,
      connected: false,
      totalQueries: 0,
      successfulQueries: 0,
      failedQueries: 0,
      averageQueryTime: 0,
      uptime: 0,
    };
  }

  abstract connect(): Promise<void>;
  abstract disconnect(): Promise<void>;
  abstract testConnection(): Promise<ConnectionTestResult>;
  abstract executeQuery(query: string, params?: any[]): Promise<QueryResult>;
  abstract getSchema(): Promise<SchemaInfo>;

  // Optional lifecycle hook
  cleanup?(): Promise<void> | void;

  async validateQuery(query: string): Promise<{ valid: boolean; error?: string }> {
    try {
      await this.executeQuery(`EXPLAIN ${query}`);
      return { valid: true };
    } catch (error: any) {
      return { valid: false, error: error?.message ?? "Query validation failed" };
    }
  }

  async getTableStats(tableName: string, schemaName?: string): Promise<any> {
    return {
      tableName,
      schemaName,
      rowCount: 0,
      sizeBytes: 0,
      message: "Table statistics not available for this connector type",
    };
  }

  async getSampleData(tableName: string, schemaName?: string, limit = 100): Promise<QueryResult> {
    const full = schemaName ? `${schemaName}.${tableName}` : tableName;
    const q = `SELECT * FROM ${full} LIMIT ${limit}`;
    return this.executeQuery(q);
  }

  async getColumnDistinctValues(
    tableName: string,
    columnName: string,
    schemaName?: string,
    limit = 100
  ): Promise<any[]> {
    const full = schemaName ? `${schemaName}.${tableName}` : tableName;
    const q = `SELECT DISTINCT ${columnName} FROM ${full} LIMIT ${limit}`;
    const result = await this.executeQuery(q);
    return result.rows.map((r) => r[columnName]);
  }

  getMetrics(): ConnectorMetrics {
    return { ...this.metrics, uptime: Date.now() - this.startTime.getTime() };
  }

  protected updateQueryMetrics(executionTime: number, success: boolean): void {
    this.metrics.totalQueries++;
    if (success) {
      this.metrics.successfulQueries++;
      this.metrics.lastQueryAt = new Date();
      const totalTime =
        this.metrics.averageQueryTime * (this.metrics.successfulQueries - 1) + executionTime;
      this.metrics.averageQueryTime = totalTime / this.metrics.successfulQueries;
    } else {
      this.metrics.failedQueries++;
      this.metrics.lastErrorAt = new Date();
    }
  }

  protected async executeWithMetrics<T>(operation: () => Promise<T>): Promise<T> {
    const t0 = Date.now();
    let ok = false;
    try {
      const result = await operation();
      ok = true;
      return result;
    } finally {
      const dt = Date.now() - t0;
      this.updateQueryMetrics(dt, ok);
    }
  }

  protected emitConnectionEvent(event: "connected" | "disconnected" | "error", data?: any): void {
    this.emit(event, { connector: this.type, timestamp: new Date(), data });
  }

  async healthCheck(): Promise<{
    status: "healthy" | "unhealthy" | "degraded";
    latency?: number;
    error?: string;
    details?: any;
  }> {
    try {
      const r = await this.testConnection();
      if (r.success) {
        return {
          status: (r.responseTime ?? 0) > 5000 ? "degraded" : "healthy",
          latency: r.responseTime,
          details: r.details,
        };
      }
      return { status: "unhealthy", error: r.error, details: r.details };
    } catch (e: any) {
      return { status: "unhealthy", error: e?.message ?? "Health check failed" };
    }
  }

  getConnectionConfig(): C {
    const clone: any = { ...this.connectionConfig };
    if (clone.password) clone.password = "[REDACTED]";
    return clone as C;
  }

  updateConnectionConfig(patch: Partial<C>): void {
    this.connectionConfig = { ...this.connectionConfig, ...patch };
  }

  protected escapeIdentifier(identifier: string): string {
    return `"${String(identifier).replace(/"/g, '""')}"`;
  }
  protected escapeLiteral(literal: string): string {
    return `'${String(literal).replace(/'/g, "''")}'`;
  }

  protected parseConnectionString(cs: string): Record<string, string> {
    const out: Record<string, string> = {};
    cs.split(";").forEach((pair) => {
      const [k, v] = pair.split("=");
      if (k && v) out[k.trim().toLowerCase()] = v.trim();
    });
    return out;
  }

  async getPoolStats(): Promise<{ total: number; active: number; idle: number; waiting: number }> {
    return { total: 1, active: this.metrics.connected ? 1 : 0, idle: 0, waiting: 0 };
  }
}

export default BaseConnector;



------------------------------------------------------------
FILE: backend\data-service\src\services\connectors\factory.ts
------------------------------------------------------------
// backend/data-service/src/services/connectors/factory.ts - FIXED VERSION

import type { ConnectionConfig } from "../../models/Connection";
import type { DataSourceType } from "../../models/DataSource";
import { logger } from "../../utils/logger";
import { AzureSqlConnector } from "./azureSql";
import { BaseConnector } from "./base";

// Fix: Use generic constraint that works with union types
export interface ConnectorConstructor<TConfig extends ConnectionConfig = ConnectionConfig> {
  new (config: TConfig): BaseConnector<TConfig>;
}

/* Normalize common aliases to canonical DataSourceType values */
const normalizeType = (t: string): DataSourceType => {
  const x = (t || "").toLowerCase();
  if (x === "azure_sql" || x === "azure-sql" || x === "sqlserver" || x === "sql-server") return "mssql";
  return x as DataSourceType;
};

export class ConnectorFactory {
  private static connectors: Map<DataSourceType | string, ConnectorConstructor<any>> = new Map();
  private static instances: Map<string, BaseConnector<any>> = new Map();

  /* Register built-ins with proper type casting */
  static {
    // Fix: Use type assertion to handle the union type compatibility
    ConnectorFactory.registerConnector("mssql", AzureSqlConnector as ConnectorConstructor<any>);
    ConnectorFactory.registerConnector("azure-sql", AzureSqlConnector as ConnectorConstructor<any>);
    ConnectorFactory.registerConnector("azure_sql", AzureSqlConnector as ConnectorConstructor<any>);
  }

  static registerConnector(type: DataSourceType | string, ctor: ConnectorConstructor<any>): void {
    ConnectorFactory.connectors.set(type, ctor);
    logger.info(`Registered connector for type: ${type}`);
  }

  static createConnector(config: ConnectionConfig): BaseConnector<ConnectionConfig> {
    const type = normalizeType(config.type as string);
    const Ctor =
      ConnectorFactory.connectors.get(type) || 
      ConnectorFactory.connectors.get(config.type as string);
    
    if (!Ctor) {
      throw new Error(`No connector available for data source type: ${config.type}`);
    }
    
    try {
      const inst = new Ctor(config);
      logger.info(`Created connector instance for type: ${type}`);
      return inst;
    } catch (err: any) {
      logger.error(`Failed to create connector for ${type}:`, err);
      throw new Error(`Failed to create connector: ${err?.message || "Unknown error"}`);
    }
  }

  static async getConnector(dataSourceId: string, config: ConnectionConfig): Promise<BaseConnector<ConnectionConfig>> {
    let c = ConnectorFactory.instances.get(dataSourceId);
    if (!c) {
      c = ConnectorFactory.createConnector(config);
      ConnectorFactory.instances.set(dataSourceId, c);
      
      // Fix: Add proper event handling with type safety
      c.on("disconnected", () => {
        ConnectorFactory.instances.delete(dataSourceId);
        logger.info(`Connector removed from cache: ${dataSourceId}`);
      });
      
      c.on("error", (e) => {
        logger.error(`Connector error [${dataSourceId}]`, e);
      });
    }
    return c;
  }

  static async removeConnector(dataSourceId: string): Promise<void> {
    const c = ConnectorFactory.instances.get(dataSourceId);
    if (c) {
      try {
        // Fix: Check if cleanup method exists before calling
        if (c && typeof (c as any).cleanup === "function") {
          await (c as any).cleanup();
        }
      } catch (e) {
        logger.error(`Cleanup error for ${dataSourceId}`, e);
      } finally {
        ConnectorFactory.instances.delete(dataSourceId);
      }
    }
  }

  static async testConnection(config: ConnectionConfig): Promise<any> {
    const c = ConnectorFactory.createConnector(config);
    try {
      const result = await c.testConnection();
      await c.disconnect();
      return result;
    } catch (e) {
      try {
        await c.disconnect();
      } catch (disconnectError) {
        logger.warn("Error during connector cleanup after test failure:", disconnectError);
      }
      throw e;
    }
  }

  // Fix: Updated helper methods with better type safety
  static getAvailableTypes(): DataSourceType[] {
    const uniq = new Set<DataSourceType>();
    for (const k of ConnectorFactory.connectors.keys()) {
      const normalized = normalizeType(String(k));
      if (normalized) {
        uniq.add(normalized);
      }
    }
    return Array.from(uniq);
  }

  static isTypeSupported(type: DataSourceType | string): boolean {
    const normalized = normalizeType(String(type));
    return ConnectorFactory.connectors.has(normalized) || ConnectorFactory.connectors.has(type);
  }

  // Fix: More robust config validation with type guards
  static validateConfig(type: DataSourceType | string, config: any): string[] {
    const normalizedType = normalizeType(String(type));
    const errors: string[] = [];

    // Basic validation
    if (!config || typeof config !== 'object') {
      errors.push("Configuration must be an object");
      return errors;
    }

    switch (normalizedType) {
      case "postgresql":
      case "mysql":
      case "mssql": {
        const hasConnStr = config.connectionString && typeof config.connectionString === 'string';
        if (!hasConnStr) {
          if (!config.host || typeof config.host !== 'string') {
            errors.push("Host is required when not using connection string");
          }
          if (!config.database || typeof config.database !== 'string') {
            errors.push("Database is required when not using connection string");
          }
          if (!config.username || typeof config.username !== 'string') {
            errors.push("Username is required when not using connection string");
          }
        }
        if (config.port !== undefined && (typeof config.port !== 'number' || config.port < 1 || config.port > 65535)) {
          errors.push("Port must be a number between 1 and 65535");
        }
        break;
      }
      case "mongodb": {
        const hasConnStr = config.connectionString && typeof config.connectionString === 'string';
        const hasHost = config.host && typeof config.host === 'string';
        if (!hasConnStr && !hasHost) {
          errors.push("Connection string or host is required");
        }
        break;
      }
      case "s3": {
        if (!config.bucket || typeof config.bucket !== 'string') {
          errors.push("Bucket is required");
        }
        if (!config.region || typeof config.region !== 'string') {
          errors.push("Region is required");
        }
        if (!config.accessKeyId || typeof config.accessKeyId !== 'string') {
          errors.push("Access Key ID is required");
        }
        if (!config.secretAccessKey || typeof config.secretAccessKey !== 'string') {
          errors.push("Secret Access Key is required");
        }
        break;
      }
      case "api": {
        if (!config.baseUrl || typeof config.baseUrl !== 'string') {
          errors.push("Base URL is required");
        } else {
          try {
            new URL(config.baseUrl);
          } catch {
            errors.push("Base URL must be a valid URL");
          }
        }
        break;
      }
      default:
        // For unknown types, do basic validation
        if (config.timeout !== undefined && (typeof config.timeout !== 'number' || config.timeout <= 0)) {
          errors.push("Timeout must be a positive number");
        }
        break;
    }

    return errors;
  }

  // Rest of your existing methods remain the same
  static getConfigTemplate(type: DataSourceType | string): any {
    const normalized = normalizeType(String(type));
    switch (normalized) {
      case "postgresql":
        return { 
          host: "localhost", port: 5432, database: "", username: "", password: "", 
          ssl: false, timeout: 30000, maxConnections: 10 
        };
      case "mysql":
        return { 
          host: "localhost", port: 3306, database: "", username: "", password: "", 
          ssl: false, timeout: 30000, maxConnections: 10 
        };
      case "mssql":
        return { 
          host: "localhost", port: 1433, database: "", username: "", password: "", 
          ssl: true, timeout: 30000, maxConnections: 10 
        };
      case "mongodb":
        return { 
          connectionString: "mongodb://localhost:27017", database: "", 
          username: "", password: "", timeout: 30000 
        };
      case "s3":
        return { 
          region: "us-east-1", bucket: "", accessKeyId: "", secretAccessKey: "" 
        };
      case "api":
        return { 
          baseUrl: "https://api.example.com", apiKey: "", timeout: 30000, headers: {} 
        };
      default:
        return { timeout: 30000 };
    }
  }

  static getActiveConnectors(): Map<string, BaseConnector<any>> {
    return new Map(ConnectorFactory.instances);
  }

  static getAllMetrics(): Record<string, any> {
    const out: Record<string, any> = {};
    for (const [id, c] of ConnectorFactory.instances) {
      try {
        out[id] = (c as any).getMetrics?.() || { status: "no metrics available" };
      } catch (e: any) {
        out[id] = { error: e?.message || "Failed to get metrics" };
      }
    }
    return out;
  }

  static async healthCheckAll(): Promise<Record<string, any>> {
    const results: Record<string, any> = {};
    const checks = Array.from(ConnectorFactory.instances.entries()).map(async ([id, c]) => {
      try {
        results[id] = await c.healthCheck();
      } catch (e: any) {
        results[id] = { status: "unhealthy", error: e?.message || "Health check failed" };
      }
    });
    
    await Promise.allSettled(checks);
    return results;
  }

  static async cleanupAll(): Promise<void> {
    const cleanupPromises = Array.from(ConnectorFactory.instances.keys()).map(id => 
      ConnectorFactory.removeConnector(id)
    );
    
    await Promise.allSettled(cleanupPromises);
    ConnectorFactory.instances.clear();
    logger.info("All connectors cleaned up");
  }
}

export default ConnectorFactory;


------------------------------------------------------------
FILE: backend\data-service\src\services\DatabaseService.ts
------------------------------------------------------------
// backend/data-service/src/services/DatabaseService.ts
import { Pool, PoolClient, QueryResult } from 'pg';
import { config } from '../config/env';
import { logger, loggerUtils } from '../utils/logger';

export interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  ssl?: boolean | object;
  max?: number;
  min?: number;
  idleTimeoutMillis?: number;
  connectionTimeoutMillis?: number;
}

export interface QueryOptions { timeout?: number; retries?: number; retryDelay?: number; }
export interface TransactionOptions {
  timeout?: number;
  isolationLevel?: 'READ_UNCOMMITTED'|'READ_COMMITTED'|'REPEATABLE_READ'|'SERIALIZABLE';
}
export interface HealthCheckResult {
  status: 'healthy' | 'unhealthy';
  latency?: number;
  connections?: { total: number; idle: number; waiting: number; };
  error?: string;
  timestamp: string;
}
export interface PoolStats { total: number; idle: number; waiting: number; max: number; min: number; }
export interface Migration { id: number; name: string; sql: string; executedAt?: Date; }

export class DatabaseService {
  private pool!: Pool;
  private isInitialized = false;
  private migrations: Migration[] = [];

  constructor() {
    this.initializePool();
    this.setupMigrations();
  }

  private initializePool(): void {
    const dbConfig: DatabaseConfig = {
      host: config.database.host,
      port: config.database.port,
      database: config.database.name,
      user: config.database.user,
      password: config.database.password,
      ssl: config.database.ssl ? { rejectUnauthorized: false } : false,
      max: config.database.poolMax,
      min: config.database.poolMin,
      idleTimeoutMillis: config.database.idleTimeout,
      connectionTimeoutMillis: config.database.connectionTimeout,
    };

    this.pool = new Pool(dbConfig);

    this.pool.on('error', (err: Error) => {
      logger.error('Database pool error:', { error: err.message, stack: err.stack });
    });

    logger.info('Database pool initialized', {
      host: dbConfig.host, port: dbConfig.port, database: dbConfig.database,
      maxConnections: dbConfig.max, minConnections: dbConfig.min, ssl: !!dbConfig.ssl,
    });

    this.isInitialized = true;
  }

  /** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Migrations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  // ...imports & class skeleton unchanged...

// backend/data-service/src/services/DatabaseService.ts
private setupMigrations(): void {
  this.migrations = [
    {
      id: 0,
      name: '000_enable_pgcrypto',
      sql: `CREATE EXTENSION IF NOT EXISTS pgcrypto;`
    },
    {
      id: 1,
      name: '001_create_data_sources_table',
      sql: `
        CREATE TABLE IF NOT EXISTS data_sources (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          name VARCHAR(100) NOT NULL,
          type VARCHAR(50) NOT NULL,
          host VARCHAR(255),
          port INTEGER CHECK (port > 0 AND port <= 65535),
          database_name VARCHAR(100),
          username VARCHAR(100),
          password_encrypted TEXT,
          ssl BOOLEAN DEFAULT FALSE,
          connection_string TEXT,
          description TEXT,
          tags TEXT[] DEFAULT '{}',
          status VARCHAR(20) DEFAULT 'active',
          metadata JSONB DEFAULT '{}',
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW(),
          last_tested_at TIMESTAMPTZ,
          last_sync_at TIMESTAMPTZ
        );

        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
          NEW.updated_at = NOW();
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;

        DROP TRIGGER IF EXISTS update_data_sources_updated_at ON data_sources;
        CREATE TRIGGER update_data_sources_updated_at
          BEFORE UPDATE ON data_sources
          FOR EACH ROW
          EXECUTE FUNCTION update_updated_at_column();

        CREATE INDEX IF NOT EXISTS idx_data_sources_type ON data_sources(type);
        CREATE INDEX IF NOT EXISTS idx_data_sources_status ON data_sources(status);
        CREATE INDEX IF NOT EXISTS idx_data_sources_name ON data_sources(name);
        CREATE INDEX IF NOT EXISTS idx_data_sources_tags ON data_sources USING GIN(tags);
      `
    },
    {
      id: 6,
      name: '006_align_data_sources_schema',
      sql: `
        ALTER TABLE data_sources
          ADD COLUMN IF NOT EXISTS connection_config JSONB DEFAULT '{}'::jsonb,
          ADD COLUMN IF NOT EXISTS created_by VARCHAR(100),
          ADD COLUMN IF NOT EXISTS updated_by VARCHAR(100),
          ADD COLUMN IF NOT EXISTS last_error TEXT,
          ADD COLUMN IF NOT EXISTS public_id VARCHAR(100),
          ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ,
          ADD COLUMN IF NOT EXISTS last_test_at TIMESTAMPTZ;  -- tolerate new name

        -- Backfill new last_test_at from legacy last_tested_at if present
        UPDATE data_sources
          SET last_test_at = COALESCE(last_test_at, last_tested_at)
          WHERE last_tested_at IS NOT NULL;

        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE schemaname = 'public' AND indexname = 'uq_data_sources_public_id'
          ) THEN
            CREATE UNIQUE INDEX uq_data_sources_public_id
              ON data_sources ((public_id)) WHERE public_id IS NOT NULL;
          END IF;
        END $$;

        CREATE INDEX IF NOT EXISTS idx_data_sources_updated_at ON data_sources(updated_at);

        DO $$
        BEGIN
          IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'data_sources_type_check' AND conrelid = 'data_sources'::regclass) THEN
            ALTER TABLE data_sources DROP CONSTRAINT data_sources_type_check;
          END IF;
          IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'data_sources_status_check' AND conrelid = 'data_sources'::regclass) THEN
            ALTER TABLE data_sources DROP CONSTRAINT data_sources_status_check;
          END IF;
        END $$;

        ALTER TABLE data_sources
          ADD CONSTRAINT chk_data_sources_type CHECK (type IN (
            'postgresql','mysql','mssql','oracle','mongodb','redis',
            's3','azure-blob','gcs','snowflake','bigquery','redshift',
            'databricks','api','file','kafka','elasticsearch'
          ));

        ALTER TABLE data_sources
          ADD CONSTRAINT chk_data_sources_status CHECK (status IN (
            'active','inactive','pending','error','testing',
            'connected','disconnected','warning','syncing'
          ));
      `
    }
  ];
}



  /** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Query helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  public async query(text: string, params?: any[], options: QueryOptions = {}): Promise<QueryResult> {
    const { timeout = 30000, retries = 0, retryDelay = 1000 } = options;
    const start = Date.now();
    const queryId = Math.random().toString(36).substring(7);
    let lastError: Error;

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const result = await this.pool.query({ text, values: params });
        const duration = Date.now() - start;
        loggerUtils.logDbOperation('select', 'general', duration, true);
        return result;
      } catch (err) {
        lastError = err as Error;
        if (attempt === retries) {
          const duration = Date.now() - start;
          loggerUtils.logDbOperation('select', 'general', duration, false);
          throw lastError;
        }
        await new Promise(r => setTimeout(r, retryDelay * (attempt + 1)));
      }
    }
    throw lastError!;
  }

  public async transaction<T>(callback: (client: PoolClient) => Promise<T>, options: TransactionOptions = {}): Promise<T> {
    const { timeout = 30000, isolationLevel } = options;
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      if (isolationLevel) await client.query(`SET TRANSACTION ISOLATION LEVEL ${isolationLevel}`);
      const result = await Promise.race([
        callback(client),
        new Promise<never>((_, reject) => setTimeout(() => reject(new Error(`Transaction timeout after ${timeout}ms`)), timeout)),
      ]);
      await client.query('COMMIT');
      return result;
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  }

  public async healthCheck(): Promise<HealthCheckResult> {
    const started = Date.now();
    try {
      await this.pool.query('SELECT 1');
      return {
        status: 'healthy',
        latency: Date.now() - started,
        connections: {
          total: (this.pool as any).totalCount ?? 0,
          idle: (this.pool as any).idleCount ?? 0,
          waiting: (this.pool as any).waitingCount ?? 0,
        },
        timestamp: new Date().toISOString(),
      };
    } catch (e: any) {
      return {
        status: 'unhealthy',
        latency: Date.now() - started,
        error: e?.message || String(e),
        timestamp: new Date().toISOString(),
      };
    }
  }

  public getPoolStats(): PoolStats {
    // @ts-ignore
    return {
      total: this.pool.totalCount ?? 0,
      idle: this.pool.idleCount ?? 0,
      waiting: this.pool.waitingCount ?? 0,
      max: config.database.poolMax,
      min: config.database.poolMin,
    };
  }

  public async runMigrations(): Promise<void> {
    logger.info('Running database migrations...');
    await this.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      )
    `);

    for (const m of this.migrations) {
      const seen = await this.query('SELECT 1 FROM migrations WHERE name = $1', [m.name]);
      if (seen.rowCount) continue;

      logger.info(`Running migration: ${m.name}`);
      await this.transaction(async (client) => {
        await client.query(m.sql);
        await client.query('INSERT INTO migrations (name) VALUES ($1)', [m.name]);
      });
      logger.info(`Migration completed: ${m.name}`);
    }
    logger.info('All migrations completed.');
  }

  public async close(): Promise<void> {
    await this.pool.end();
    this.isInitialized = false;
  }

  public isReady(): boolean { return this.isInitialized; }
}



------------------------------------------------------------
FILE: backend\data-service\src\services\DataSourceService.ts
------------------------------------------------------------
// backend/data-service/src/services/DataSourceService.ts
import { randomUUID } from 'node:crypto';
import {
  ConnectionConfig,
  DataSource,
  DataSourceFilters,
  DataSourceStatus,
  DataSourceType,
} from '../models/DataSource';
import { logger } from '../utils/logger';
import { DatabaseService } from './DatabaseService';

export interface PaginatedDataSources {
  dataSources: DataSource[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DataSourceListOptions {
  page: number;
  limit: number;
  filters: DataSourceFilters;
  sortBy?: 'updatedAt' | 'createdAt' | 'name' | 'status' | 'type';
  sortOrder?: 'asc' | 'desc';
}

export interface HealthSummary {
  total: number;
  healthy: number;
  warning: number;
  error: number;
  lastUpdated: Date;
}

export interface SchemaInfo {
  tables: TableInfo[];
  views: ViewInfo[];
  totalTables: number;
  totalColumns: number;
  estimatedSize: string;
}

export interface TableInfo {
  name: string;
  schema?: string;
  rowCount?: number;
  columns: ColumnInfo[];
  indexes: IndexInfo[];
  constraints: ConstraintInfo[];
}

export interface ColumnInfo {
  name: string;
  type: string;
  nullable: boolean;
  primaryKey: boolean;
  foreignKey?: { table: string; column: string };
  defaultValue?: string;
}

export interface ViewInfo { name: string; schema?: string; definition: string; }
export interface IndexInfo { name: string; columns: string[]; unique: boolean; type: string; }

export interface ConstraintInfo {
  name: string;
  type: 'PRIMARY_KEY' | 'FOREIGN_KEY' | 'UNIQUE' | 'CHECK';
  columns: string[];
  referencedTable?: string;
  referencedColumns?: string[];
}

export interface SyncResult {
  syncId: string;
  status: 'started' | 'completed' | 'failed';
  tablesScanned: number;
  newTables: number;
  updatedTables: number;
  errors: string[];
  startedAt: Date;
  completedAt?: Date;
}

const SORT_MAP: Record<NonNullable<DataSourceListOptions['sortBy']>, string> = {
  updatedAt: 'updated_at',
  createdAt: 'created_at',
  name: 'name',
  status: 'status',
  type: 'type',
};

export class DataSourceService {
  private db = new DatabaseService();

  private makePublicId(): string {
    return `ds_${Date.now()}_${randomUUID().slice(0, 8)}`;
  }

  private coerceJSON<T>(val: any, fallback: T): T {
    if (val === null || val === undefined) return fallback;
    if (typeof val === 'string') {
      try { return JSON.parse(val) as T; } catch { return fallback; }
    }
    return (typeof val === 'object') ? (val as T) : fallback;
  }

  private coerceStringArray(val: any): string[] {
    if (Array.isArray(val)) return val.map(String);
    if (typeof val === 'string') {
      try {
        const parsed = JSON.parse(val);
        if (Array.isArray(parsed)) return parsed.map(String);
      } catch {
        if (/^\{.*\}$/.test(val)) {
          return val
            .slice(1, -1)
            .split(',')
            .map((s) => s.replace(/^"(.*)"$/, '$1'))
            .filter(Boolean);
        }
      }
    }
    return [];
  }

  private toConnectionConfig(raw: any, fallbackType?: DataSourceType): ConnectionConfig {
    try {
      const obj = raw == null ? {} : (typeof raw === 'string' ? JSON.parse(raw) : raw);
      if (obj && typeof obj === 'object' && typeof obj.type === 'string') {
        return obj as ConnectionConfig;
      }
    } catch { /* ignore */ }
    return { type: (fallbackType as any) ?? 'api' } as ConnectionConfig;
  }

  private mapRowToDataSource(row: any): DataSource {
    return {
      id: row.id,
      name: row.name,
      description: row.description ?? null,
      type: row.type,
      status: row.status,
      connectionConfig: this.toConnectionConfig(row.connection_config, row.type),
      tags: this.coerceStringArray(row.tags),
      metadata: this.coerceJSON(row.metadata, {}),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      createdBy: row.created_by ?? null,
      updatedBy: row.updated_by ?? null,
      lastTestAt: row.last_test_at ?? row.last_tested_at ?? null,
      lastSyncAt: row.last_sync_at ?? null,
      lastError: row.last_error ?? null,
      publicId: row.public_id ?? null,
    } as DataSource;
  }

  async getAllDataSources(options: DataSourceListOptions): Promise<PaginatedDataSources> {
    try {
      const { page, limit, filters, sortBy = 'updatedAt', sortOrder = 'desc' } = options;
      const offset = (page - 1) * limit;

      let where = 'WHERE deleted_at IS NULL';
      const params: any[] = [];
      let i = 1;

      if (filters.status) { where += ` AND status = $${i++}`; params.push(filters.status); }
      if (filters.type)   { where += ` AND type = $${i++}`; params.push(filters.type); }
      if (filters.createdBy) { where += ` AND created_by = $${i++}`; params.push(filters.createdBy); }
      if (filters.search) {
        where += ` AND (name ILIKE $${i} OR description ILIKE $${i})`;
        params.push(`%${filters.search}%`); i++;
      }

      const countSQL = `SELECT COUNT(*)::int AS total FROM data_sources ${where}`;
      const { rows: countRows } = await this.db.query(countSQL, params);
      const total = countRows[0]?.total ?? 0;

      const orderBy = SORT_MAP[sortBy] ?? 'updated_at';
      const orderDir = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';

      const dataSQL = `
        SELECT
          id, name, description, type, status,
          connection_config, tags, metadata,
          created_at, updated_at, created_by, updated_by,
          COALESCE(last_test_at, last_tested_at) AS last_test_at,
          last_sync_at, last_error, public_id
        FROM data_sources
        ${where}
        ORDER BY ${orderBy} ${orderDir}
        LIMIT $${i++} OFFSET $${i++}
      `;
      const { rows } = await this.db.query(dataSQL, [...params, limit, offset]);
      const dataSources = rows.map((r) => this.mapRowToDataSource(r));

      return { dataSources, total, page, limit, totalPages: Math.ceil(total / limit) };
    } catch (error) {
      logger.error('DataSourceService.getAllDataSources failed:', error);
      throw error;
    }
  }

  async getDataSourceById(id: string): Promise<DataSource | null> {
    try {
      const sql = `
        SELECT
          id, name, description, type, status,
          connection_config, tags, metadata,
          created_at, updated_at, created_by, updated_by,
          COALESCE(last_test_at, last_tested_at) AS last_test_at,
          last_sync_at, last_error, public_id
        FROM data_sources
        WHERE id = $1 AND deleted_at IS NULL
      `;
      const { rows } = await this.db.query(sql, [id]);
      if (rows.length === 0) return null;
      return this.mapRowToDataSource(rows[0]);
    } catch (error) {
      logger.error('DataSourceService.getDataSourceById failed:', error);
      throw error;
    }
  }

  async createDataSource(data: Partial<DataSource>): Promise<DataSource> {
    try {
      const now = new Date();
      const publicId = this.makePublicId();

      const connectionCfg: ConnectionConfig =
        data.connectionConfig && typeof (data.connectionConfig as any).type === 'string'
          ? (data.connectionConfig as ConnectionConfig)
          : this.toConnectionConfig(null, data.type as DataSourceType);

      const sql = `
        INSERT INTO data_sources (
          name, description, type, status,
          connection_config, tags, metadata,
          created_at, updated_at, created_by, public_id,
          last_test_at, last_sync_at, last_error
        )
        VALUES (
          $1, $2, $3, $4,
          $5::jsonb, $6::text[], $7::jsonb,
          $8, $9, $10, $11,
          $12, $13, $14
        )
        RETURNING
          id, name, description, type, status,
          connection_config, tags, metadata,
          created_at, updated_at, created_by, updated_by,
          COALESCE(last_test_at, last_tested_at) AS last_test_at,
          last_sync_at, last_error, public_id
      `;

      const params: any[] = [
        data.name!,
        data.description ?? null,
        data.type!,
        data.status ?? ('pending' as DataSourceStatus),
        JSON.stringify(connectionCfg),
        Array.isArray(data.tags) ? data.tags : [],
        JSON.stringify(data.metadata ?? {}),
        now,
        now,
        data.createdBy ?? null,
        publicId,
        data.lastTestAt ?? null,
        data.lastSyncAt ?? null,
        data.lastError ?? null,
      ];

      const { rows } = await this.db.query(sql, params);
      return this.mapRowToDataSource(rows[0]);
    } catch (error) {
      logger.error('DataSourceService.createDataSource failed:', error);
      throw error;
    }
  }

  async updateDataSource(id: string, patch: Partial<DataSource>): Promise<DataSource | null> {
    try {
      const existing = await this.getDataSourceById(id);
      if (!existing) return null;

      const sets: string[] = [];
      const params: any[] = [];
      let i = 1;
      const push = (frag: string, val: any) => { sets.push(frag); params.push(val); };

      if (patch.name !== undefined)        push(`name = $${i++}`, patch.name);
      if (patch.description !== undefined) push(`description = $${i++}`, patch.description);
      if (patch.type !== undefined)        push(`type = $${i++}`, patch.type);
      if (patch.status !== undefined)      push(`status = $${i++}`, patch.status);
      if (patch.connectionConfig !== undefined) {
        const cfg = this.toConnectionConfig(patch.connectionConfig, (patch.type as any) ?? existing.type);
        push(`connection_config = $${i++}::jsonb`, JSON.stringify(cfg));
      }
      if (patch.tags !== undefined)        push(`tags = $${i++}::text[]`, Array.isArray(patch.tags) ? patch.tags : []);
      if (patch.metadata !== undefined)    push(`metadata = $${i++}::jsonb`, JSON.stringify(patch.metadata ?? {}));
      if (patch.lastTestAt !== undefined)  push(`last_test_at = $${i++}`, patch.lastTestAt);
      if (patch.lastSyncAt !== undefined)  push(`last_sync_at = $${i++}`, patch.lastSyncAt);
      if (patch.lastError !== undefined)   push(`last_error = $${i++}`, patch.lastError);
      if (patch.updatedBy !== undefined)   push(`updated_by = $${i++}`, patch.updatedBy ?? null);

      push(`updated_at = $${i++}`, new Date());
      params.push(id);

      const sql = `
        UPDATE data_sources
        SET ${sets.join(', ')}
        WHERE id = $${i} AND deleted_at IS NULL
        RETURNING
          id, name, description, type, status,
          connection_config, tags, metadata,
          created_at, updated_at, created_by, updated_by,
          COALESCE(last_test_at, last_tested_at) AS last_test_at,
          last_sync_at, last_error, public_id
      `;
      const { rows } = await this.db.query(sql, params);
      if (rows.length === 0) return null;
      return this.mapRowToDataSource(rows[0]);
    } catch (error) {
      logger.error('DataSourceService.updateDataSource failed:', error);
      throw error;
    }
  }

  async deleteDataSource(id: string): Promise<boolean> {
    try {
      const sql = `UPDATE data_sources SET deleted_at = $1 WHERE id = $2 AND deleted_at IS NULL`;
      const { rowCount } = await this.db.query(sql, [new Date(), id]);
      return (rowCount ?? 0) > 0;
    } catch (error) {
      logger.error('DataSourceService.deleteDataSource failed:', error);
      throw error;
    }
  }

  async getHealthSummary(): Promise<HealthSummary> {
    try {
      const sql = `
        SELECT
          COUNT(*)::int AS total,
          COUNT(CASE WHEN status IN ('active','connected') THEN 1 END)::int AS healthy,
          COUNT(CASE WHEN status IN ('warning','pending','testing','syncing') THEN 1 END)::int AS warning,
          COUNT(CASE WHEN status IN ('error','inactive','disconnected') THEN 1 END)::int AS error
        FROM data_sources
        WHERE deleted_at IS NULL
      `;
      const { rows } = await this.db.query(sql);
      const row = rows[0] || { total: 0, healthy: 0, warning: 0, error: 0 };
      return { ...row, lastUpdated: new Date() } as HealthSummary;
    } catch (error) {
      logger.error('DataSourceService.getHealthSummary failed:', error);
      throw error;
    }
  }

  async getDataSourceSchema(_id: string): Promise<SchemaInfo> {
    return {
      tables: [{
        name: 'users',
        schema: 'public',
        rowCount: 10000,
        columns: [
          { name: 'id', type: 'bigint', nullable: false, primaryKey: true },
          { name: 'email', type: 'varchar', nullable: false, primaryKey: false },
          { name: 'created_at', type: 'timestamp', nullable: false, primaryKey: false },
        ],
        indexes: [
          { name: 'users_pkey', columns: ['id'], unique: true, type: 'btree' },
          { name: 'users_email_idx', columns: ['email'], unique: true, type: 'btree' },
        ],
        constraints: [{ name: 'users_pkey', type: 'PRIMARY_KEY', columns: ['id'] }],
      }],
      views: [],
      totalTables: 1,
      totalColumns: 3,
      estimatedSize: '125MB',
    };
    // Replace with real connector inspection per type/id.
  }

  async syncDataSource(id: string, _options: { force?: boolean } = {}): Promise<SyncResult> {
    const syncId = `sync_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
    await this.updateDataSource(id, { lastSyncAt: new Date(), status: 'connected' as any });
    return {
      syncId,
      status: 'completed',
      tablesScanned: 15,
      newTables: 2,
      updatedTables: 3,
      errors: [],
      startedAt: new Date(),
      completedAt: new Date(),
    };
  }
}



------------------------------------------------------------
FILE: backend\data-service\src\utils\logger.ts
------------------------------------------------------------
// backend/data-service/src/utils/logger.ts
import fs from 'fs';
import path from 'path';
import winston from 'winston';
import { env } from '../config/env';

function bool(val: any, def = true) {
  if (val === undefined || val === null) return def;
  const s = String(val).toLowerCase();
  return s === '1' || s === 'true' || s === 'yes' || s === 'on';
}

const LOG_DIR = process.env.LOG_DIR || path.join(process.cwd(), 'logs'); // default ./logs
const LOG_TO_FILES = bool(process.env.LOG_TO_FILES, true);
const LOG_LEVEL = env.LOG_LEVEL || process.env.LOG_LEVEL || 'info';

function ensureWritable(dir: string): boolean {
  try {
    fs.mkdirSync(dir, { recursive: true });
    const testFile = path.join(dir, `.writable-${Date.now()}`);
    fs.writeFileSync(testFile, 'ok');
    fs.unlinkSync(testFile);
    return true;
  } catch {
    return false;
  }
}

const canWriteFiles = LOG_TO_FILES && ensureWritable(LOG_DIR);

// common formats
const human = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)
);

const jsonFmt = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// base transports: always console
const baseTransports: winston.transport[] = [
  new winston.transports.Console({ level: LOG_LEVEL, format: human }),
];

// add file transports only if writable
if (canWriteFiles) {
  baseTransports.push(
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'combined.log'),
      level: LOG_LEVEL,
      format: jsonFmt,
      maxsize: 10 * 1024 * 1024,
      maxFiles: 5,
      tailable: true,
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'error.log'),
      level: 'error',
      format: jsonFmt,
      maxsize: 10 * 1024 * 1024,
      maxFiles: 3,
      tailable: true,
    })
  );
} else {
  // visible, but non-fatal notice
  // eslint-disable-next-line no-console
  console.warn(`[logger] File logging disabled. LOG_DIR=${LOG_DIR} not writable. Using console only.`);
}

export const logger = winston.createLogger({
  level: LOG_LEVEL,
  format: jsonFmt,
  transports: baseTransports,
  exitOnError: false,
});

export const httpLogger = winston.createLogger({
  level: 'http',
  format: human,
  transports: canWriteFiles
    ? [
        new winston.transports.Console({ level: 'http', format: human }),
        new winston.transports.File({
          filename: path.join(LOG_DIR, 'http.log'),
          level: 'http',
          format: jsonFmt,
        }),
      ]
    : [new winston.transports.Console({ level: 'http', format: human })],
});

export const performanceLogger = winston.createLogger({
  level: 'info',
  format: jsonFmt,
  transports: canWriteFiles
    ? [new winston.transports.File({ filename: path.join(LOG_DIR, 'performance.log'), format: jsonFmt })]
    : [new winston.transports.Console({ level: 'info', format: human })],
});

export const securityLogger = winston.createLogger({
  level: 'warn',
  format: jsonFmt,
  transports: canWriteFiles
    ? [new winston.transports.File({ filename: path.join(LOG_DIR, 'security.log'), format: jsonFmt })]
    : [new winston.transports.Console({ level: 'warn', format: human })],
});

// Structured helpers (unchanged API, but now safe)
export const loggerUtils = {
  logRequest: (req: any, res: any, duration: number) => {
    httpLogger.http(`${req.method} ${req.url} - ${res.statusCode} - ${duration}ms`);
  },
  logDbOperation: (operation: string, table: string, duration: number, success: boolean) => {
    performanceLogger.info({ type: 'database', operation, table, duration, success, ts: new Date().toISOString() });
  },
  logAuth: (event: string, userId?: string, ip?: string, userAgent?: string) => {
    securityLogger.warn({ type: 'authentication', event, userId, ip, userAgent, ts: new Date().toISOString() });
  },
  logApiCall: (service: string, endpoint: string, method: string, duration: number, statusCode: number) => {
    performanceLogger.info({ type: 'external_api', service, endpoint, method, duration, statusCode, ts: new Date().toISOString() });
  },
  logDataSource: (operation: string, dataSourceId: string, status: string, details?: any) => {
    logger.info({ type: 'data_source', operation, dataSourceId, status, details, ts: new Date().toISOString() });
  },
  logConnectionTest: (dataSourceId: string, type: string, success: boolean, duration: number, error?: string) => {
    logger.info({ type: 'connection_test', dataSourceId, connectionType: type, success, duration, error, ts: new Date().toISOString() });
  },
  logError: (error: Error, context?: any) => {
    logger.error({ message: error.message, stack: error.stack, context, ts: new Date().toISOString() });
  },
};

// Crash guards (optional)
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception', { message: error.message, stack: error.stack });
  // Donâ€™t exit here; let orchestrator handle restarts based on health checks.
});
process.on('unhandledRejection', (reason: any, promise) => {
  logger.error('Unhandled Rejection', { reason: reason?.message || String(reason), promise: String(promise) });
});



------------------------------------------------------------
FILE: backend\data-service\src\utils\normalizeType.ts
------------------------------------------------------------
// Normalize external aliases to canonical internal types
export type KnownType =
  | 'postgres' | 'postgresql' | 'mysql' | 'mssql' | 'mongodb' | 'redis'
  | 'snowflake' | 'bigquery' | 'redshift' | 'databricks' | 's3' | 'azure-blob'
  | 'gcs' | 'kafka' | 'api' | 'file' | 'ftp' | 'elasticsearch' | 'oracle';

export function normalizeDataSourceType(t?: string): KnownType | undefined {
  if (!t) return undefined;
  const lower = t.toLowerCase();
  switch (lower) {
    case 'postgres': return 'postgresql';
    default: return lower as KnownType;
  }
}



------------------------------------------------------------
FILE: backend\data-service\src\utils\pagination.ts
------------------------------------------------------------
export type PageQuery = { page?: any; pageSize?: any; sort?: any; dir?: any };

export function pageParams(q: PageQuery, allowedSort: string[] = ['created_at']) {
  const page = Math.max(1, Number(q.page) || 1);
  const pageSize = Math.min(100, Math.max(1, Number(q.pageSize) || 20));
  const sort = allowedSort.includes(String(q.sort || '')) ? String(q.sort) : allowedSort[0];
  const dir = (String(q.dir).toLowerCase() === 'desc' ? 'desc' : 'asc') as 'asc'|'desc';
  const offset = (page - 1) * pageSize;
  return { page, pageSize, sort, dir, offset };
}



====================================================================================================
  AI SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\ai-service\src\app.ts
------------------------------------------------------------
// src/app.ts
import compression from 'compression';
import cors from 'cors';
import express, { Application, NextFunction, Request, RequestHandler, Response } from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

class App {
  public app: Application;

  constructor() {
    this.app = express();
    console.log('ðŸ”„ Creating Express app...');
    this.initializeMiddlewares();
    console.log('âœ… Express app created');
    this.initializeRoutes();
    console.log('ðŸ”„ Initializing basic middlewares...');
    this.initializeErrorHandling();
    console.log('âœ… Basic middlewares initialized');
  }

  private initializeMiddlewares(): void {
    // Security middleware
    this.app.use(helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
        },
      },
      crossOriginEmbedderPolicy: false
    }) as RequestHandler);

    // CORS configuration
    const corsOptions = {
      origin: process.env.NODE_ENV === 'production' 
        ? process.env.CORS_ORIGINS?.split(',') || ['https://your-frontend-domain.com']
        : ['http://localhost:3000', 'http://127.0.0.1:3000', 'http://localhost:5173'],
      credentials: true,
      optionsSuccessStatus: 200
    };
    this.app.use(cors(corsOptions) as RequestHandler);

    // Compression
    this.app.use(compression() as RequestHandler);

    // Body parsing
    this.app.use(express.json({ limit: '10mb' }) as RequestHandler);
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }) as RequestHandler);

    // Logging
    const morganFormat = process.env.NODE_ENV === 'production' ? 'combined' : 'dev';
    this.app.use(morgan(morganFormat) as RequestHandler);

    // Request ID middleware
    this.app.use((req: Request, _res: Response, next: NextFunction) => {
      (req as any).id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      next();
    });

    // Security headers
    this.app.use((_req: Request, res: Response, next: NextFunction) => {
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
      res.removeHeader('X-Powered-By');
      next();
    });
  }

  private initializeRoutes(): void {
    console.log('ðŸ”„ Initializing basic routes...');
    
    // Health check (before any middleware that might block it)
    this.app.get('/health', (_req: Request, res: Response) => {
      const memoryUsage = process.memoryUsage();
      res.status(200).json({
        status: 'healthy',
        service: 'ai-service',
        timestamp: new Date().toISOString(),
        version: process.env.APP_VERSION || '1.0.0',
        uptime: Math.floor(process.uptime()),
        environment: process.env.NODE_ENV || 'development',
        memory: {
          used: Math.round(memoryUsage.heapUsed / 1024 / 1024),
          total: Math.round(memoryUsage.heapTotal / 1024 / 1024),
          usage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100)
        }
      });
    });

    // Root endpoint
    this.app.get('/', (_req: Request, res: Response) => {
      res.status(200).json({
        message: 'CWIC AI Service',
        version: process.env.APP_VERSION || '1.0.0',
        status: 'running',
        endpoints: {
          health: '/health',
          api: '/api',
          docs: '/api/docs'
        },
        timestamp: new Date().toISOString()
      });
    });

    // API documentation endpoint
    this.app.get('/api/docs', (_req: Request, res: Response) => {
      res.status(200).json({
        service: 'CWIC AI Service',
        version: process.env.APP_VERSION || '1.0.0',
        description: 'AI-powered data governance and discovery service',
        endpoints: {
          discovery: {
            'POST /api/discovery': 'Start data discovery session',
            'GET /api/discovery/:sessionId': 'Get discovery status',
            'POST /api/discovery/query': 'Natural language queries',
            'POST /api/discovery/quality-rules': 'Generate quality rules'
          },
          analysis: {
            'POST /api/analysis/schema': 'Analyze database schema',
            'POST /api/analysis/quality': 'Data quality analysis'
          },
          health: {
            'GET /health': 'Service health check',
            'GET /health/ready': 'Readiness probe',
            'GET /health/live': 'Liveness probe'
          }
        }
      });
    });

    // API status endpoint (fallback)
    this.app.get('/api/status', (_req: Request, res: Response) => {
      res.status(200).json({
        status: 'AI Service API Ready',
        timestamp: new Date().toISOString(),
        routes: 'Basic routes loaded'
      });
    });

    // Try to load API routes (gracefully handle if not available)
   try {
  // IMPORTANT: prefer require here because ts-node is already running with tsconfig-paths/register
  // If this throws, you'll see the exact error below.
    const routes = require('./routes');
    this.app.use('/api', routes.default || routes);
    console.log('âœ… API routes loaded successfully');
  } catch (routeError: any) {
    console.error('âŒ Failed to load API routes:', {
      message: routeError?.message,
      stack: routeError?.stack,
    });

    // Fallback API route (keep this so app still runs)
    this.app.use('/api', (_req: Request, res: Response) => {
      res.status(503).json({
        error: 'API routes failed to load',
        message: routeError?.message || 'Service is starting up',
        retry: 'Fix the routes import error shown in server logs',
      });
    });
  }

    console.log('âœ… Basic routes initialized');
  }

  private initializeErrorHandling(): void {
    // 404 handler
    this.app.use((_req: Request, res: Response) => {
      res.status(404).json({
        success: false,
        error: {
          code: 'NOT_FOUND',
          message: 'The requested resource was not found',
          path: _req.path
        },
        timestamp: new Date().toISOString()
      });
    });

    // Global error handler
    this.app.use((error: unknown, _req: Request, res: Response, _next: NextFunction) => {
      // Type guard to check if error is an Error object
      const isError = error instanceof Error;
      const errorMessage = isError ? error.message : 'Unknown error occurred';
      const errorStack = isError ? error.stack : undefined;

      // Log error safely
      if (typeof console !== 'undefined') {
        console.error('âŒ Application Error:', {
          message: errorMessage,
          stack: errorStack,
          url: _req.url,
          method: _req.method
        });
      }

      // Determine status code
      let statusCode = 500;
      if (isError && 'statusCode' in error) {
        statusCode = (error as any).statusCode || 500;
      }

      // Send error response
      const response: any = {
        success: false,
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: process.env.NODE_ENV === 'development' 
            ? errorMessage 
            : 'An internal server error occurred'
        },
        timestamp: new Date().toISOString()
      };

      // Include stack trace in development
      if (process.env.NODE_ENV === 'development' && errorStack) {
        response.error.stack = errorStack;
      }

      if (!res.headersSent) {
        res.status(statusCode).json(response);
      }
    });
  }

  public getApp(): Application {
    return this.app;
  }

  public async shutdown(): Promise<void> {
    console.log('ðŸ”„ Shutting down application...');
    // Add cleanup logic here if needed
    console.log('âœ… Application shutdown complete');
  }
}

export default App;


------------------------------------------------------------
FILE: backend\ai-service\src\config\database.ts
------------------------------------------------------------
import { logger } from '@utils/logger';
import { Pool } from 'pg';

class DatabaseConfig {
  private pool: Pool | null = null;

  constructor() {
    this.initializePool();
  }

  private initializePool(): void {
    try {
      this.pool = new Pool({
        connectionString: process.env.DATABASE_URL,
        min: parseInt(process.env.DATABASE_POOL_MIN || '2'),
        max: parseInt(process.env.DATABASE_POOL_MAX || '10'),
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000,
        ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
      });

      // Handle pool errors
      this.pool.on('error', (err) => {
        logger.error('Database pool error:', err);
      });

      // Handle client connection errors
      this.pool.on('connect', () => {
        logger.debug('New database client connected');
      });

    } catch (error) {
      logger.error('Failed to initialize database pool:', error);
      throw error;
    }
  }

  public getPool(): Pool {
    if (!this.pool) {
      throw new Error('Database pool not initialized');
    }
    return this.pool;
  }

  public async query(text: string, params?: any[]): Promise<any> {
    const client = await this.getPool().connect();
    try {
      const start = Date.now();
      const result = await client.query(text, params);
      const duration = Date.now() - start;
      
      logger.debug('Query executed', {
        query: text,
        duration: `${duration}ms`,
        rows: result.rowCount
      });
      
      return result;
    } catch (error) {
      logger.error('Database query error:', { query: text, error });
      throw error;
    } finally {
      client.release();
    }
  }

  public async transaction(callback: (client: any) => Promise<any>): Promise<any> {
    const client = await this.getPool().connect();
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      logger.error('Transaction error:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  public async close(): Promise<void> {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
      logger.info('Database pool closed');
    }
  }
}

export const db = new DatabaseConfig();

export async function connectDatabase(): Promise<void> {
  try {
    await db.query('SELECT 1');
    logger.info('Database connection verified');
  } catch (error) {
    logger.error('Database connection failed:', error);
    throw error;
  }
}


------------------------------------------------------------
FILE: backend\ai-service\src\config\openai.ts
------------------------------------------------------------
// src/config/openai.ts
import { logger } from '@utils/logger';
import OpenAI from 'openai';

type ChatRole = 'system' | 'user' | 'assistant';

export interface ChatMessage {
  role: ChatRole;
  content: string;
}

export interface ChatArgs {
  model?: string;
  messages: ChatMessage[];
  max_tokens?: number;
  temperature?: number;
  response_format?: { type: 'json_object' | 'text' };
}

export interface ChatResponse {
  choices: Array<{ message: { content: string } }>;
}

class OpenAIAdapter {
  private client: OpenAI | null = null;
  private enabled = false;

  constructor() {
    const apiKey = process.env.OPENAI_API_KEY?.trim();
    if (apiKey) {
      try {
        this.client = new OpenAI({ apiKey });
        this.enabled = true;
        logger.info('OpenAI client initialized');
      } catch (err) {
        this.client = null;
        this.enabled = false;
        logger.error('Failed to initialize OpenAI client (using stub):', err as any);
      }
    } else {
      logger.warn('OPENAI_API_KEY not set. Using stub OpenAI client.');
      this.enabled = false;
    }
  }

  public isAvailable(): boolean {
    return this.enabled && !!this.client;
  }

  /**
   * Mirrors the shape your AIService expects:
   * await openai.createChatCompletion({...})
   * -> returns { choices: [{ message: { content: string } }] }
   */
  public async createChatCompletion(args: ChatArgs): Promise<ChatResponse> {
    // Real client path
    if (this.isAvailable() && this.client) {
      const model = args.model || process.env.OPENAI_MODEL || 'gpt-4o-mini';
      const res = await this.client.chat.completions.create({
        model,
        messages: args.messages,
        max_tokens: args.max_tokens,
        temperature: args.temperature,
        // The SDK accepts response_format on chat.completions
        response_format: args.response_format as any,
      });

      // Conform to your expected return type
      return {
        choices: [
          {
            message: {
              content: res.choices?.[0]?.message?.content ?? '',
            },
          },
        ],
      };
    }

    // Stubbed fallback (no API key): return a JSON-ish payload so your services can parse it.
    const stubJson = JSON.stringify({
      // field discovery defaults
      fields: [],
      recommendations: { governance: [], quality: [], compliance: [] },
      confidence: 0.5,
      // nlq defaults
      sql: 'SELECT 1;',
      explanation: 'OpenAI disabled; returning stubbed content.',
      tables: [],
      fieldsUsed: [],
      warnings: ['OpenAI disabled (stub)'],
    });

    logger.warn('OpenAI call intercepted by stub. Set OPENAI_API_KEY to enable real calls.');
    return { choices: [{ message: { content: stubJson } }] };
  }
}

export const openai = new OpenAIAdapter();



------------------------------------------------------------
FILE: backend\ai-service\src\config\redis.ts
------------------------------------------------------------
import { logger } from '@utils/logger';
import { createClient, RedisClientType } from 'redis';

class RedisConfig {
  private client: RedisClientType | null = null;

  constructor() {
    this.initializeClient();
  }

  private initializeClient(): void {
    try {
      this.client = createClient({
        url: process.env.REDIS_URL || 'redis://localhost:6379',
        socket: {
          reconnectStrategy: (retries) => Math.min(retries * 50, 1000)
        }
      });

      this.client.on('error', (err) => {
        logger.error('Redis client error:', err);
      });

      this.client.on('connect', () => {
        logger.info('Redis client connected');
      });

      this.client.on('ready', () => {
        logger.info('Redis client ready');
      });

      this.client.on('end', () => {
        logger.info('Redis client disconnected');
      });

    } catch (error) {
      logger.error('Failed to initialize Redis client:', error);
      throw error;
    }
  }

  public getClient(): RedisClientType {
    if (!this.client) {
      throw new Error('Redis client not initialized');
    }
    return this.client;
  }

  public async set(key: string, value: string, ttl?: number): Promise<void> {
    try {
      if (ttl) {
        await this.getClient().setEx(key, ttl, value);
      } else {
        await this.getClient().set(key, value);
      }
    } catch (error) {
      logger.error('Redis SET error:', { key, error });
      throw error;
    }
  }

  public async get(key: string): Promise<string | null> {
    try {
      return await this.getClient().get(key);
    } catch (error) {
      logger.error('Redis GET error:', { key, error });
      throw error;
    }
  }

  public async del(key: string): Promise<void> {
    try {
      await this.getClient().del(key);
    } catch (error) {
      logger.error('Redis DEL error:', { key, error });
      throw error;
    }
  }

  public async exists(key: string): Promise<boolean> {
    try {
      const result = await this.getClient().exists(key);
      return result === 1;
    } catch (error) {
      logger.error('Redis EXISTS error:', { key, error });
      throw error;
    }
  }

  public async close(): Promise<void> {
    if (this.client) {
      await this.client.quit();
      this.client = null;
      logger.info('Redis client closed');
    }
  }
}

export const redis = new RedisConfig();

export async function connectRedis(): Promise<void> {
  try {
    await redis.getClient().connect();
    logger.info('Redis connection established');
  } catch (error) {
    logger.error('Redis connection failed:', error);
    throw error;
  }
}


------------------------------------------------------------
FILE: backend\ai-service\src\controllers\AnalysisController.ts
------------------------------------------------------------
import { AnalysisService } from '@/services/AnalysisService';
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';
import { successResponse } from '@/utils/responses';
import { NextFunction, Request, Response } from 'express';

export class AnalysisController {
  private analysisService: AnalysisService;

  constructor() {
    this.analysisService = new AnalysisService();
  }

  public analyzeSchema = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { schema } = req.body;
      const userId = (req as any).user.id;

      if (!schema) {
        throw new APIError('Schema information is required', 400);
      }

      const analysis = await this.analysisService.analyzeSchema(schema, userId);

      logger.info('Schema analysis completed', { 
        userId, 
        schema: schema.name,
        tables: schema.tables?.length || 0
      });

      res.json(successResponse(analysis, 'Schema analysis completed'));

    } catch (error) {
      next(error);
    }
  };

  public analyzeDataSample = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { samples } = req.body;
      const userId = (req as any).user.id;

      if (!samples || !Array.isArray(samples)) {
        throw new APIError('Data samples are required', 400);
      }

      const analysis = await this.analysisService.analyzeDataSample(samples, userId);

      logger.info('Data sample analysis completed', { 
        userId,
        samplesAnalyzed: samples.length
      });

      res.json(successResponse(analysis, 'Data sample analysis completed'));

    } catch (error) {
      next(error);
    }
  };

  public performQualityCheck = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { dataSourceId, rules } = req.body;
      const userId = (req as any).user.id;

      if (!dataSourceId) {
        throw new APIError('Data source ID is required', 400);
      }

      const qualityReport = await this.analysisService.performQualityCheck(dataSourceId, rules, userId);

      logger.info('Quality check completed', { 
        userId,
        dataSourceId,
        rulesChecked: rules?.length || 0
      });

      res.json(successResponse(qualityReport, 'Quality check completed'));

    } catch (error) {
      next(error);
    }
  };
}


------------------------------------------------------------
FILE: backend\ai-service\src\controllers\DiscoveryController.ts
------------------------------------------------------------
import { AIService, NaturalLanguageQuery } from '@services/AIService';
import { DiscoveryService, StartDiscoveryRequest } from '@services/DiscoveryService';
import { APIError } from '@utils/errors';
import { logger } from '@utils/logger';
import { successResponse } from '@utils/responses';
import { NextFunction, Request, Response } from 'express';

export class DiscoveryController {
  private discoveryService: DiscoveryService;
  private aiService: AIService;

  constructor() {
    this.discoveryService = new DiscoveryService();
    this.aiService = new AIService();
  }

  public startDiscovery = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { dataSourceId, schemas, tables, options } = req.body;
      const userId = (req as any).user.id;

      if (!dataSourceId) {
        throw new APIError('Data source ID is required', 400);
      }

      const request: StartDiscoveryRequest = {
        userId,
        dataSourceId,
        schemas,
        tables,
        options
      };

      const session = await this.discoveryService.startDiscovery(request);

      logger.info('Discovery started', { sessionId: session.sessionId, userId });

      res.status(201).json(successResponse(session, 'Discovery session started'));

    } catch (error) {
      next(error);
    }
  };

  public getDiscoveryStatus = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { sessionId } = req.params;
      const userId = (req as any).user.id;

      const session = await this.discoveryService.getSession(sessionId);

      if (!session) {
        throw new APIError('Discovery session not found', 404);
      }

      if (session.userId !== userId) {
        throw new APIError('Access denied', 403);
      }

      res.json(successResponse(session));

    } catch (error) {
      next(error);
    }
  };

  public listDiscoverySessions = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = (req as any).user.id;
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = parseInt(req.query.offset as string) || 0;

      const sessions = await this.discoveryService.listSessions(userId, limit, offset);

      res.json(successResponse({
        sessions,
        pagination: {
          limit,
          offset,
          total: sessions.length
        }
      }));

    } catch (error) {
      next(error);
    }
  };

  public deleteDiscoverySession = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { sessionId } = req.params;
      const userId = (req as any).user.id;

      await this.discoveryService.deleteSession(sessionId, userId);

      logger.info('Discovery session deleted', { sessionId, userId });

      res.json(successResponse(null, 'Discovery session deleted'));

    } catch (error) {
      next(error);
    }
  };

  public processNaturalLanguageQuery = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { query, context } = req.body;
    if (!query) throw new APIError('Query is required', 400);

    const nlQuery: NaturalLanguageQuery = { query, context };
    const result = await this.aiService.processNaturalLanguageQuery(nlQuery);

    // ðŸ”§ Normalize to the frontendâ€™s expected AIResponse.data shape
    const payload = {
      message: "Hereâ€™s the SQL Iâ€™d run based on your request.",
      type: 'query' as const,
      results: {
        sql:          result.sql,
        explanation:  result.explanation,
        tables:       result.tables,
        fields:       result.fields,
        confidence:   result.confidence,
        warnings:     result.warnings,
        isAiGenerated: result.isAiGenerated
      },
      suggestions: [
        'Add a date range filter',
        'Group results by day',
        'Limit to the last 1,000 rows',
        'Explain this query step-by-step'
      ],
      actions: [
        { type: 'view_details', label: 'Copy SQL', payload: { sql: result.sql } },
        { type: 'export_data',  label: 'Export as CSV' }
      ]
    };

    res.json(successResponse(payload, 'Natural language query processed'));
  } catch (error) {
    next(error);
  }
};

  public generateQualityRules = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { fieldInfo } = req.body;

      if (!fieldInfo) {
        throw new APIError('Field information is required', 400);
      }

      const rules = await this.aiService.generateQualityRules(fieldInfo);

      res.json(successResponse({ rules }));

    } catch (error) {
      next(error);
    }
  };

  public explainViolation = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { violation } = req.body;

      if (!violation) {
        throw new APIError('Violation information is required', 400);
      }

      const explanation = await this.aiService.explainViolation(violation);

      res.json(successResponse({ explanation }));

    } catch (error) {
      next(error);
    }
  };
}


------------------------------------------------------------
FILE: backend\ai-service\src\controllers\HealthController.ts
------------------------------------------------------------
// src/controllers/HealthController.ts
import type { NextFunction, Request, Response } from 'express';
import { unlink, writeFile } from 'fs/promises';
import os from 'os';
import path from 'path';

import { db } from '@config/database';
import { openai } from '@config/openai';
import { redis } from '@config/redis';
import { APIError } from '@utils/errors';
import { logger } from '@utils/logger';
import { errorResponse, successResponse } from '@utils/responses';

type Status = 'healthy' | 'degraded' | 'unhealthy';

interface HealthCheck {
  name: string;
  status: Status;
  responseTime: number; // ms
  details?: unknown;
  error?: string;
}

interface SystemHealth {
  status: Status;
  service: string;
  version: string;
  timestamp: string;
  uptime: number;
  environment: string;
  checks: HealthCheck[];
  summary: { total: number; healthy: number; degraded: number; unhealthy: number };
  system: {
    memory: NodeJS.MemoryUsage;
    cpu: { loadAverage: number[]; usageMicros: number };
    process: { pid: number; platform: string; nodeVersion: string };
  };
}

// --- bounded timeouts to avoid crazy env values
const clamp = (n: number, min: number, max: number) => Math.max(min, Math.min(max, n));
const DEFAULT_CHECK_TIMEOUT_MS = clamp(Number(process.env.HEALTH_CHECK_TIMEOUT_MS || 2000), 250, 10_000);

// Mask detailed dependency errors in production
const mask = (msg: string) => (process.env.NODE_ENV === 'development' ? msg : 'dependency error');

export class HealthController {
  private healthChecks: Map<string, () => Promise<HealthCheck>> = new Map();

  constructor() {
    this.initializeHealthChecks();
  }

  private initializeHealthChecks(): void {
    this.healthChecks.set('database', this.checkDatabase.bind(this));
    this.healthChecks.set('redis', this.checkRedis.bind(this));
    this.healthChecks.set('openai', this.checkOpenAI.bind(this));
    this.healthChecks.set('memory', this.checkMemory.bind(this));
    this.healthChecks.set('storage', this.checkStorage.bind(this));
  }

  public checkHealth = async (_req: Request, res: Response): Promise<void> => {
    const started = Date.now();
    logger.debug('Health: starting');

    const entries = Array.from(this.healthChecks.entries());
    const checks = await Promise.all(
      entries.map(([name, fn]) => this.runWithTimeout(name, fn, DEFAULT_CHECK_TIMEOUT_MS))
    );

    const summary = {
      total: checks.length,
      healthy: checks.filter(c => c.status === 'healthy').length,
      degraded: checks.filter(c => c.status === 'degraded').length,
      unhealthy: checks.filter(c => c.status === 'unhealthy').length
    };

    const overall: Status =
      summary.unhealthy > 0 ? 'unhealthy' : summary.degraded > 0 ? 'degraded' : 'healthy';

    const system = this.getSystemInfo();
    const payload: SystemHealth = {
      status: overall,
      service: 'ai-service',
      version: process.env.APP_VERSION || '1.0.0',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      environment: process.env.NODE_ENV || 'development',
      checks,
      summary,
      system
    };

    logger.info('Health: completed', { status: overall, durationMs: Date.now() - started, summary });

    // prevent caches from serving stale health
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res
      .status(overall === 'unhealthy' ? 503 : 200)
      .json(successResponse(payload, 'Health check completed'));
  };

  public checkReadiness = async (_req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      logger.debug('Readiness: starting');
      const critical: Array<[string, () => Promise<HealthCheck>]> = [
        ['database', this.checkDatabase.bind(this)],
        ['redis', this.checkRedis.bind(this)],
        ['openai', this.checkOpenAI.bind(this)]
      ];

      const results = await Promise.all(
        critical.map(([name, fn]) => this.runWithTimeout(name, fn, DEFAULT_CHECK_TIMEOUT_MS))
      );

      const failures = results.filter(r => r.status === 'unhealthy');

      if (failures.length) {
        logger.warn('Readiness: failed', { failures });
        res
          .status(503)
          .json(
            errorResponse('Service not ready', 503, {
              status: 'not ready',
              service: 'ai-service',
              timestamp: new Date().toISOString(),
              failures
            })
          );
        return;
      }

      logger.info('Readiness: passed');
      res.setHeader('Cache-Control', 'no-store');
      res.json(
        successResponse(
          { status: 'ready', service: 'ai-service', timestamp: new Date().toISOString(), message: 'Service is ready to accept requests' },
          'Readiness check passed'
        )
      );
    } catch (err) {
      logger.error('Readiness: error', { err });
      next(new APIError('Readiness check failed', 503, err));
    }
  };

  public checkLiveness = async (_req: Request, res: Response): Promise<void> => {
    const status = {
      status: 'alive',
      service: 'ai-service',
      timestamp: new Date().toISOString(),
      uptime: Math.floor(process.uptime()),
      pid: process.pid,
      memory: process.memoryUsage()
    };
    logger.debug('Liveness: ok', status);
    res.setHeader('Cache-Control', 'no-store');
    res.json(successResponse(status, 'Service is alive'));
  };

  public getMetrics = async (_req: Request, res: Response): Promise<void> => {
    try {
      // short sampling window to compute delta CPU
      const snap = process.cpuUsage();
      await new Promise(r => setTimeout(r, 50));
      const delta = process.cpuUsage(snap);
      const usageMicros = delta.user + delta.system;

      const metrics = {
        service: 'ai-service',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        cpu: { loadAverage: os.loadavg(), usageMicros },
        requests: { total: 0, active: 0, errors: 0 }, // wire your counters via middleware
        cache: await this.getCacheMetrics(),
        database: await this.getDatabaseMetrics()
      };

      res.setHeader('Cache-Control', 'no-store');
      res.json(successResponse(metrics, 'Metrics retrieved'));
    } catch (err) {
      logger.error('Metrics: failed', { err });
      res.status(500).json(errorResponse('Failed to retrieve metrics', 500));
    }
  };

  // ----- Individual checks

  private async checkDatabase(): Promise<HealthCheck> {
    const t0 = Date.now();
    try {
      await db.query('SELECT 1');
      return { name: 'database', status: 'healthy', responseTime: Date.now() - t0, details: { type: 'PostgreSQL', connection: 'active' } };
    } catch (err: any) {
      return { name: 'database', status: 'unhealthy', responseTime: Date.now() - t0, error: mask(err?.message || 'db error') };
    }
  }

  private async checkRedis(): Promise<HealthCheck> {
    const t0 = Date.now();
    try {
      const key = `health:check:${Date.now()}`;
      // Redis v4: { EX: seconds }
      await (redis as any).set?.(key, 'ok', { EX: 10 });
      const val = await (redis as any).get?.(key);
      await (redis as any).del?.(key);
      if (val !== 'ok') throw new Error('Redis read/write test failed');
      return { name: 'redis', status: 'healthy', responseTime: Date.now() - t0, details: { type: 'Redis', operation: 'read/write passed' } };
    } catch (err: any) {
      return { name: 'redis', status: 'unhealthy', responseTime: Date.now() - t0, error: mask(err?.message || 'redis error') };
    }
  }

  private async checkOpenAI(): Promise<HealthCheck> {
    const t0 = Date.now();
    try {
      let ok = false;
      if (typeof (openai as any)?.testConnection === 'function') {
        ok = await (openai as any).testConnection();
      } else if ((openai as any)?.models?.list) {
        const models = await (openai as any).models.list();
        ok = Boolean(models);
      }
      return {
        name: 'openai',
        status: ok ? 'healthy' : 'degraded',
        responseTime: Date.now() - t0,
        details: { type: 'OpenAI API', available: ok },
        ...(ok ? {} : { error: 'OpenAI API not verified' })
      };
    } catch (err: any) {
      return { name: 'openai', status: 'degraded', responseTime: Date.now() - t0, error: mask(err?.message || 'OpenAI check failed') };
    }
  }

  private async checkMemory(): Promise<HealthCheck> {
    const t0 = Date.now();
    try {
      const m = process.memoryUsage();
      const pct = (m.heapUsed / Math.max(m.heapTotal, 1)) * 100;
      let status: Status = 'healthy';
      let message = 'Memory usage normal';
      if (pct > 90) { status = 'unhealthy'; message = 'Critical memory usage'; }
      else if (pct > 75) { status = 'degraded'; message = 'High memory usage'; }

      return {
        name: 'memory',
        status,
        responseTime: Date.now() - t0,
        details: {
          usagePercent: Math.round(pct * 100) / 100,
          heapUsedMB: Math.round((m.heapUsed / 1024 / 1024) * 100) / 100,
          heapTotalMB: Math.round((m.heapTotal / 1024 / 1024) * 100) / 100,
          message
        }
      };
    } catch {
      return { name: 'memory', status: 'unhealthy', responseTime: Date.now() - t0, error: 'Failed to evaluate memory' };
    }
  }

  private async checkStorage(): Promise<HealthCheck> {
    const t0 = Date.now();
    const base = process.env.HEALTH_TMP_DIR || os.tmpdir(); // configurable for read-only FS
    const file = path.join(base, `ai-service-health-${process.pid}-${Date.now()}.tmp`);
    try {
      await writeFile(file, 'health check');
      await unlink(file);
      return { name: 'storage', status: 'healthy', responseTime: Date.now() - t0, details: { type: 'filesystem', dir: base, writable: true } };
    } catch (err: any) {
      return { name: 'storage', status: 'degraded', responseTime: Date.now() - t0, error: mask(err?.message || 'Storage write test failed') };
    }
  }

  // ----- Helpers

  private getSystemInfo() {
    const mem = process.memoryUsage();
    const cpu0 = process.cpuUsage();
    const load = os.loadavg();
    return {
      memory: mem,
      cpu: { loadAverage: load, usageMicros: cpu0.user + cpu0.system },
      process: { pid: process.pid, platform: process.platform, nodeVersion: process.version }
    };
  }

  private async getCacheMetrics() {
    try {
      if (typeof (redis as any)?.getStats === 'function') {
        const stats = await (redis as any).getStats();
        return { connected: true, stats };
      }
      const pong = await (redis as any).ping?.();
      return { connected: pong === 'PONG' || pong === true };
    } catch (err: any) {
      return { connected: false, error: mask(err?.message || 'Failed to get Redis stats') };
    }
  }

  private async getDatabaseMetrics() {
    try {
      const result = await db.query(`
        SELECT 
          pg_database_size(current_database()) as database_size,
          (SELECT count(*) FROM pg_stat_activity WHERE state = 'active') as active_connections
      `);
      const row = (result as any).rows?.[0] || {};
      return {
        connected: true,
        size: Number(row.database_size ?? 0),
        activeConnections: Number(row.active_connections ?? 0)
      };
    } catch (err: any) {
      return { connected: false, error: mask(err?.message || 'Failed to get database metrics') };
    }
  }

  private async runWithTimeout(name: string, fn: () => Promise<HealthCheck>, timeoutMs: number): Promise<HealthCheck> {
    const started = Date.now();
    try {
      const result = await Promise.race<Promise<HealthCheck>>([
        fn(),
        new Promise<HealthCheck>((_resolve, reject) => setTimeout(() => reject(new Error(`${name} check timed out after ${timeoutMs}ms`)), timeoutMs))
      ]);
      return result;
    } catch (err: any) {
      logger.warn('Health: check failed', { name, error: err?.message });
      return { name, status: 'unhealthy', responseTime: Date.now() - started, error: mask(err?.message || 'Unknown error') };
    }
  }
}



------------------------------------------------------------
FILE: backend\ai-service\src\interfaces\analysis.interface.ts
------------------------------------------------------------
export interface AnalysisRequest {
  dataSourceId: string;
  analysisType: 'schema' | 'data_quality' | 'compliance' | 'performance';
  options?: AnalysisOptions;
  userId: string;
}

export interface AnalysisOptions {
  includeMetadata?: boolean;
  includeSampleData?: boolean;
  sampleSize?: number;
  analysisDepth?: 'basic' | 'detailed' | 'comprehensive';
  targetTables?: string[];
  targetSchemas?: string[];
  complianceFrameworks?: ComplianceFramework[];
}

export interface AnalysisResult {
  analysisId: string;
  dataSourceId: string;
  analysisType: string;
  status: AnalysisStatus;
  progress: number;
  startedAt: Date;
  completedAt?: Date;
  results?: AnalysisData;
  error?: string;
  userId: string;
}

export interface AnalysisData {
  schemaAnalysis?: SchemaAnalysisResult;
  qualityAnalysis?: QualityAnalysisResult;
  complianceAnalysis?: ComplianceAnalysisResult;
  performanceAnalysis?: PerformanceAnalysisResult;
  summary: AnalysisSummary;
}

export interface SchemaAnalysisResult {
  totalTables: number;
  totalColumns: number;
  tableAnalysis: TableAnalysis[];
  relationshipMap: RelationshipAnalysis[];
  dataClassification: DataClassificationSummary;
  recommendations: string[];
}

export interface TableAnalysis {
  schemaName: string;
  tableName: string;
  columnCount: number;
  estimatedRowCount?: number;
  columns: ColumnAnalysis[];
  governance: TableGovernance;
  dataQuality: TableQualityMetrics;
  relationships: TableRelationship[];
}

export interface ColumnAnalysis {
  name: string;
  dataType: string;
  nullable: boolean;
  isPrimaryKey: boolean;
  isForeignKey: boolean;
  classification: DataClassification;
  sensitivity: SensitivityLevel;
  qualityScore: number;
  patterns: DataPattern[];
  statistics?: ColumnStatistics;
  recommendations: string[];
}

export interface TableGovernance {
  classification: DataClassification;
  sensitivity: SensitivityLevel;
  complianceRequirements: ComplianceFramework[];
  accessLevel: AccessLevel;
  retentionPolicy?: RetentionPolicy;
  encryptionRequired: boolean;
  auditRequired: boolean;
}

export interface TableQualityMetrics {
  completeness: number;
  validity: number;
  consistency: number;
  accuracy: number;
  uniqueness: number;
  overallScore: number;
  issues: QualityIssue[];
}

export interface QualityAnalysisResult {
  overallScore: number;
  dimensionScores: QualityDimensionScores;
  issues: QualityIssue[];
  trends: QualityTrend[];
  recommendations: QualityRecommendation[];
}

export interface QualityDimensionScores {
  completeness: number;
  validity: number;
  consistency: number;
  accuracy: number;
  uniqueness: number;
  timeliness: number;
}

export interface QualityIssue {
  id: string;
  type: QualityIssueType;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  table: string;
  column?: string;
  description: string;
  affectedRows: number;
  suggestion: string;
  detectedAt: Date;
  status: 'Open' | 'Acknowledged' | 'Resolved' | 'Ignored';
}

export interface ComplianceAnalysisResult {
  overallScore: number;
  frameworkResults: FrameworkComplianceResult[];
  violations: ComplianceViolation[];
  recommendations: ComplianceRecommendation[];
  riskAssessment: RiskAssessment;
}

export interface FrameworkComplianceResult {
  framework: ComplianceFramework;
  score: number;
  status: 'Compliant' | 'Partially Compliant' | 'Non-Compliant';
  requirements: RequirementResult[];
  lastAssessed: Date;
}

export interface PerformanceAnalysisResult {
  queryPerformance: QueryPerformanceMetrics;
  indexAnalysis: IndexAnalysis[];
  storageAnalysis: StorageMetrics;
  recommendations: PerformanceRecommendation[];
}

export interface AnalysisSummary {
  totalTables: number;
  totalColumns: number;
  sensitiveDataTables: number;
  qualityScore: number;
  complianceScore: number;
  criticalIssues: number;
  highPriorityRecommendations: string[];
  estimatedImprovementEffort: 'Low' | 'Medium' | 'High';
}

// Supporting Enums and Types
export enum AnalysisStatus {
  PENDING = 'pending',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

export enum DataClassification {
  PUBLIC = 'Public',
  INTERNAL = 'Internal',
  CONFIDENTIAL = 'Confidential',
  RESTRICTED = 'Restricted',
  PII = 'PII',
  PHI = 'PHI',
  FINANCIAL = 'Financial'
}

export enum SensitivityLevel {
  LOW = 'Low',
  MEDIUM = 'Medium',
  HIGH = 'High',
  CRITICAL = 'Critical'
}

export enum ComplianceFramework {
  GDPR = 'GDPR',
  HIPAA = 'HIPAA',
  CCPA = 'CCPA',
  SOX = 'SOX',
  PCI_DSS = 'PCI-DSS',
  ISO_27001 = 'ISO-27001',
  NIST = 'NIST'
}

export enum AccessLevel {
  PUBLIC = 'Public',
  INTERNAL = 'Internal',
  RESTRICTED = 'Restricted',
  CONFIDENTIAL = 'Confidential'
}

export enum QualityIssueType {
  NULL_VALUES = 'null_values',
  DUPLICATES = 'duplicates',
  FORMAT_INCONSISTENCY = 'format_inconsistency',
  OUTLIERS = 'outliers',
  REFERENTIAL_INTEGRITY = 'referential_integrity',
  BUSINESS_RULE_VIOLATION = 'business_rule_violation'
}

// Supporting Interfaces
export interface DataPattern {
  type: string;
  pattern: string;
  confidence: number;
  examples: string[];
}

export interface ColumnStatistics {
  nullCount: number;
  uniqueCount: number;
  minValue?: any;
  maxValue?: any;
  avgValue?: number;
  standardDeviation?: number;
  distribution?: ValueDistribution[];
}

export interface ValueDistribution {
  value: any;
  count: number;
  percentage: number;
}

export interface RelationshipAnalysis {
  sourceTable: string;
  targetTable: string;
  relationshipType: 'one-to-one' | 'one-to-many' | 'many-to-many';
  foreignKeys: ForeignKeyRelation[];
  strength: number;
}

export interface ForeignKeyRelation {
  sourceColumn: string;
  targetColumn: string;
  constraintName?: string;
}

export interface TableRelationship {
  relatedTable: string;
  relationshipType: string;
  foreignKeyColumns: string[];
  isStrong: boolean;
}

export interface DataClassificationSummary {
  byClassification: Record<DataClassification, number>;
  bySensitivity: Record<SensitivityLevel, number>;
  byCompliance: Record<ComplianceFramework, number>;
  totalSensitiveFields: number;
}

export interface RetentionPolicy {
  retentionPeriod: number;
  retentionUnit: 'days' | 'months' | 'years';
  archiveAfter?: number;
  deleteAfter?: number;
  policy: string;
}

export interface QualityTrend {
  date: Date;
  dimension: string;
  score: number;
  change: number;
}

export interface QualityRecommendation {
  id: string;
  priority: 'High' | 'Medium' | 'Low';
  category: 'Data Quality' | 'Governance' | 'Compliance' | 'Performance';
  title: string;
  description: string;
  impact: string;
  effort: 'Low' | 'Medium' | 'High';
  estimatedImprovement: number;
  implementation: string[];
}

export interface ComplianceViolation {
  id: string;
  framework: ComplianceFramework;
  requirement: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  table: string;
  column?: string;
  description: string;
  remediation: string;
  dueDate?: Date;
  status: 'Open' | 'In Progress' | 'Resolved';
}

export interface ComplianceRecommendation {
  framework: ComplianceFramework;
  requirement: string;
  description: string;
  priority: 'High' | 'Medium' | 'Low';
  implementation: string[];
  timeline: string;
}

export interface RiskAssessment {
  overallRisk: 'Low' | 'Medium' | 'High' | 'Critical';
  riskFactors: RiskFactor[];
  mitigationStrategies: string[];
  businessImpact: string;
}

export interface RiskFactor {
  factor: string;
  level: 'Low' | 'Medium' | 'High' | 'Critical';
  description: string;
  likelihood: number;
  impact: number;
}

export interface RequirementResult {
  requirement: string;
  status: 'Met' | 'Partially Met' | 'Not Met';
  description: string;
  evidence?: string[];
  gaps?: string[];
}

export interface QueryPerformanceMetrics {
  avgQueryTime: number;
  slowQueries: SlowQuery[];
  queryPatterns: QueryPattern[];
  resourceUtilization: ResourceUtilization;
}

export interface SlowQuery {
  query: string;
  executionTime: number;
  frequency: number;
  table: string;
  recommendation: string;
}

export interface QueryPattern {
  pattern: string;
  frequency: number;
  avgExecutionTime: number;
  optimization: string;
}

export interface ResourceUtilization {
  cpuUsage: number;
  memoryUsage: number;
  ioWait: number;
  connectionCount: number;
}

export interface IndexAnalysis {
  table: string;
  existingIndexes: IndexInfo[];
  suggestedIndexes: SuggestedIndex[];
  unusedIndexes: string[];
}

export interface IndexInfo {
  name: string;
  columns: string[];
  type: string;
  size: number;
  usage: number;
}

export interface SuggestedIndex {
  columns: string[];
  type: string;
  rationale: string;
  estimatedImprovement: number;
}

export interface StorageMetrics {
  totalSize: number;
  tablesSizes: TableSize[];
  growthRate: number;
  projectedSize: number;
  optimization: string[];
}

export interface TableSize {
  table: string;
  size: number;
  rowCount: number;
  avgRowSize: number;
}

export interface PerformanceRecommendation {
  type: 'Index' | 'Query' | 'Schema' | 'Configuration';
  description: string;
  impact: 'High' | 'Medium' | 'Low';
  effort: 'Low' | 'Medium' | 'High';
  implementation: string;
}


------------------------------------------------------------
FILE: backend\ai-service\src\interfaces\discovery.interface.ts
------------------------------------------------------------
/* eslint-disable @typescript-eslint/consistent-type-definitions */

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Utility & Brand Types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */
export type Brand<K, T extends string> = K & { readonly __brand: T };

export type UUID = Brand<string, 'uuid'>;               // e.g., '2f1a2c1e-...'
export type ISODateTime = Brand<string, 'iso-datetime'>; // e.g., new Date().toISOString()
export type ByteSize = Brand<number, 'bytes'>;
export type Percentage = Brand<number, '0..100'>;

export type NonEmptyArray<T> = readonly [T, ...T[]];
export type PositiveInt = Brand<number, 'positive-int'>;

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Shared Enums / Unions
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */
export type DiscoveryType = 'full' | 'incremental' | 'targeted';

export enum DiscoveryStatus {
  PENDING = 'pending',
  INITIALIZING = 'initializing',
  SCANNING_METADATA = 'scanning_metadata',
  SAMPLING_DATA = 'sampling_data',
  CLASSIFYING = 'classifying',
  AI_ANALYSIS = 'ai_analysis',
  QUALITY_ASSESSMENT = 'quality_assessment',
  GENERATING_INSIGHTS = 'generating_insights',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled',
}

export enum PatternType {
  EMAIL = 'email',
  PHONE = 'phone',
  SSN = 'ssn',
  CREDIT_CARD = 'credit_card',
  IP_ADDRESS = 'ip_address',
  UUID = 'uuid',
  DATE = 'date',
  URL = 'url',
  CUSTOM = 'custom',
}

export type ConstraintKind = 'PRIMARY KEY' | 'FOREIGN KEY' | 'UNIQUE' | 'CHECK' | 'NOT NULL';
export type IndexMethod = 'btree' | 'hash' | 'gist' | 'gin' | 'brin' | 'spgist' | string;
export type TableLike = 'table' | 'view' | 'materialized_view';

export type DBType =
  | 'postgres'
  | 'mysql'
  | 'mariadb'
  | 'mssql'
  | 'oracle'
  | 'snowflake'
  | 'bigquery'
  | 'sqlite'
  | 'redshift'
  | string;

export type QualityDimension = 'Completeness' | 'Validity' | 'Consistency' | 'Accuracy' | 'Uniqueness';
export type DataVolume = 'Small' | 'Medium' | 'Large' | 'Very Large';
export type Criticality = 'Low' | 'Medium' | 'High' | 'Critical';
export type RiskLevel = Criticality;
export type Priority = 'Critical' | 'High' | 'Medium' | 'Low';
export type Timeline = 'Immediate' | 'Short Term' | 'Long Term';

export type GovernanceCategory = 'Access Control' | 'Data Classification' | 'Retention' | 'Compliance';

export type DataClassification =
  | 'PII'
  | 'PHI'
  | 'PCI'
  | 'Confidential'
  | 'Restricted'
  | 'Internal'
  | 'Public'
  | 'Custom';

export type SensitivityLevel = 'Low' | 'Medium' | 'High' | 'Very High';

export type ComplianceFramework =
  | 'GDPR'
  | 'HIPAA'
  | 'PCI-DSS'
  | 'SOX'
  | 'CCPA'
  | 'ISO27001'
  | 'NIST'
  | 'SOC2'
  | 'Custom';

export type ClassificationScope = 'column_name' | 'data_type' | 'data_pattern';

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Request Models
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

export interface DiscoveryOptions {
  readonly schemas?: readonly string[];
  readonly tables?: readonly string[];
  readonly includeSystemTables?: boolean;
  readonly includeSampleData?: boolean;
  readonly sampleSize?: PositiveInt; // rows per table when sampling
  readonly analysisDepth?: 'basic' | 'detailed' | 'comprehensive';
  readonly aiAnalysis?: boolean;
  readonly classificationRules?: readonly ClassificationRule[];
  readonly customPatterns?: readonly CustomPattern[];
}

/**
 * Discriminated DiscoveryRequest:
 * - full / incremental: options optional
 * - targeted: requires at least one of schemas/tables, and they cannot be empty
 */
interface BaseDiscoveryRequest {
  readonly dataSourceId: UUID | string;
  readonly userId: UUID | string;
}

export type DiscoveryRequest =
  | (BaseDiscoveryRequest & {
      readonly discoveryType: 'full';
      readonly options?: DiscoveryOptions;
    })
  | (BaseDiscoveryRequest & {
      readonly discoveryType: 'incremental';
      readonly options?: DiscoveryOptions & { readonly since?: ISODateTime };
    })
  | (BaseDiscoveryRequest & {
      readonly discoveryType: 'targeted';
      readonly options: DiscoveryOptions & {
        readonly schemas?: NonEmptyArray<string>;
        readonly tables?: NonEmptyArray<string>;
      };
    });

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Session / Results
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

export interface DiscoverySession {
  readonly sessionId: UUID | string;
  readonly userId: UUID | string;
  readonly dataSourceId: UUID | string;
  readonly discoveryType: DiscoveryType;
  readonly status: DiscoveryStatus;
  readonly progress: Percentage; // 0..100
  readonly currentStep?: string;
  readonly results?: DiscoveryResults;
  readonly error?: string;
  readonly startedAt: Date;
  readonly completedAt?: Date;
  readonly estimatedCompletion?: Date;
  readonly options: DiscoveryOptions;
}

export interface DiscoveryResults {
  readonly metadata: DataSourceMetadata;
  readonly classification: ClassificationResults;
  readonly aiInsights: AIInsights;
  readonly qualityAssessment: QualityAssessment;
  readonly summary: DiscoverySummary;
  readonly recommendations: readonly DiscoveryRecommendation[];
}

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Metadata Shapes
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

export interface DataSourceMetadata {
  readonly dataSourceId: UUID | string;
  readonly connectionInfo: ConnectionInfo;
  readonly schemas: readonly SchemaMetadata[];
  readonly totalTables: number;
  readonly totalColumns: number;
  readonly totalRows?: number;
  readonly dataSize?: ByteSize;
  readonly lastUpdated: Date;
}

export interface ConnectionInfo {
  readonly type: DBType;
  readonly host?: string;
  readonly port?: number;
  readonly database?: string;
  readonly version?: string;
  readonly charset?: string;
  readonly collation?: string;
}

export interface SchemaMetadata {
  readonly name: string;
  readonly tables: readonly TableMetadata[];
  readonly views: readonly ViewMetadata[];
  readonly procedures?: readonly ProcedureMetadata[];
  readonly functions?: readonly FunctionMetadata[];
}

export interface TableMetadata {
  readonly schema: string;
  readonly name: string;
  readonly type: TableLike;
  readonly columns: readonly ColumnMetadata[];
  readonly primaryKeys: readonly string[];
  readonly foreignKeys: readonly ForeignKeyMetadata[];
  readonly indexes: readonly IndexMetadata[];
  readonly constraints: readonly ConstraintMetadata[];
  readonly rowCount?: number;
  readonly sizeBytes?: ByteSize;
  readonly lastModified?: Date;
  readonly sampleData?: readonly unknown[];
}

export interface ColumnMetadata {
  readonly name: string;
  readonly dataType: string;
  readonly length?: number;
  readonly precision?: number;
  readonly scale?: number;
  readonly nullable: boolean;
  readonly defaultValue?: unknown;
  readonly autoIncrement?: boolean;
  readonly description?: string;
  readonly position: number;
}

export interface ViewMetadata {
  readonly schema: string;
  readonly name: string;
  readonly definition: string;
  readonly columns: readonly ColumnMetadata[];
  readonly dependencies: readonly string[];
}

export interface ProcedureMetadata {
  readonly schema: string;
  readonly name: string;
  readonly parameters: readonly ParameterMetadata[];
  readonly returnType?: string;
  readonly language?: string;
}

export interface FunctionMetadata {
  readonly schema: string;
  readonly name: string;
  readonly parameters: readonly ParameterMetadata[];
  readonly returnType: string;
  readonly language?: string;
}

export interface ParameterMetadata {
  readonly name: string;
  readonly dataType: string;
  readonly direction: 'IN' | 'OUT' | 'INOUT';
  readonly defaultValue?: unknown;
}

export interface ForeignKeyMetadata {
  readonly name: string;
  readonly columns: readonly string[];
  readonly referencedTable: string; // consider "schema.table"
  readonly referencedColumns: readonly string[];
  readonly onDelete?: 'NO ACTION' | 'RESTRICT' | 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | string;
  readonly onUpdate?: 'NO ACTION' | 'RESTRICT' | 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | string;
}

export interface IndexMetadata {
  readonly name: string;
  readonly columns: readonly string[];
  readonly unique: boolean;
  readonly type?: string;   // btree, hash... (engine-specific)
  readonly method?: IndexMethod;
}

export interface ConstraintMetadata {
  readonly name: string;
  readonly type: ConstraintKind;
  readonly columns: readonly string[];
  readonly definition?: string;
}

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Classification / Compliance
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

export interface ClassificationResults {
  readonly fieldClassifications: readonly FieldClassification[];
  readonly tableClassifications: readonly TableClassification[];
  readonly sensitivityMap: SensitivityMap;
  readonly complianceMapping: ComplianceMapping;
  readonly riskAssessment: DataRiskAssessment;
}

export interface FieldClassification {
  readonly schema: string;
  readonly table: string;
  readonly column: string;
  readonly dataType: string;
  readonly classification: DataClassification;
  readonly sensitivity: SensitivityLevel;
  readonly confidence: Percentage;
  readonly patterns: readonly DetectedPattern[];
  readonly tags: readonly string[];
  readonly businessContext?: string;
  readonly complianceFlags: readonly ComplianceFlag[];
}

export interface TableClassification {
  readonly schema: string;
  readonly table: string;
  readonly overallClassification: DataClassification;
  readonly overallSensitivity: SensitivityLevel;
  readonly dataVolume: DataVolume;
  readonly businessCriticality: Criticality;
  readonly accessFrequency: 'Rare' | 'Occasional' | 'Regular' | 'High';
  readonly retentionCategory: string;
  readonly complianceScope: readonly ComplianceFramework[];
}

export interface DetectedPattern {
  readonly type: PatternType;
  readonly pattern: string; // e.g., regex or named rule
  readonly confidence: Percentage;
  readonly examples: readonly string[];
  readonly description: string;
}

export interface SensitivityMap {
  readonly bySensitivity: Record<SensitivityLevel, readonly FieldClassification[]>;
  readonly byClassification: Record<DataClassification, readonly FieldClassification[]>;
  readonly sensitiveTableCount: number;
  readonly highRiskFields: readonly FieldClassification[];
}

export interface ComplianceMapping {
  readonly byFramework: Record<ComplianceFramework, ComplianceScope>;
  readonly overallComplexity: 'Low' | 'Medium' | 'High' | 'Very High';
  readonly requiredActions: readonly ComplianceAction[];
}

export interface ComplianceScope {
  readonly applicableTables: readonly string[]; // consider using "schema.table" naming
  readonly applicableFields: readonly FieldClassification[];
  readonly requirements: readonly string[];
  readonly riskLevel: RiskLevel;
}

export interface ComplianceAction {
  readonly framework: ComplianceFramework;
  readonly action: string;
  readonly priority: 'High' | 'Medium' | 'Low';
  readonly timeline: string;
  readonly effort: 'Low' | 'Medium' | 'High';
}

export interface ComplianceFlag {
  readonly framework: ComplianceFramework;
  readonly requirement: string;
  readonly severity: 'Info' | 'Warning' | 'Error';
  readonly description: string;
}

/**
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Risk / Quality / AI Insights
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 */

export interface DataRiskAssessment {
  readonly overallRisk: RiskLevel;
  readonly riskFactors: readonly DataRiskFactor[];
  readonly mitigationPriorities: readonly string[];
  readonly businessImpact: BusinessImpact;
}

export interface DataRiskFactor {
  readonly factor: string;
  readonly level: RiskLevel;
  readonly description: string;
  readonly affectedTables: readonly string[];
  readonly mitigationStrategy: string;
}

export interface BusinessImpact {
  readonly reputational: RiskLevel;
  readonly financial: RiskLevel;
  readonly operational: RiskLevel;
  readonly regulatory: RiskLevel;
}

export interface AIInsights {
  readonly fieldRecommendations: readonly AIFieldRecommendation[];
  readonly schemaInsights: readonly SchemaInsight[];
  readonly qualityPredictions: readonly QualityPrediction[];
  readonly governanceRecommendations: readonly GovernanceRecommendation[];
  readonly anomalies: readonly DataAnomaly[];
}

export interface AIFieldRecommendation {
  readonly schema: string;
  readonly table: string;
  readonly column: string;
  readonly recommendation: string;
  readonly reasoning: string;
  readonly confidence: Percentage;
  readonly impact: 'Low' | 'Medium' | 'High';
  readonly category: 'Classification' | 'Quality' | 'Governance' | 'Security';
}

export interface SchemaInsight {
  readonly type: 'Pattern' | 'Relationship' | 'Optimization' | 'Risk';
  readonly insight: string;
  readonly confidence: Percentage;
  readonly tables: readonly string[];
  readonly recommendation: string;
  readonly priority: 'Low' | 'Medium' | 'High';
}

export interface QualityPrediction {
  readonly table: string;
  readonly column?: string;
  readonly qualityDimension: QualityDimension;
  readonly predictedScore: Percentage; // 0..100
  readonly confidence: Percentage;     // 0..100
  readonly factors: readonly string[];
  readonly recommendations: readonly string[];
}

export interface GovernanceRecommendation {
  readonly scope: 'Field' | 'Table' | 'Schema' | 'Database';
  readonly target: string; // e.g., "schema.table.column"
  readonly recommendation: string;
  readonly category: GovernanceCategory;
  readonly priority: 'High' | 'Medium' | 'Low';
  readonly effort: 'Low' | 'Medium' | 'High';
  readonly benefit: string;
}

export interface DataAnomaly {
  readonly type: 'Statistical' | 'Pattern' | 'Relationship' | 'Quality';
  readonly table: string;
  readonly column?: string;
  readonly description: string;
  readonly severity: 'Info' | 'Warning' | 'Error';
  readonly confidence: Percentage;
  readonly suggestion: string;
}

export interface QualityAssessment {
  readonly overallScore: Percentage;
  readonly tableScores: readonly TableQualityScore[];
  readonly dimensionScores: QualityDimensionScores;
  readonly issues: readonly QualityIssue[];
  readonly trends?: readonly QualityTrend[];
}

export interface TableQualityScore {
  readonly schema: string;
  readonly table: string;
  readonly overallScore: Percentage;
  readonly completeness: Percentage;
  readonly validity: Percentage;
  readonly consistency: Percentage;
  readonly accuracy: Percentage;
  readonly uniqueness: Percentage;
  readonly issueCount: number;
  readonly recommendation: string;
}

export interface QualityDimensionScores {
  readonly [dimension: string]: Percentage | number; // allow dynamic dimensions
}

export interface QualityIssue {
  readonly id?: UUID | string;
  readonly schema: string;
  readonly table: string;
  readonly column?: string;
  readonly dimension: QualityDimension;
  readonly severity: 'Low' | 'Medium' | 'High';
  readonly description: string;
  readonly recommendation: string;
}

export interface QualityTrend {
  readonly timestamp: ISODateTime | string;
  readonly dimension: QualityDimension;
  readonly score: Percentage;
}

export interface DiscoverySummary {
  readonly totalTablesAnalyzed: number;
  readonly totalColumnsAnalyzed: number;
  readonly classificationsApplied: number;
  readonly sensitiveDataFound: number;
  readonly complianceFlags: number;
  readonly qualityIssues: number;
  readonly aiRecommendations: number;
  readonly executionTime: number; // ms
  readonly dataVolumeProcessed: ByteSize | number;
}

export interface DiscoveryRecommendation {
  readonly id: UUID | string;
  readonly category: Timeline;
  readonly priority: Priority;
  readonly type: 'Security' | 'Compliance' | 'Quality' | 'Governance' | 'Performance';
  readonly title: string;
  readonly description: string;
  readonly affectedTables: readonly string[];
  readonly businessImpact: string;
  readonly effort: 'Low' | 'Medium' | 'High';
  readonly timeline: string;
  readonly implementation: readonly ImplementationStep[];
}

export interface ImplementationStep {
  readonly step: number;
  readonly description: string;
  readonly estimatedTime: string;
  readonly dependencies?: readonly string[];
  readonly tools?: readonly string[];
}

export interface ClassificationRule {
  readonly name: string;
  readonly pattern: string; // regex or named rule
  readonly classification: DataClassification;
  readonly sensitivity: SensitivityLevel;
  readonly scope: ClassificationScope;
  readonly priority: number;
}

export interface CustomPattern {
  readonly name: string;
  readonly regex: string; // serialized regex
  readonly classification: DataClassification;
  readonly description: string;
  readonly examples: readonly string[];
}



------------------------------------------------------------
FILE: backend\ai-service\src\interfaces\index.ts
------------------------------------------------------------
// src/interfaces/index.ts

// Namespace-style re-exports (import as `Analysis.*` or `Discovery.*`)
export * as Analysis from './analysis.interface';
export * as Discovery from './discovery.interface';

// Flatten specific items so you can `import { DiscoveryStatus } from '@/interfaces'`
export { DiscoveryStatus, DiscoveryType } from './discovery.interface';

// NOTE: Removed this because we define JobStatus/JobPriority below.
// export { JobStatus, JobPriority } from './job.interface';

// Import only for typing
import type { Request as ExpressRequest } from 'express';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Utility & Brand Types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export type Brand<K, T extends string> = K & { readonly __brand: T };

export type UUID = Brand<string, 'uuid'>;
export type ISODateTime = Brand<string, 'iso-datetime'>;

export type Maybe<T> = T | null | undefined;
export type Result<T, E = ServiceError> =
  | Readonly<{ ok: true; value: T }>
  | Readonly<{ ok: false; error: E }>;
export type NonEmptyArray<T> = readonly [T, ...T[]];

export type DeepReadonly<T> =
  T extends (...args: any[]) => any ? T :
  T extends Array<infer U> ? ReadonlyArray<DeepReadonly<U>> :
  T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :
  T;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Shared entities & pagination
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export interface BaseEntity {
  readonly id: UUID | string;
  readonly createdAt: Date;
  readonly updatedAt: Date;
  readonly createdBy?: UUID | string;
  readonly updatedBy?: UUID | string;
}

export type SortOrder = 'ASC' | 'DESC';

export interface PaginationParams {
  readonly page?: number;
  readonly limit?: number;
  readonly offset?: number; // (page-1)*limit (server-calculated preferred)
  readonly sortBy?: string;
  readonly sortOrder?: SortOrder;
}

export interface PaginationInfo {
  readonly page: number;
  readonly limit: number;
  readonly total: number;
  readonly totalPages: number;
  readonly hasNext: boolean;
  readonly hasPrev: boolean;
}

export interface PaginationResult<T> {
  readonly data: readonly T[];
  readonly pagination: PaginationInfo;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Filtering / query params
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export interface DateRange {
  readonly from: Date | ISODateTime | string;
  readonly to: Date | ISODateTime | string;
}

export interface FilterParams<F extends Record<string, unknown> = Record<string, unknown>> {
  readonly search?: string;
  readonly filters?: F;
  readonly dateRange?: DateRange;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ApiRequest & Auth
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export enum UserRole {
  SUPER_ADMIN = 'super_admin',
  ADMIN = 'admin',
  DATA_STEWARD = 'data_steward',
  ANALYST = 'analyst',
  VIEWER = 'viewer'
}

export enum Permission {
  // Discovery
  DISCOVERY_READ = 'discovery:read',
  DISCOVERY_WRITE = 'discovery:write',
  DISCOVERY_DELETE = 'discovery:delete',
  // Analysis
  ANALYSIS_READ = 'analysis:read',
  ANALYSIS_WRITE = 'analysis:write',
  ANALYSIS_DELETE = 'analysis:delete',
  // Data source
  DATASOURCE_READ = 'datasource:read',
  DATASOURCE_WRITE = 'datasource:write',
  DATASOURCE_DELETE = 'datasource:delete',
  DATASOURCE_CONNECT = 'datasource:connect',
  // Admin
  USER_MANAGEMENT = 'user:management',
  SYSTEM_CONFIG = 'system:config',
  AUDIT_LOGS = 'audit:logs',
  // AI
  AI_QUERY = 'ai:query',
  AI_TRAINING = 'ai:training'
}

export interface NotificationSettings {
  readonly email: boolean;
  readonly inApp: boolean;
  readonly sms: boolean;
  readonly slack: boolean;
  readonly webhooks: boolean;
}

export interface UserPreferences {
  readonly timezone: string;
  readonly language: string;
  readonly dateFormat: string;
  readonly notifications: NotificationSettings;
}

export interface AuthenticatedUser {
  readonly id: UUID | string;
  readonly email: string;
  readonly role: UserRole;
  readonly permissions: readonly Permission[];
  readonly organizationId?: UUID | string;
  readonly preferences?: UserPreferences;
}

/** Express Request typed with body/params/query plus user */
export type ApiRequest<
  B = unknown,
  P extends Record<string, string> = Record<string, string>,
  Q extends Record<string, unknown> = Record<string, unknown>
> = ExpressRequest<P, any, B, Q> & { user?: AuthenticatedUser };

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Service response envelopes
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export interface ServiceError {
  readonly code: string; // e.g., 'VALIDATION_ERROR', 'DB_TIMEOUT'
  readonly message: string;
  readonly details?: unknown;
  readonly stack?: string; // do not expose in prod
}

export interface ResponseMeta {
  readonly timestamp: ISODateTime | string;
  readonly requestId?: string;
  readonly version: string;
  readonly processingTime?: number; // ms
}

export interface ServiceResponse<T = unknown> {
  readonly success: boolean;
  readonly data?: T;
  readonly message?: string;
  readonly error?: ServiceError;
  readonly meta?: ResponseMeta;
}

/** Generic pagination wrapper using ApiResponse pattern */
export type PaginatedResponse<T> =
  | Readonly<{
      success: true;
      data: { items: readonly T[]; pagination: PaginationInfo };
      message?: string;
      meta?: ResponseMeta;
    }>
  | Readonly<{
      success: false;
      error: ServiceError;
      meta?: ResponseMeta;
    }>;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Health & system info
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export type HealthState = 'healthy' | 'degraded' | 'unhealthy';

export interface HealthCheck {
  readonly name: string;
  readonly status: HealthState;
  readonly responseTime: number;
  readonly details?: unknown;
  readonly error?: string;
}

export interface SystemInfo {
  readonly memory: NodeJS.MemoryUsage;
  readonly cpu: {
    readonly loadAverage: readonly number[];
    readonly usage: number; // your implementation units
  };
  readonly process: {
    readonly pid: number;
    readonly platform: string;
    readonly nodeVersion: string;
  };
}

export interface HealthStatus {
  readonly status: HealthState;
  readonly service: string;
  readonly version: string;
  readonly timestamp: ISODateTime | string;
  readonly uptime: number;
  readonly checks: readonly HealthCheck[];
  readonly system: SystemInfo;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Data sources & connection
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export enum DataSourceType {
  POSTGRESQL = 'postgresql',
  MYSQL = 'mysql',
  SQL_SERVER = 'sql_server',
  ORACLE = 'oracle',
  SNOWFLAKE = 'snowflake',
  BIGQUERY = 'bigquery',
  REDSHIFT = 'redshift',
  MONGODB = 'mongodb',
  CASSANDRA = 'cassandra',
  ELASTICSEARCH = 'elasticsearch'
}

export enum ConnectionStatus {
  CONNECTED = 'connected',
  DISCONNECTED = 'disconnected',
  ERROR = 'error',
  TESTING = 'testing',
  PENDING = 'pending',
  TIMEOUT = 'timeout'
}

export interface ConnectionConfig {
  readonly host?: string;
  readonly port?: number;
  readonly database?: string;
  readonly username?: string;
  readonly password?: string; // encrypted at rest
  readonly ssl?: boolean;
  readonly connectionTimeout?: number;
  readonly queryTimeout?: number;
  readonly poolSize?: number;
  readonly additionalProperties?: Record<string, unknown>;
}

export interface DataSource {
  readonly id: UUID | string;
  readonly name: string;
  readonly type: DataSourceType;
  readonly connectionConfig: ConnectionConfig;
  readonly status: ConnectionStatus;
  readonly lastConnected?: Date;
  readonly tags?: readonly string[];
  readonly description?: string;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Logging / audit / notifications
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export type LogLevel = 'error' | 'warn' | 'info' | 'debug';

export interface LogEntry {
  readonly level: LogLevel;
  readonly message: string;
  readonly timestamp: Date;
  readonly service: string;
  readonly requestId?: string;
  readonly userId?: UUID | string;
  readonly metadata?: Record<string, unknown>;
  readonly stack?: string;
}

export interface AuditLog extends BaseEntity {
  readonly action: string;
  readonly resource: string;
  readonly resourceId?: string;
  readonly userId: UUID | string;
  readonly ipAddress?: string;
  readonly userAgent?: string;
  readonly details?: Record<string, unknown>;
  readonly result: 'success' | 'failure';
}

export enum NotificationType {
  DISCOVERY_COMPLETED = 'discovery_completed',
  ANALYSIS_COMPLETED = 'analysis_completed',
  QUALITY_ALERT = 'quality_alert',
  COMPLIANCE_VIOLATION = 'compliance_violation',
  SYSTEM_ALERT = 'system_alert',
  SECURITY_ALERT = 'security_alert',
  DATA_BREACH = 'data_breach',
  MAINTENANCE = 'maintenance'
}

export enum NotificationChannel {
  EMAIL = 'email',
  IN_APP = 'in_app',
  SMS = 'sms',
  SLACK = 'slack',
  TEAMS = 'teams',
  WEBHOOK = 'webhook',
  PUSH = 'push'
}

export enum NotificationStatus {
  PENDING = 'pending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  READ = 'read',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

export interface Notification extends BaseEntity {
  readonly type: NotificationType;
  readonly title: string;
  readonly message: string;
  readonly userId?: UUID | string;
  readonly organizationId?: UUID | string;
  readonly channel: NotificationChannel;
  readonly status: NotificationStatus;
  readonly scheduledAt?: Date;
  readonly sentAt?: Date;
  readonly metadata?: Record<string, unknown>;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Jobs (defined here; no external file needed)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export enum JobStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled',
  TIMEOUT = 'timeout'
}

export enum JobPriority {
  LOW = 'low',
  NORMAL = 'normal',
  HIGH = 'high',
  CRITICAL = 'critical'
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Events
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export enum EventType {
  USER_LOGIN = 'user_login',
  USER_LOGOUT = 'user_logout',
  DATA_ACCESS = 'data_access',
  DISCOVERY_START = 'discovery_start',
  DISCOVERY_COMPLETE = 'discovery_complete',
  ANALYSIS_START = 'analysis_start',
  ANALYSIS_COMPLETE = 'analysis_complete',
  COMPLIANCE_CHECK = 'compliance_check',
  QUALITY_CHECK = 'quality_check',
  SYSTEM_ERROR = 'system_error',
  SECURITY_EVENT = 'security_event'
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * JSON types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export type JSONValue = string | number | boolean | null | JSONObject | JSONArray;
export type JSONObject = { readonly [key: string]: JSONValue };
export type JSONArray = readonly JSONValue[];

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Forms (UI helpers)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export interface ValidationRule {
  readonly required?: boolean;
  readonly minLength?: number;
  readonly maxLength?: number;
  readonly pattern?: RegExp;
  readonly custom?: (value: unknown) => boolean | string;
}

export interface FormField {
  readonly name: string;
  readonly label: string;
  readonly type: 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'textarea';
  readonly placeholder?: string;
  readonly defaultValue?: unknown;
  readonly options?: ReadonlyArray<{ label: string; value: unknown }>;
  readonly validation?: ValidationRule;
  readonly disabled?: boolean;
  readonly required?: boolean;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Configuration
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export interface DatabaseConfig {
  readonly host: string;
  readonly port: number;
  readonly database: string;
  readonly username: string;
  readonly password: string;
  readonly ssl: boolean;
  readonly poolMin: number;
  readonly poolMax: number;
  readonly timeout: number;
}

export interface RedisConfig {
  readonly host: string;
  readonly port: number;
  readonly password?: string;
  readonly db: number;
  readonly ttl: number;
}

export interface AIConfig {
  readonly provider: 'openai' | 'azure' | 'anthropic';
  readonly apiKey: string;
  readonly model: string;
  readonly maxTokens: number;
  readonly temperature: number;
  readonly timeout: number;
}

export interface SecurityConfig {
  readonly jwtSecret: string;
  readonly jwtExpiry: string;
  readonly bcryptRounds: number;
  readonly rateLimitWindow: number;
  readonly rateLimitMax: number;
  readonly corsOrigins: readonly string[];
}

export interface MonitoringConfig {
  readonly enabled: boolean;
  readonly metricsPort: number;
  readonly healthCheckInterval: number;
  readonly logLevel: LogLevel;
  readonly logRetention: number;
}

export interface ServiceConfig {
  readonly name: string;
  readonly version: string;
  readonly environment: string;
  readonly port: number;
  readonly database: DatabaseConfig;
  readonly redis: RedisConfig;
  readonly ai: AIConfig;
  readonly security: SecurityConfig;
  readonly monitoring: MonitoringConfig;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Friendly named export aliases
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export type {
  AIConfig as TAIConfig,
  DatabaseConfig as TDatabaseConfig,
  FormField as TFormField,
  ISODateTime as TISODateTime,
  JSONArray as TJSONArray,
  JSONObject as TJSONObject,
  JSONValue as TJSONValue,
  MonitoringConfig as TMonitoringConfig,
  PaginatedResponse as TPaginatedResponse,
  RedisConfig as TRedisConfig,
  SecurityConfig as TSecurityConfig,
  ServiceConfig as TServiceConfig,
  UUID as TUUID
};

// Re-export ApiResponse type from utils (type-only to avoid runtime deps)
  export type { ApiResponse } from '../utils/responses';




------------------------------------------------------------
FILE: backend\ai-service\src\jobs\analysisJob.ts
------------------------------------------------------------
// src/jobs/analysisJob.ts
import { db } from '@/config/database';
import { redis } from '@/config/redis';
import { JobPriority, JobStatus } from '@/interfaces';
import { AnalysisService } from '@/services/AnalysisService';
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

type AnalysisKind = 'schema' | 'data_quality' | 'compliance' | 'performance';

export interface AnalysisJobData {
  analysisId: string;
  userId: string;
  dataSourceId: string;
  analysisType: AnalysisKind;
  options?: SchemaOptions | QualityOptions | ComplianceOptions | PerformanceOptions;
  priority: JobPriority;
  retryCount?: number;
  maxRetries?: number;
}

export interface AnalysisJobResult {
  analysisId: string;
  status: JobStatus;
  result?: SchemaResult | QualityResult | ComplianceResult | PerformanceResult;
  error?: string;
  duration: number;
  completedAt: Date;
}

/** Per-type options */
export interface SchemaOptions {
  schemas?: string[];
  includeSystem?: boolean;
}
export interface QualityOptions {
  sampleSize?: number; // rows per column/table
}
export interface ComplianceOptions {
  frameworks?: Array<'GDPR' | 'HIPAA' | 'PCI-DSS' | 'SOX' | 'CCPA' | 'ISO27001' | 'NIST' | 'SOC2'>;
}
export interface PerformanceOptions {
  timeWindowMinutes?: number;
}

/** Public result contracts (mutable arrays) */
export interface SchemaResult {
  name: string;
  tables: Array<{
    schema: string;
    name: string;
    columns: Array<{ name: string; type: string; nullable: boolean }>;
  }>;
}
export interface QualityResult {
  issues: Array<{ columnName: string; type: 'format' | 'range' | 'nulls'; count: number }>;
  scores: Record<string, number>;
}
export interface ComplianceResult {
  passed: boolean;
  violations: Array<{ id: string; framework: string; description: string }>;
}
export interface PerformanceResult {
  windowMinutes: number;
  queryPerformance: {
    avgQueryTime: number;
    slowQueries: string[];
    queryPatterns: string[];
    resourceUtilization: {
      cpuUsage: number;
      memoryUsage: number;
      ioWait: number;
      connectionCount: number;
    };
  };
  recommendations: Array<{
    type: string;
    description: string;
    impact: 'Low' | 'Medium' | 'High';
    effort: 'Low' | 'Medium' | 'High';
    implementation?: string;
  }>;
}

/** DataSource rows we actually use */
interface DataSource {
  id: string;
  name: string;
  type?: string;
  config?: unknown;
}

/* Shapes coming back from services (loose, then normalized) */
type SchemaAnalysisResult = {
  name?: unknown;
  tables?: ReadonlyArray<{
    schema?: unknown;
    name?: unknown;
    columns?: ReadonlyArray<{
      name?: unknown;
      type?: unknown;
      nullable?: unknown;
    }>;
  }>;
};

type AnalyzeDataSampleResponse = {
  qualityIssues?: ReadonlyArray<{ columnName?: unknown; type?: unknown; count?: unknown }>;
  analysis?: Record<string, unknown> | ReadonlyArray<Record<string, unknown>>;
};

type QualityCheckResult = {
  results?: ReadonlyArray<{
    ruleId?: unknown;
    ruleName?: unknown;
    status?: unknown;
  }>;
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Config
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const DEFAULT_MAX_RETRIES = 3;
const BASE_RETRY_DELAY_MS = 5_000; // 5s
const MAX_RETRY_DELAY_MS = 60_000; // 60s cap
const REDIS_STATUS_TTL_SEC = 300; // 5m

/** Where we check for a cancel flag (optional) */
const CANCEL_KEY = (analysisId: string) => `analysis:cancel:${analysisId}`;
const STATUS_KEY = (analysisId: string) => `analysis:status:${analysisId}`;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Utility helpers
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function assertNever(x: never): never {
  throw new APIError(`Unsupported analysis type: ${String(x)}`, 400);
}

const backoffWithJitter = (attempt: number) => {
  const exp = Math.min(BASE_RETRY_DELAY_MS * Math.pow(2, attempt - 1), MAX_RETRY_DELAY_MS);
  const jitter = Math.floor(Math.random() * Math.min(1000, Math.floor(exp * 0.1))); // up to 10% jitter, max 1s
  return exp + jitter;
};

/** Keep log payloads small to avoid huge log lines */
const safeLogSize = (value: unknown, max = 4_096) => {
  try {
    const s = JSON.stringify(value);
    return s.length <= max ? s : s.slice(0, max) + `â€¦ (truncated ${s.length - max} chars)`;
  } catch {
    return '[unserializable]';
  }
};

/** Heuristic transient error classifier for retries */
const isTransientError = (err: unknown): boolean => {
  const anyErr = err as { message?: string; code?: string } | undefined;
  const msg = (anyErr?.message ?? '').toLowerCase();
  const code = anyErr?.code ?? '';
  return (
    code === 'ETIMEDOUT' ||
    code === 'ECONNRESET' ||
    code === 'ECONNREFUSED' ||
    msg.includes('timeout') ||
    msg.includes('deadlock') ||
    msg.includes('connection') ||
    msg.includes('too many connections') ||
    msg.includes('rate limit') ||
    msg.includes('temporarily') ||
    msg.includes('try again')
  );
};

/** Build a parameterized UPDATE statement dynamically and safely */
const buildUpdateQuery = (
  table: string,
  whereClause: string,
  whereParams: unknown[],
  data: Record<string, unknown>
) => {
  const keys = Object.keys(data);
  const setFragments = keys.map((k, i) => `${k} = $${i + whereParams.length + 1}`);
  const values = [...whereParams, ...keys.map((k) => data[k])];
  const text = `UPDATE ${table} SET ${setFragments.join(', ')} ${whereClause}`;
  return { text, values };
};

/** Deep clone a readonly schema array to a mutable one */
function cloneTablesToMutable(
  tables: ReadonlyArray<{
    schema?: unknown;
    name?: unknown;
    columns?: ReadonlyArray<{ name?: unknown; type?: unknown; nullable?: unknown }>;
  }>
): SchemaResult['tables'] {
  return tables.map((t) => ({
    schema: typeof t?.schema === 'string' ? t.schema : 'public',
    name: typeof t?.name === 'string' ? t.name : 'unknown',
    columns: Array.isArray(t?.columns)
      ? t.columns.map((c) => ({
          name: typeof c?.name === 'string' ? c.name : 'unknown',
          type: typeof c?.type === 'string' ? c.type : 'text',
          nullable: typeof c?.nullable === 'boolean' ? c.nullable : true
        }))
      : []
  }));
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Job executor
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export class AnalysisJob {
  private readonly analysisService: AnalysisService;
  private readonly maxRetries = DEFAULT_MAX_RETRIES;

  constructor() {
    this.analysisService = new AnalysisService();
  }

  public async execute(data: AnalysisJobData): Promise<AnalysisJobResult> {
    const start = Date.now();
    const { analysisId, userId, dataSourceId, analysisType, options } = data;

    try {
      logger.info('Analysis job: start', {
        analysisId,
        userId,
        dataSourceId,
        analysisType,
        priority: data.priority,
        retryCount: data.retryCount ?? 0
      });

      await this.updateJobStatus(analysisId, JobStatus.RUNNING);
      await this.validateJobData(data);

      if (await this.isCancelled(analysisId)) {
        throw new APIError('Job cancelled', 499);
      }

      let result: SchemaResult | QualityResult | ComplianceResult | PerformanceResult;

      switch (analysisType) {
        case 'schema':
          result = await this.executeSchemaAnalysis(
            dataSourceId,
            (options as SchemaOptions | undefined) ?? undefined,
            userId
          );
          break;
        case 'data_quality':
          result = await this.executeQualityAnalysis(
            dataSourceId,
            (options as QualityOptions | undefined) ?? undefined,
            userId
          );
          break;
        case 'compliance':
          result = await this.executeComplianceAnalysis(
            dataSourceId,
            (options as ComplianceOptions | undefined) ?? undefined,
            userId
          );
          break;
        case 'performance':
          result = await this.executePerformanceAnalysis(
            dataSourceId,
            (options as PerformanceOptions | undefined) ?? undefined,
            userId
          );
          break;
        default:
          return assertNever(analysisType as never);
      }

      await this.updateJobStatus(analysisId, JobStatus.COMPLETED, result);
      await this.storeAnalysisResult(analysisId, result);
      await this.sendCompletionNotification(userId, analysisId, analysisType, true);

      const duration = Date.now() - start;
      logger.info('Analysis job: completed', {
        analysisId,
        durationMs: duration,
        resultPreview: safeLogSize(result)
      });

      return { analysisId, status: JobStatus.COMPLETED, result, duration, completedAt: new Date() };
    } catch (err) {
      const anyErr = err as { message?: string } | undefined;
      const duration = Date.now() - start;

      logger.error('Analysis job: failed', {
        analysisId,
        durationMs: duration,
        error: anyErr?.message,
        retryCount: data.retryCount ?? 0
      });

      if (await this.shouldRetryJob(data, err)) {
        return this.scheduleRetry(data);
      }

      await this.updateJobStatus(analysisId, JobStatus.FAILED, undefined, anyErr?.message);
      await this.sendCompletionNotification(userId, analysisId, analysisType, false, anyErr?.message);

      return { analysisId, status: JobStatus.FAILED, error: anyErr?.message ?? 'failed', duration, completedAt: new Date() };
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Per-type handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async executeSchemaAnalysis(
    dataSourceId: string,
    _options: SchemaOptions | undefined,
    userId: string
  ): Promise<SchemaResult> {
    try {
      const dataSource = await this.getDataSource(dataSourceId);
      if (!dataSource) throw new APIError('Data source not found', 404);

      // Baseline candidate
      const schemaCandidate = {
        name: String(dataSource.name ?? 'unknown'),
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              { name: 'id', type: 'integer', nullable: false },
              { name: 'email', type: 'varchar', nullable: false },
              { name: 'first_name', type: 'varchar', nullable: true },
              { name: 'last_name', type: 'varchar', nullable: true },
              { name: 'created_at', type: 'timestamp', nullable: false }
            ]
          }
        ] as const
      } as const;

      // Call service; cast via unknown first (TS suggestion) then narrow with our loose type
      const analyzed = (await this.analysisService.analyzeSchema(
        { name: schemaCandidate.name, tables: schemaCandidate.tables },
        userId
      )) as unknown as SchemaAnalysisResult;

      const name =
        typeof analyzed?.name === 'string' ? analyzed.name : schemaCandidate.name;

      let tables: SchemaResult['tables'];
      if (Array.isArray(analyzed?.tables)) {
        tables = cloneTablesToMutable(analyzed.tables);
      } else {
        // clone readonly candidate â†’ mutable
        tables = cloneTablesToMutable(schemaCandidate.tables);
      }

      return { name, tables };
    } catch (err) {
      logger.error('Schema analysis failed', {
        dataSourceId,
        error: (err as { message?: string } | undefined)?.message
      });
      throw err;
    }
  }

  private async executeQualityAnalysis(
    _dataSourceId: string,
    options: QualityOptions | undefined,
    userId: string
  ): Promise<QualityResult> {
    try {
      const sampleSize = Math.max(1, Math.min(options?.sampleSize ?? 100, 10_000));

      const dataSamples = [
        { columnName: 'email', values: ['user1@example.com', 'user2@example.com', 'invalid-email', null] },
        { columnName: 'age', values: [25, 30, -5, 150, null, 28] }
      ].map((c) => ({ ...c, values: c.values.slice(0, sampleSize) }));

      const serviceRes = (await this.analysisService.analyzeDataSample(
        dataSamples,
        userId
      )) as unknown as AnalyzeDataSampleResponse;

      const issues: QualityResult['issues'] = Array.isArray(serviceRes?.qualityIssues)
        ? serviceRes.qualityIssues.map((q) => ({
            columnName: typeof q?.columnName === 'string' ? q.columnName : 'unknown',
            type:
              q?.type === 'format' || q?.type === 'range' || q?.type === 'nulls'
                ? q.type
                : ('format' as const),
            count: Number.isFinite(q?.count as number) ? Number(q!.count) : 0
          }))
        : [];

      const scores: Record<string, number> = {};
      const a = serviceRes?.analysis;

      if (a && !Array.isArray(a)) {
        for (const [k, v] of Object.entries(a)) {
          scores[k] = typeof v === 'number' && Number.isFinite(v) ? v : 0;
        }
      } else if (Array.isArray(a)) {
        a.forEach((row, idx) => {
          for (const [k, v] of Object.entries(row)) {
            const key = `${k}#${idx}`;
            scores[key] = typeof v === 'number' && Number.isFinite(v) ? v : 0;
          }
        });
      }

      return { issues, scores };
    } catch (err) {
      logger.error('Quality analysis failed', { error: (err as { message?: string } | undefined)?.message });
      throw err;
    }
  }

  private async executeComplianceAnalysis(
    dataSourceId: string,
    options: ComplianceOptions | undefined,
    userId: string
  ): Promise<ComplianceResult> {
    try {
      const frameworks = (options?.frameworks?.length ? options.frameworks : ['GDPR', 'HIPAA']) as readonly string[];

      const rules = [
        { id: 'gdpr_1', name: 'PII Data Encryption', framework: 'GDPR' },
        { id: 'hipaa_1', name: 'PHI Access Controls', framework: 'HIPAA' }
      ].filter((r) => frameworks.includes(r.framework));

      const serviceRes = (await this.analysisService.performQualityCheck(
        dataSourceId,
        rules,
        userId
      )) as unknown as QualityCheckResult;

      const violations: ComplianceResult['violations'] = Array.isArray(serviceRes?.results)
        ? serviceRes.results
            .filter((r) => r?.status === 'failed')
            .map((r) => ({
              id: typeof r?.ruleId === 'string' ? r.ruleId : 'unknown',
              framework: String(rules.find((x) => x.id === r?.ruleId)?.framework ?? 'Unknown'),
              description: typeof r?.ruleName === 'string' ? r.ruleName : 'Violation detected'
            }))
        : [];

      const passed = violations.length === 0;
      return { passed, violations };
    } catch (err) {
      logger.error('Compliance analysis failed', {
        dataSourceId,
        error: (err as { message?: string } | undefined)?.message
      });
      throw err;
    }
  }

  private async executePerformanceAnalysis(
    _dataSourceId: string,
    options: PerformanceOptions | undefined,
    _userId: string
  ): Promise<PerformanceResult> {
    try {
      const windowMins = Math.max(1, Math.min(options?.timeWindowMinutes ?? 15, 1440));

      const result: PerformanceResult = {
        windowMinutes: windowMins,
        queryPerformance: {
          avgQueryTime: 250,
          slowQueries: [],
          queryPatterns: [],
          resourceUtilization: { cpuUsage: 45, memoryUsage: 60, ioWait: 5, connectionCount: 15 }
        },
        recommendations: [
          {
            type: 'Index',
            description: 'Add index on frequently queried columns',
            impact: 'High',
            effort: 'Low',
            implementation: 'CREATE INDEX idx_user_email ON users(email);'
          }
        ]
      };

      return result;
    } catch (err) {
      logger.error('Performance analysis failed', { error: (err as { message?: string } | undefined)?.message });
      throw err;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async validateJobData(d: AnalysisJobData): Promise<void> {
    if (!d.analysisId) throw new APIError('Analysis ID is required', 400);
    if (!d.userId) throw new APIError('User ID is required', 400);
    if (!d.dataSourceId) throw new APIError('Data source ID is required', 400);

    const validTypes: AnalysisKind[] = ['schema', 'data_quality', 'compliance', 'performance'];
    if (!validTypes.includes(d.analysisType)) throw new APIError('Invalid analysis type', 400);

    const ds = await this.getDataSource(d.dataSourceId);
    if (!ds) throw new APIError('Data source not found', 404);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async updateJobStatus(
    analysisId: string,
    status: JobStatus,
    result?: unknown,
    error?: string
  ): Promise<void> {
    try {
      const data: Record<string, unknown> = { status, updated_at: new Date() };
      if (result !== undefined) data.results = JSON.stringify(result);
      if (error !== undefined) data.error = error;
      if (status === JobStatus.COMPLETED || status === JobStatus.FAILED) data.completed_at = new Date();

      const { text, values } = buildUpdateQuery('analysis_jobs', 'WHERE analysis_id = $1', [analysisId], data);
      await db.query(text, values);

      await (redis as any).set?.(
        STATUS_KEY(analysisId),
        JSON.stringify({ status, updated_at: Date.now() }),
        { EX: REDIS_STATUS_TTL_SEC }
      );
    } catch (err) {
      logger.error('Job status update failed', {
        analysisId,
        status,
        error: (err as { message?: string } | undefined)?.message
      });
    }
  }

  private async storeAnalysisResult(analysisId: string, result: unknown): Promise<void> {
    try {
      const resultStr = JSON.stringify(result);
      await db.query(
        `UPDATE analysis_jobs 
           SET results = $2, result_size = $3, completed_at = NOW()
         WHERE analysis_id = $1`,
        [analysisId, resultStr, resultStr.length]
      );

      await db.query(
        `INSERT INTO analysis_results (analysis_id, result_data, created_at)
         VALUES ($1, $2, NOW())
         ON CONFLICT (analysis_id) DO UPDATE SET
           result_data = EXCLUDED.result_data,
           updated_at = NOW()`,
        [analysisId, resultStr]
      );
    } catch (err) {
      logger.error('Persisting result failed', {
        analysisId,
        error: (err as { message?: string } | undefined)?.message
      });
      throw err;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Retry & Cancel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async shouldRetryJob(data: AnalysisJobData, err: unknown): Promise<boolean> {
    const retryCount = data.retryCount ?? 0;
    const maxRetries = data.maxRetries ?? this.maxRetries;

    if (err instanceof APIError && err.statusCode >= 400 && err.statusCode < 500) return false;

    const anyErr = err as { statusCode?: number } | undefined;
    if (anyErr?.statusCode === 499 || (await this.isCancelled(data.analysisId))) return false;

    if (retryCount >= maxRetries) return false;

    return isTransientError(err);
  }

  private async scheduleRetry(data: AnalysisJobData): Promise<AnalysisJobResult> {
    const retryCount = (data.retryCount ?? 0) + 1;
    const delay = backoffWithJitter(retryCount);

    logger.info('Analysis job: scheduling retry', {
      analysisId: data.analysisId,
      retryCount,
      delayMs: delay
    });

    const retryData: AnalysisJobData = { ...data, retryCount };

    setTimeout(async () => {
      try {
        if (await this.isCancelled(retryData.analysisId)) {
          await this.updateJobStatus(retryData.analysisId, JobStatus.FAILED, undefined, 'Job cancelled');
          return;
        }
        await this.execute(retryData);
      } catch (err) {
        logger.error('Retry execution failed', {
          analysisId: retryData.analysisId,
          error: (err as { message?: string } | undefined)?.message
        });
      }
    }, delay);

    return {
      analysisId: data.analysisId,
      status: JobStatus.PENDING,
      duration: 0,
      completedAt: new Date()
    };
  }

  private async isCancelled(analysisId: string): Promise<boolean> {
    try {
      const val = await (redis as any).get?.(CANCEL_KEY(analysisId));
      return val === '1' || val === 'true';
    } catch {
      return false;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async sendCompletionNotification(
    userId: string,
    analysisId: string,
    analysisType: string,
    success: boolean,
    error?: string
  ): Promise<void> {
    try {
      const metadata = { analysisId, analysisType, success };
      const type = success ? 'analysis_completed' : 'analysis_failed';
      const title = success ? 'Analysis Completed' : 'Analysis Failed';
      const message = success
        ? `Your ${analysisType} analysis has completed successfully.`
        : `Your ${analysisType} analysis failed: ${error ?? 'unknown error'}`;

      await db.query(
        `INSERT INTO notifications (user_id, type, title, message, metadata, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW())`,
        [userId, type, title, message, JSON.stringify(metadata)]
      );
    } catch (err) {
      logger.error('Notification emit failed', {
        userId,
        analysisId,
        error: (err as { message?: string } | undefined)?.message
      });
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Lookups & Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async getDataSource(dataSourceId: string): Promise<DataSource | null> {
    try {
      const result = await db.query(
        'SELECT id, name, type, config FROM data_sources WHERE id = $1',
        [dataSourceId]
      );
      const row = result.rows[0];
      if (!row) return null;

      // exactOptionalPropertyTypes-safe construction
      const dsBase: { id: string; name: string } = {
        id: String(row.id),
        name: String(row.name)
      };
      const ds: DataSource = {
        ...dsBase,
        ...(row.type !== undefined && row.type !== null ? { type: String(row.type) } : {}),
        ...(row.config !== undefined ? { config: row.config } : {})
      };

      return ds;
    } catch (err) {
      logger.error('Data source lookup failed', {
        dataSourceId,
        error: (err as { message?: string } | undefined)?.message
      });
      throw err;
    }
  }

  public async cleanup(analysisId: string): Promise<void> {
    try {
      await (redis as any).del?.(STATUS_KEY(analysisId));
      logger.debug('Job cleanup completed', { analysisId });
    } catch (err) {
      logger.error('Job cleanup failed', {
        analysisId,
        error: (err as { message?: string } | undefined)?.message
      });
    }
  }
}

/* Singleton export */
export const analysisJob = new AnalysisJob();



------------------------------------------------------------
FILE: backend\ai-service\src\jobs\discoveryJob.ts
------------------------------------------------------------
import { db } from '@/config/database';
import { redis } from '@/config/redis';
import { DiscoveryStatus, JobPriority, JobStatus } from '@/interfaces';
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

type DiscoveryKind = 'full' | 'incremental' | 'targeted';

export interface DiscoveryJobData {
  sessionId: string;
  userId: string;
  dataSourceId: string;
  discoveryType: DiscoveryKind;
  options?: DiscoveryOptions;
  priority: JobPriority;
  retryCount?: number;
  maxRetries?: number;
}

export interface DiscoveryJobResult {
  sessionId: string;
  status: JobStatus;
  result?: DiscoveryResults;
  error?: string;
  duration: number;
  completedAt: Date;
}

/** Tighten options you actually use */
export interface DiscoveryOptions {
  includeSampleData?: boolean;
  sampleSize?: number;
  aiAnalysis?: boolean; // default true
  schemas?: string[];
  tables?: string[];
}

/** Minimal result shape; swap with your domain interfaces if you prefer */
export interface DiscoveryResults {
  metadata: any;         // replace with Discovery.DataSourceMetadata if wired
  classification: any;   // replace with Discovery.ClassificationResults
  aiInsights?: any;      // replace with Discovery.AIInsights
  summary: any;          // replace with Discovery.DiscoverySummary
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Config & Keys
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const DEFAULT_MAX_RETRIES = 3;
const BASE_RETRY_DELAY_MS = 5_000;
const MAX_RETRY_DELAY_MS = 60_000;
const REDIS_STATUS_TTL_SEC = 300;

const STATUS_KEY = (sessionId: string) => `discovery:status:${sessionId}`;
const CANCEL_KEY = (sessionId: string) => `discovery:cancel:${sessionId}`;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Utils
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const backoffWithJitter = (attempt: number) => {
  const exp = Math.min(BASE_RETRY_DELAY_MS * Math.pow(2, attempt - 1), MAX_RETRY_DELAY_MS);
  const jitter = Math.floor(Math.random() * Math.min(1000, exp * 0.1));
  return exp + jitter;
};

const safeLogSize = (val: unknown, max = 4096) => {
  try {
    const s = JSON.stringify(val);
    return s.length <= max ? s : s.slice(0, max) + `â€¦ (truncated ${s.length - max} chars)`;
  } catch {
    return '[unserializable]';
  }
};

const isTransientError = (err: unknown): boolean => {
  const msg = (err as any)?.message?.toLowerCase?.() || '';
  const code = (err as any)?.code || '';
  return (
    code === 'ETIMEDOUT' ||
    code === 'ECONNRESET' ||
    code === 'ECONNREFUSED' ||
    msg.includes('timeout') ||
    msg.includes('connection') ||
    msg.includes('deadlock') ||
    msg.includes('too many connections') ||
    msg.includes('rate limit') ||
    msg.includes('temporarily') ||
    msg.includes('try again')
  );
};

/** Parameterized UPDATE builder to avoid index mistakes */
const buildUpdateQuery = (table: string, whereClause: string, whereParams: unknown[], data: Record<string, unknown>) => {
  const keys = Object.keys(data);
  const setFragments = keys.map((k, i) => `${k} = $${i + whereParams.length + 1}`);
  const values = [...whereParams, ...keys.map(k => data[k])];
  const text = `UPDATE ${table} SET ${setFragments.join(', ')} ${whereClause}`;
  return { text, values };
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Job
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export class DiscoveryJob {
  private maxRetries = DEFAULT_MAX_RETRIES;

  constructor() {}

  public async execute(data: DiscoveryJobData): Promise<DiscoveryJobResult> {
    const started = Date.now();
    const { sessionId, userId, dataSourceId, discoveryType, options } = data;

    try {
      logger.info('Discovery job: start', {
        sessionId, userId, dataSourceId, discoveryType, priority: data.priority, retryCount: data.retryCount ?? 0,
      });

      await this.updateJobStatus(sessionId, DiscoveryStatus.INITIALIZING, 0);

      await this.validateJobData(data);

      // Respect cancellation early
      if (await this.isCancelled(sessionId)) {
        throw new APIError('Job cancelled', 499);
      }

      const result = await this.executeDiscoveryPhases(data);

      await this.updateJobStatus(sessionId, DiscoveryStatus.COMPLETED, 100, result);

      await this.sendCompletionNotification(userId, sessionId, discoveryType, true);

      const duration = Date.now() - started;
      logger.info('Discovery job: completed', {
        sessionId,
        durationMs: duration,
        resultPreview: safeLogSize({
          summary: result?.summary,
          metadata: { totalTables: result?.metadata?.totalTables, totalColumns: result?.metadata?.totalColumns },
        })
      });

      return {
        sessionId,
        status: JobStatus.COMPLETED,
        result,
        duration,
        completedAt: new Date(),
      };
    } catch (err: any) {
      const duration = Date.now() - started;
      logger.error('Discovery job: failed', {
        sessionId,
        durationMs: duration,
        error: err?.message,
        retryCount: data.retryCount ?? 0,
      });

      if (await this.shouldRetryJob(data, err)) {
        return this.scheduleRetry(data);
      }

      await this.updateJobStatus(sessionId, DiscoveryStatus.FAILED, 0, undefined, err?.message);
      await this.sendCompletionNotification(userId, sessionId, discoveryType, false, err?.message);

      return {
        sessionId,
        status: JobStatus.FAILED,
        error: err?.message ?? 'failed',
        duration,
        completedAt: new Date(),
      };
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async executeDiscoveryPhases(data: DiscoveryJobData): Promise<DiscoveryResults> {
    const { sessionId, dataSourceId, options } = data;
    let progress = 0;

    try {
      // Phase 1: metadata
      await this.updateJobStatus(sessionId, DiscoveryStatus.SCANNING_METADATA, 10);
      const metadata = await this.scanMetadata(dataSourceId, options);
      progress = 20;
      await this.updateJobStatus(sessionId, DiscoveryStatus.SCANNING_METADATA, progress);

      // Phase 2: sampling
      if (options?.includeSampleData) {
        await this.updateJobStatus(sessionId, DiscoveryStatus.SAMPLING_DATA, progress);
        const sampleData = await this.sampleData(dataSourceId, metadata, options);
        (metadata as any).sampleData = sampleData;
        progress = 40;
        await this.updateJobStatus(sessionId, DiscoveryStatus.SAMPLING_DATA, progress);
      }

      // Phase 3: classification
      await this.updateJobStatus(sessionId, DiscoveryStatus.CLASSIFYING, progress);
      const classification = await this.classifyData(metadata, options);
      progress = 60;
      await this.updateJobStatus(sessionId, DiscoveryStatus.CLASSIFYING, progress);

      // Phase 4: AI analysis (default on)
      let aiInsights: unknown | undefined;
      if (options?.aiAnalysis !== false) {
        await this.updateJobStatus(sessionId, DiscoveryStatus.AI_ANALYSIS, progress);
        aiInsights = await this.performAIAnalysis(metadata, classification);
        progress = 80;
        await this.updateJobStatus(sessionId, DiscoveryStatus.AI_ANALYSIS, progress);
      }

      const summary = this.generateSummary(metadata, classification, aiInsights);

      return { metadata, classification, aiInsights, summary };
    } catch (err) {
      logger.error('Discovery phases: error', { sessionId, progress, error: (err as any)?.message });
      throw err;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Implementations (mocked) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async scanMetadata(dataSourceId: string, _options?: DiscoveryOptions): Promise<any> {
    void _options;
    const dataSource = await this.getDataSource(dataSourceId);
    if (!dataSource) throw new APIError('Data source not found', 404);

    // Replace this mock with real extractor when ready
    const metadata = {
      dataSourceId,
      connectionInfo: {
        type: (dataSource as any).type,
        host: (dataSource as any).connectionConfig?.host,
        database: (dataSource as any).connectionConfig?.database,
        version: '14.5',
      },
      schemas: [
        {
          name: 'public',
          tables: [
            {
              schema: 'public',
              name: 'users',
              type: 'table',
              columns: [
                { name: 'id', dataType: 'integer', nullable: false, isPrimaryKey: true },
                { name: 'email', dataType: 'varchar', nullable: false },
                { name: 'first_name', dataType: 'varchar', nullable: true },
                { name: 'last_name', dataType: 'varchar', nullable: true },
                { name: 'phone', dataType: 'varchar', nullable: true },
                { name: 'date_of_birth', dataType: 'date', nullable: true },
                { name: 'created_at', dataType: 'timestamp', nullable: false },
              ],
              primaryKeys: ['id'],
              foreignKeys: [],
              indexes: [
                { name: 'users_pkey', columns: ['id'], unique: true },
                { name: 'users_email_idx', columns: ['email'], unique: true },
              ],
              rowCount: 15_000,
              sizeBytes: 2_048_000,
            },
            {
              schema: 'public',
              name: 'orders',
              type: 'table',
              columns: [
                { name: 'id', dataType: 'integer', nullable: false, isPrimaryKey: true },
                { name: 'user_id', dataType: 'integer', nullable: false, isForeignKey: true },
                { name: 'total_amount', dataType: 'decimal', nullable: false },
                { name: 'status', dataType: 'varchar', nullable: false },
                { name: 'created_at', dataType: 'timestamp', nullable: false },
              ],
              primaryKeys: ['id'],
              foreignKeys: [
                { name: 'fk_orders_user', columns: ['user_id'], referencedTable: 'users', referencedColumns: ['id'] },
              ],
              indexes: [
                { name: 'orders_pkey', columns: ['id'], unique: true },
                { name: 'orders_user_id_idx', columns: ['user_id'], unique: false },
              ],
              rowCount: 45_000,
              sizeBytes: 3_072_000,
            },
          ],
          views: [],
          procedures: [],
        },
      ],
      totalTables: 2,
      totalColumns: 12,
      totalRows: 60_000,
      dataSize: 5_120_000,
      lastUpdated: new Date(),
    };

    return metadata;
  }

  private async sampleData(_dataSourceId: string, _metadata: any, options?: DiscoveryOptions): Promise<any> {
    void _metadata;
    const size = Math.max(1, Math.min(options?.sampleSize ?? 100, 10_000));
    void size; // for now
    return {
      'public.users': [
        { id: 1, email: 'john.doe@example.com', first_name: 'John', last_name: 'Doe', phone: '+1-555-0123', date_of_birth: '1990-05-15' },
        { id: 2, email: 'jane.smith@example.com', first_name: 'Jane', last_name: 'Smith', phone: '+1-555-0124', date_of_birth: '1985-12-08' },
        { id: 3, email: 'invalid-email', first_name: 'Bob', last_name: 'Johnson', phone: '555-0125', date_of_birth: '1992-03-22' },
      ],
      'public.orders': [
        { id: 1, user_id: 1, total_amount: 99.99, status: 'completed', created_at: '2024-01-15T10:30:00Z' },
        { id: 2, user_id: 2, total_amount: 149.50, status: 'pending', created_at: '2024-01-16T14:20:00Z' },
        { id: 3, user_id: 1, total_amount: -10.00, status: 'refunded', created_at: '2024-01-17T09:15:00Z' },
      ],
    };
  }

  private async classifyData(metadata: any, _options?: DiscoveryOptions): Promise<any> {
    void _options;
    const fieldClassifications: any[] = [];
    const tableClassifications: any[] = [];

    const piiPatterns = ['email', 'phone', 'ssn', 'social_security', 'first_name', 'last_name', 'full_name'];
    const phiPatterns = ['medical', 'health', 'diagnosis', 'patient', 'dob', 'date_of_birth'];
    const finPatterns = ['credit_card', 'bank_account', 'salary', 'income', 'total_amount', 'price'];

    for (const schema of metadata.schemas) {
      for (const table of schema.tables) {
        let hasPII = false; let hasPHI = false; let hasFIN = false;

        for (const col of table.columns) {
          const name = String(col.name).toLowerCase();
          let classification = 'General';
          let sensitivity = 'Low';
          let confidence = 0.7;
          const patterns: string[] = [];
          const tags: string[] = [];
          const complianceFlags: any[] = [];

          if (piiPatterns.some(p => name.includes(p))) {
            classification = 'PII';
            sensitivity = name.includes('ssn') ? 'High' : 'Medium';
            confidence = 0.9;
            patterns.push('PII identifier pattern');
            tags.push('personal_data');
            complianceFlags.push({ framework: 'GDPR', requirement: 'Data subject rights', severity: 'Warning' });
            hasPII = true;
          } else if (phiPatterns.some(p => name.includes(p))) {
            classification = 'PHI';
            sensitivity = 'High';
            confidence = 0.9;
            patterns.push('PHI identifier pattern');
            tags.push('health_data');
            complianceFlags.push({ framework: 'HIPAA', requirement: 'PHI protection', severity: 'Error' });
            hasPHI = true;
          } else if (finPatterns.some(p => name.includes(p))) {
            classification = 'Financial';
            sensitivity = 'Medium';
            confidence = 0.8;
            patterns.push('Financial data pattern');
            tags.push('financial_data');
            complianceFlags.push({ framework: 'PCI-DSS', requirement: 'Payment data security', severity: 'Warning' });
            hasFIN = true;
          }

          fieldClassifications.push({
            schema: schema.name,
            table: table.name,
            column: col.name,
            dataType: col.dataType,
            classification,
            sensitivity,
            confidence,
            patterns,
            tags,
            complianceFlags,
          });
        }

        let overallClassification = 'General';
        let overallSensitivity = 'Low';
        if (hasPHI) { overallClassification = 'PHI'; overallSensitivity = 'High'; }
        else if (hasPII) { overallClassification = 'PII'; overallSensitivity = 'Medium'; }
        else if (hasFIN) { overallClassification = 'Financial'; overallSensitivity = 'Medium'; }

        tableClassifications.push({
          schema: schema.name,
          table: table.name,
          overallClassification,
          overallSensitivity,
          dataVolume: table.rowCount > 100_000 ? 'Large' : table.rowCount > 10_000 ? 'Medium' : 'Small',
          businessCriticality: 'Medium',
          accessFrequency: 'Regular',
          retentionCategory: 'Standard',
          complianceScope: this.getComplianceScope(overallClassification),
        });
      }
    }

    return {
      fieldClassifications,
      tableClassifications,
      sensitivityMap: this.createSensitivityMap(fieldClassifications),
      complianceMapping: this.createComplianceMapping(fieldClassifications),
      riskAssessment: this.assessRisk(fieldClassifications, tableClassifications),
    };
  }

  private async performAIAnalysis(metadata: any, classification: any): Promise<any> {
    // Stubbed AI; integrate your AIService usage once ready
    const aiInsights = {
      fieldRecommendations: [] as any[],
      schemaInsights: [] as any[],
      qualityPredictions: [] as any[],
      governanceRecommendations: [] as any[],
      anomalies: [] as any[],
    };

    for (const f of classification.fieldClassifications) {
      if (f.sensitivity === 'High' || f.classification !== 'General') {
        aiInsights.fieldRecommendations.push({
          schema: f.schema,
          table: f.table,
          column: f.column,
          recommendation: `Encrypt and restrict access to ${f.classification} field`,
          reasoning: `Contains ${f.classification} with ${f.sensitivity} sensitivity`,
          confidence: 0.9,
          impact: f.sensitivity === 'High' ? 'High' : 'Medium',
          category: 'Security',
        });
      }
    }

    aiInsights.schemaInsights.push({
      type: 'Pattern',
      insight: 'Detected user-order relationship; consider normalization/indexing',
      confidence: 0.8,
      tables: ['users', 'orders'],
      recommendation: 'Add FKs and composite indexes for key joins',
      priority: 'Medium',
    });

    aiInsights.qualityPredictions.push({
      table: 'users',
      column: 'email',
      qualityDimension: 'Validity',
      predictedScore: 85,
      confidence: 0.9,
      factors: ['Invalid format occurrences'],
      recommendations: ['Add email validation', 'Clean existing invalids'],
    });

    aiInsights.governanceRecommendations.push({
      scope: 'Table',
      target: 'users',
      recommendation: 'Adopt data retention for PII',
      category: 'Retention',
      priority: 'High',
      effort: 'Medium',
      benefit: 'Compliance & cost control',
    });

    aiInsights.anomalies.push({
      type: 'Quality',
      table: 'orders',
      column: 'total_amount',
      description: 'Negative amounts detected',
      severity: 'Warning',
      confidence: 0.95,
      suggestion: 'Review refund logic; add validation',
    });

    return aiInsights;
  }

  private generateSummary(metadata: any, classification: any, aiInsights?: any): any {
    const summary = {
      totalTablesAnalyzed: metadata.totalTables,
      totalColumnsAnalyzed: metadata.totalColumns,
      classificationsApplied: classification.fieldClassifications.length,
      sensitiveDataFound: classification.fieldClassifications.filter((f: any) => f.sensitivity !== 'Low').length,
      complianceFlags: classification.fieldClassifications.reduce((sum: number, f: any) => sum + f.complianceFlags.length, 0),
      qualityIssues: 0,
      aiRecommendations: 0,
      executionTime: 0,
      dataVolumeProcessed: metadata.totalRows || 0,
    };

    if (aiInsights) {
      summary.qualityIssues = aiInsights.anomalies.length;
      summary.aiRecommendations = aiInsights.fieldRecommendations.length + aiInsights.governanceRecommendations.length;
    }
    return summary;
  }

  private createSensitivityMap(fieldClassifications: any[]) {
    const bySensitivity: Record<string, any[]> = {
      Low: fieldClassifications.filter(f => f.sensitivity === 'Low'),
      Medium: fieldClassifications.filter(f => f.sensitivity === 'Medium'),
      High: fieldClassifications.filter(f => f.sensitivity === 'High'),
      Critical: fieldClassifications.filter(f => f.sensitivity === 'Critical'),
    };

    const byClassification: Record<string, any[]> = {
      General: fieldClassifications.filter(f => f.classification === 'General'),
      PII: fieldClassifications.filter(f => f.classification === 'PII'),
      PHI: fieldClassifications.filter(f => f.classification === 'PHI'),
      Financial: fieldClassifications.filter(f => f.classification === 'Financial'),
    };

    return {
      bySensitivity,
      byClassification,
      sensitiveTableCount: new Set(
        fieldClassifications.filter(f => f.sensitivity !== 'Low').map(f => `${f.schema}.${f.table}`)
      ).size,
      highRiskFields: fieldClassifications.filter(f => f.sensitivity === 'High' || f.sensitivity === 'Critical'),
    };
  }

  private createComplianceMapping(fieldClassifications: any[]) {
    const frameworkMap: Record<string, { applicableTables: Set<string>; applicableFields: any[]; requirements: Set<string>; riskLevel: 'Low' | 'Medium' | 'High' }> = {};

    fieldClassifications.forEach(field => {
      field.complianceFlags.forEach((flag: any) => {
        if (!frameworkMap[flag.framework]) {
          frameworkMap[flag.framework] = {
            applicableTables: new Set<string>(),
            applicableFields: [],
            requirements: new Set<string>(),
            riskLevel: 'Low',
          };
        }
        const f = frameworkMap[flag.framework];
        f.applicableTables.add(`${field.schema}.${field.table}`);
        f.applicableFields.push(field);
        f.requirements.add(flag.requirement);
        if (flag.severity === 'Error') f.riskLevel = 'High';
        else if (flag.severity === 'Warning' && f.riskLevel === 'Low') f.riskLevel = 'Medium';
      });
    });

    // Convert Sets
    const byFramework: Record<string, any> = {};
    for (const [fw, data] of Object.entries(frameworkMap)) {
      byFramework[fw] = {
        applicableTables: Array.from(data.applicableTables),
        applicableFields: data.applicableFields,
        requirements: Array.from(data.requirements),
        riskLevel: data.riskLevel,
      };
    }

    return {
      byFramework,
      overallComplexity: Object.keys(byFramework).length > 2 ? 'High' : Object.keys(byFramework).length > 1 ? 'Medium' : 'Low',
      requiredActions: this.generateComplianceActions(byFramework),
    };
  }

  private generateComplianceActions(byFramework: Record<string, any>) {
    const actions: any[] = [];
    for (const [framework, data] of Object.entries(byFramework)) {
      if (data.riskLevel === 'High') {
        actions.push({ framework, action: `Immediate ${framework} compliance review`, priority: 'High', timeline: '30 days', effort: 'High' });
      } else if (data.riskLevel === 'Medium') {
        actions.push({ framework, action: `${framework} compliance assessment`, priority: 'Medium', timeline: '90 days', effort: 'Medium' });
      }
    }
    return actions;
  }

  private assessRisk(fieldClassifications: any[], tableClassifications: any[]) {
    const highRiskFields = fieldClassifications.filter(f => f.sensitivity === 'High' || f.sensitivity === 'Critical');
    const sensitiveTableCount = tableClassifications.filter(t => t.overallSensitivity !== 'Low').length;

    let overallRisk: 'Low' | 'Medium' | 'High' = 'Low';
    if (highRiskFields.length > 10 || sensitiveTableCount > 5) overallRisk = 'High';
    else if (highRiskFields.length > 5 || sensitiveTableCount > 2) overallRisk = 'Medium';

    return {
      overallRisk,
      riskFactors: [
        {
          factor: 'High sensitivity data fields',
          level: highRiskFields.length > 10 ? 'High' : highRiskFields.length > 5 ? 'Medium' : 'Low',
          description: `${highRiskFields.length} fields contain highly sensitive data`,
          affectedTables: [...new Set(highRiskFields.map(f => `${f.schema}.${f.table}`))],
          mitigationStrategy: 'Implement encryption and access controls',
        },
      ],
      mitigationPriorities: [
        'Implement data classification policies',
        'Set up access controls for sensitive data',
        'Regular compliance audits',
      ],
      businessImpact: {
        reputational: overallRisk === 'High' ? 'High' : 'Medium',
        financial: overallRisk === 'High' ? 'High' : 'Low',
        operational: 'Medium',
        regulatory: overallRisk === 'High' ? 'Critical' : 'Medium',
      },
    };
  }

  private getComplianceScope(classification: string): string[] {
    switch (classification) {
      case 'PII': return ['GDPR', 'CCPA'];
      case 'PHI': return ['HIPAA'];
      case 'Financial': return ['PCI-DSS', 'SOX'];
      default: return [];
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async validateJobData(d: DiscoveryJobData): Promise<void> {
    if (!d.sessionId) throw new APIError('Session ID is required', 400);
    if (!d.userId) throw new APIError('User ID is required', 400);
    if (!d.dataSourceId) throw new APIError('Data source ID is required', 400);

    const valid: DiscoveryKind[] = ['full', 'incremental', 'targeted'];
    if (!valid.includes(d.discoveryType)) throw new APIError('Invalid discovery type', 400);

    // basic existence
    const ds = await this.getDataSource(d.dataSourceId);
    if (!ds) throw new APIError('Data source not found', 404);

    // Targeted must include at least one target
    if (d.discoveryType === 'targeted') {
      const hasTargets = Boolean(d.options?.schemas?.length || d.options?.tables?.length);
      if (!hasTargets) throw new APIError('Targeted discovery requires schemas or tables', 400);
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Persistence & Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async updateJobStatus(
    sessionId: string,
    status: DiscoveryStatus,
    progress?: number,
    result?: unknown,
    error?: string
  ): Promise<void> {
    try {
      const patch: Record<string, unknown> = {
        status,
        updated_at: new Date(),
      };
      if (progress !== undefined) patch.progress = progress;
      if (result !== undefined) patch.results = JSON.stringify(result);
      if (error !== undefined) patch.error = error;
      if (status === DiscoveryStatus.COMPLETED || status === DiscoveryStatus.FAILED || status === DiscoveryStatus.CANCELLED) {
        patch.completed_at = new Date();
      }

      const { text, values } = buildUpdateQuery('discovery_sessions', 'WHERE session_id = $1', [sessionId], patch);
      await db.query(text, values);

      await (redis as any).set?.(
        STATUS_KEY(sessionId),
        JSON.stringify({ status, progress: progress ?? null, updated_at: Date.now() }),
        { EX: REDIS_STATUS_TTL_SEC }
      );
    } catch (err) {
      logger.error('Discovery status update failed', { sessionId, status, error: (err as any)?.message });
      // non-fatal
    }
  }

  private async getDataSource(dataSourceId: string): Promise<any> {
    try {
      const result = await db.query('SELECT * FROM data_sources WHERE id = $1', [dataSourceId]);
      return result.rows[0] ?? null;
    } catch (err) {
      logger.error('Discovery data source lookup failed', { dataSourceId, error: (err as any)?.message });
      throw err;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Retry & Cancel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async shouldRetryJob(d: DiscoveryJobData, err: unknown): Promise<boolean> {
    const retryCount = d.retryCount ?? 0;
    const maxRetries = d.maxRetries ?? this.maxRetries;

    if (err instanceof APIError && err.statusCode >= 400 && err.statusCode < 500) return false;
    if ((err as any)?.statusCode === 499) return false; // cancelled
    if (await this.isCancelled(d.sessionId)) return false;
    if (retryCount >= maxRetries) return false;

    return isTransientError(err);
  }

  private async scheduleRetry(d: DiscoveryJobData): Promise<DiscoveryJobResult> {
    const retryCount = (d.retryCount ?? 0) + 1;
    const delay = backoffWithJitter(retryCount);

    logger.info('Discovery job: scheduling retry', { sessionId: d.sessionId, retryCount, delayMs: delay });

    const retryData: DiscoveryJobData = { ...d, retryCount };

    setTimeout(async () => {
      try {
        if (await this.isCancelled(retryData.sessionId)) {
          await this.updateJobStatus(retryData.sessionId, DiscoveryStatus.FAILED, 0, undefined, 'Job cancelled');
          return;
        }
        await this.execute(retryData);
      } catch (err) {
        logger.error('Discovery retry execution failed', { sessionId: retryData.sessionId, error: (err as any)?.message });
      }
    }, delay);

    return {
      sessionId: d.sessionId,
      status: JobStatus.PENDING,
      duration: 0,
      completedAt: new Date(),
    };
  }

  private async isCancelled(sessionId: string): Promise<boolean> {
    try {
      const val = await (redis as any).get?.(CANCEL_KEY(sessionId));
      return val === '1' || val === 'true';
    } catch {
      return false;
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Notifications â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async sendCompletionNotification(
    userId: string,
    sessionId: string,
    discoveryType: string,
    success: boolean,
    error?: string
  ): Promise<void> {
    try {
      const type = success ? 'discovery_completed' : 'discovery_failed';
      const title = success ? 'Discovery Completed' : 'Discovery Failed';
      const message = success
        ? `Your ${discoveryType} discovery completed successfully.`
        : `Your ${discoveryType} discovery failed: ${error ?? 'unknown error'}`;
      const metadata = { sessionId, discoveryType, success };

      await db.query(
        `INSERT INTO notifications (user_id, type, title, message, metadata, created_at)
         VALUES ($1, $2, $3, $4, $5, NOW())`,
        [userId, type, title, message, JSON.stringify(metadata)]
      );
      // push via websocket/event bus as needed
    } catch (err) {
      logger.error('Discovery notification failed', { userId, sessionId, error: (err as any)?.message });
      // swallow
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Lifecycle helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  public async cleanup(sessionId: string): Promise<void> {
    try {
      await (redis as any).del?.(STATUS_KEY(sessionId));
      logger.debug('Discovery cleanup completed', { sessionId });
    } catch (err) {
      logger.error('Discovery cleanup failed', { sessionId, error: (err as any)?.message });
    }
  }

  public async cancel(sessionId: string): Promise<void> {
    try {
      // A controller can also set CANCEL_KEY(sessionId) in Redis, if you want
      await this.updateJobStatus(sessionId, DiscoveryStatus.CANCELLED, 0);
      await this.cleanup(sessionId);
      logger.info('Discovery job cancelled', { sessionId });
    } catch (err) {
      logger.error('Discovery cancel failed', { sessionId, error: (err as any)?.message });
      throw err;
    }
  }

  public async getProgress(sessionId: string): Promise<any> {
    try {
      const cached = await (redis as any).get?.(STATUS_KEY(sessionId));
      if (cached) {
        try { return JSON.parse(cached); } catch { /* fall through */ }
      }

      const result = await db.query(
        'SELECT status, progress, updated_at FROM discovery_sessions WHERE session_id = $1',
        [sessionId]
      );
      if (result.rows.length === 0) throw new APIError('Discovery session not found', 404);

      return {
        status: result.rows[0].status,
        progress: result.rows[0].progress,
        updated_at: result.rows[0].updated_at,
      };
    } catch (err) {
      logger.error('Discovery progress fetch failed', { sessionId, error: (err as any)?.message });
      throw err;
    }
  }
}

/** Singleton */
export const discoveryJob = new DiscoveryJob();



------------------------------------------------------------
FILE: backend\ai-service\src\middleware\auth.ts
------------------------------------------------------------
// src/middleware/auth.ts
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';
import { NextFunction, Request, Response } from 'express';
import jwt, { JwtPayload, VerifyOptions } from 'jsonwebtoken';

/** Extend Express Request with an authenticated user */
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
    permissions?: string[];
    sub?: string;
    iat?: number;
    exp?: number;
  };
}

/** The JWT claims your system issues/accepts */
interface AppJwtPayload extends JwtPayload {
  id: string;
  email: string;
  role: string;
  permissions?: string[];
}

/* ---------------------------- Helpers & Config ---------------------------- */

const readEnv = () => {
  const {
    JWT_SECRET,
    JWT_ISSUER,
    JWT_AUDIENCE,
    JWT_ALLOWED_ALGS,
    JWT_ALG = 'HS256',
    JWT_CLOCK_TOLERANCE_SEC = '60',
    AUTH_COOKIE = 'auth_token',
  } = process.env;

  if (!JWT_SECRET) {
    // fail closed; this is a deployment/config error
    throw new Error('JWT_SECRET is not configured');
  }

  const allowedAlgs = (JWT_ALLOWED_ALGS?.split(',').map(s => s.trim()).filter(Boolean)) || [JWT_ALG];

  const verifyOptions: VerifyOptions = {
    algorithms: allowedAlgs as jwt.Algorithm[],
    issuer: JWT_ISSUER || undefined,
    audience: JWT_AUDIENCE || undefined,
    clockTolerance: Number.isFinite(+JWT_CLOCK_TOLERANCE_SEC) ? Number(JWT_CLOCK_TOLERANCE_SEC) : 60,
  };

  return { JWT_SECRET, verifyOptions, AUTH_COOKIE };
};

/** Safely extract a token from Authorization header, x-access-token, or a cookie */
const extractToken = (req: Request, cookieName: string): string | null => {
  const hdr = req.headers.authorization || '';
  if (hdr) {
    const [scheme, token] = hdr.split(' ');
    if (scheme?.toLowerCase() === 'bearer' && token) return token.trim();
  }
  const alt = (req.headers['x-access-token'] as string) || '';
  if (alt) return alt.trim();

  // minimal cookie parse (avoid extra deps)
  const cookieHeader = req.headers.cookie || '';
  if (cookieHeader && cookieName) {
    const parts = cookieHeader.split(';').map(c => c.trim());
    for (const p of parts) {
      const [k, v] = p.split('=');
      if (k === cookieName && v) return decodeURIComponent(v);
    }
  }
  return null;
};

/** Central token verification (HMAC secret) */
const verifyToken = (token: string): AppJwtPayload => {
  const { JWT_SECRET, verifyOptions } = readEnv();
  const decoded = jwt.verify(token, JWT_SECRET, verifyOptions);
  if (typeof decoded === 'string') {
    throw new APIError('Invalid token payload', 401);
  }
  const payload = decoded as AppJwtPayload;
  if (!payload.id || !payload.email || !payload.role) {
    throw new APIError('Token missing required claims', 401);
  }
  return payload;
};

/** include optional field only if defined (for exactOptionalPropertyTypes) */
type Defined<T> = Exclude<T, undefined>;
const includeIfDefined = <K extends string, V>(key: K, value: V | undefined) =>
  (value !== undefined ? { [key]: value } as Record<K, Defined<V>> : {});

/** normalize string or string[] input */
const toArray = <T>(v: T | T[]) => (Array.isArray(v) ? v : [v]);

/* -------------------------------- Middlewares ----------------------------- */

/** Strict authentication. Requires a valid token and attaches user to req. */
export const authenticateToken = async (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { AUTH_COOKIE } = readEnv();
    const token = extractToken(req, AUTH_COOKIE);
    if (!token) throw new APIError('Access token required', 401);

    const payload = verifyToken(token);

    // only include optional fields if they exist
    req.user = {
      id: payload.id,
      email: payload.email,
      role: payload.role,
      permissions: payload.permissions ?? [],
      ...includeIfDefined('sub', payload.sub),
      ...includeIfDefined('iat', payload.iat),
      ...includeIfDefined('exp', payload.exp),
    };

    logger.debug('Auth: user authenticated', { userId: payload.id, role: payload.role });
    next();
  } catch (err: any) {
    if (err instanceof APIError) return next(err);
    if (err instanceof jwt.TokenExpiredError) return next(new APIError('Token expired', 401));
    if (err instanceof jwt.NotBeforeError) return next(new APIError('Token not active yet', 401));
    if (err instanceof jwt.JsonWebTokenError) return next(new APIError('Invalid token', 401));
    logger.warn('Auth: unexpected verification error', { message: err?.message });
    next(new APIError('Authentication failed', 401));
  }
};

/** Optional auth. If a valid token is present, attaches user; never blocks. */
export const optionalAuth = async (
  req: AuthenticatedRequest,
  _res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { AUTH_COOKIE } = readEnv();
    const token = extractToken(req, AUTH_COOKIE);
    if (!token) return next();

    try {
      const payload = verifyToken(token);
      req.user = {
        id: payload.id,
        email: payload.email,
        role: payload.role,
        permissions: payload.permissions ?? [],
        ...includeIfDefined('sub', payload.sub),
        ...includeIfDefined('iat', payload.iat),
        ...includeIfDefined('exp', payload.exp),
      };
      logger.debug('Auth: optional user attached', { userId: payload.id, role: payload.role });
    } catch (e: any) {
      // Do not block optional routes; just log at debug
      logger.debug('Auth: optional token rejected', { reason: e?.message });
    }
    next();
  } catch {
    next();
  }
};

/** Require one of the given roles. */
export const requireRole = (roles: string[] | string) => {
  const required = new Set(toArray(roles).map(r => r.toLowerCase()));
  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) throw new APIError('Authentication required', 401);
      const userRole = (req.user.role || '').toLowerCase();
      if (!required.has(userRole)) throw new APIError('Insufficient permissions', 403);
      next();
    } catch (err) {
      next(err);
    }
  };
};

/** Require a specific permission (exact match). */
export const requirePermission = (permission: string) => {
  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {
    try {
      if (!req.user) throw new APIError('Authentication required', 401);
      const perms = new Set(req.user.permissions || []);
      if (!perms.has(permission)) throw new APIError('Insufficient permissions', 403);
      next();
    } catch (err) {
      next(err);
    }
  };
};



------------------------------------------------------------
FILE: backend\ai-service\src\middleware\errorHandler.ts
------------------------------------------------------------
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';
import { NextFunction, Request, Response } from 'express';

// Extended Error interface for database and system errors
interface ExtendedError extends Error {
  code?: string;
  errno?: number;
  sqlState?: string;
  sqlMessage?: string;
  statusCode?: number;
}

export const errorHandler = (
  error: ExtendedError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  void next; // keep Express signature, silence TS unused

  // Log the error with full context
  logger.error('Request error:', {
    error: error.message,
    stack: error.stack,
    code: error.code,
    statusCode: error.statusCode,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    requestId: (req as any).id,
    body: req.method !== 'GET' ? req.body : undefined,
    query: req.query,
    params: req.params
  });

  // Handle API errors (our custom errors)
  if (error instanceof APIError) {
    res.status(error.statusCode).json({
      success: false,
      error: {
        message: error.message,
        code: error.statusCode,
        type: 'APIError',
        ...(error.details && { details: error.details }),
        ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle Joi validation errors
  if (error.name === 'ValidationError') {
    res.status(400).json({
      success: false,
      error: {
        message: 'Validation failed',
        code: 400,
        type: 'ValidationError',
        details: error.message
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    res.status(401).json({
      success: false,
      error: {
        message: 'Invalid token',
        code: 401,
        type: 'AuthenticationError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  if (error.name === 'TokenExpiredError') {
    res.status(401).json({
      success: false,
      error: {
        message: 'Token expired',
        code: 401,
        type: 'AuthenticationError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle database connection errors
  if (error.message?.includes('connect ECONNREFUSED') || 
      error.code === 'ECONNREFUSED' ||
      error.code === 'ENOTFOUND' ||
      error.code === 'ETIMEDOUT') {
    res.status(503).json({
      success: false,
      error: {
        message: 'Database connection failed',
        code: 503,
        type: 'DatabaseConnectionError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle PostgreSQL specific errors
  if (error.code?.startsWith('23')) { // PostgreSQL constraint violations
    let message = 'Database constraint violation';
    let statusCode = 400;

    switch (error.code) {
      case '23505': // unique_violation
        message = 'Duplicate entry - record already exists';
        break;
      case '23503': // foreign_key_violation
        message = 'Referenced record does not exist';
        break;
      case '23502': // not_null_violation
        message = 'Required field cannot be empty';
        break;
      case '23514': // check_violation
        message = 'Data does not meet validation requirements';
        break;
    }

    res.status(statusCode).json({
      success: false,
      error: {
        message,
        code: statusCode,
        type: 'DatabaseConstraintError',
        dbCode: error.code,
        ...(process.env.NODE_ENV === 'development' && { 
          sqlMessage: (error as any).sqlMessage || error.message 
        })
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle Redis connection errors
  if (error.message?.includes('Redis') || error.code === 'ECONNRESET') {
    res.status(503).json({
      success: false,
      error: {
        message: 'Cache service temporarily unavailable',
        code: 503,
        type: 'CacheConnectionError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle OpenAI API errors
  if (error.message?.includes('OpenAI') || error.message?.includes('AI service')) {
    res.status(503).json({
      success: false,
      error: {
        message: 'AI service temporarily unavailable',
        code: 503,
        type: 'AIServiceError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle rate limiting errors
  if ((error.message?.includes('rate limit') || (error as any).statusCode === 429)) {
    res.status(429).json({
      success: false,
      error: {
        message: 'Too many requests - please try again later',
        code: 429,
        type: 'RateLimitError',
        retryAfter: '15 minutes'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle file upload errors
  if ((error as any).code === 'LIMIT_FILE_SIZE') {
    res.status(413).json({
      success: false,
      error: {
        message: 'File too large',
        code: 413,
        type: 'FileUploadError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  if ((error as any).code === 'LIMIT_UNEXPECTED_FILE') {
    res.status(400).json({
      success: false,
      error: {
        message: 'Invalid file upload',
        code: 400,
        type: 'FileUploadError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle syntax errors (malformed JSON, etc.)
  if (error instanceof SyntaxError) {
    res.status(400).json({
      success: false,
      error: {
        message: 'Invalid request format',
        code: 400,
        type: 'SyntaxError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle timeout errors
  if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {
    res.status(408).json({
      success: false,
      error: {
        message: 'Request timeout',
        code: 408,
        type: 'TimeoutError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle permission errors
  if (error.code === 'EACCES' || error.code === 'EPERM') {
    res.status(403).json({
      success: false,
      error: {
        message: 'Access denied',
        code: 403,
        type: 'PermissionError'
      },
      requestId: (req as any).id,
      timestamp: new Date().toISOString()
    });
    return;
  }

  // Handle default errors
  const isDevelopment = process.env.NODE_ENV === 'development';
  const statusCode = (error as any).statusCode || 500;

  res.status(statusCode).json({
    success: false,
    error: {
      message: isDevelopment ? error.message : 'Internal server error',
      code: statusCode,
      type: 'InternalServerError',
      ...(isDevelopment && { 
        stack: error.stack,
        originalError: {
          name: error.name,
          message: error.message,
          code: error.code
        }
      })
    },
    requestId: (req as any).id,
    timestamp: new Date().toISOString()
  });
};

export const notFoundHandler = (req: Request, res: Response): void => {
  const error = {
    success: false,
    error: {
      message: `Route ${req.method} ${req.path} not found`,
      code: 404,
      type: 'NotFoundError',
      availableRoutes: [
        'GET /api/health',
        'GET /api/docs',
        'POST /api/discovery',
        'POST /api/analysis/schema'
      ]
    },
    requestId: (req as any).id,
    timestamp: new Date().toISOString()
  };

  logger.warn('Route not found', {
    method: req.method,
    path: req.path,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  res.status(404).json(error);
};

// Async error wrapper utility
export const asyncHandler = (
  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>
) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Global unhandled error handlers
export const setupGlobalErrorHandlers = (): void => {
  // Handle uncaught exceptions
  process.on('uncaughtException', (error: Error) => {
    logger.error('Uncaught Exception - Server shutting down:', {
      error: error.message,
      stack: error.stack,
      pid: process.pid
    });
    process.exit(1);
  });

  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
    logger.error('Unhandled Promise Rejection:', {
      reason: reason?.message || reason,
      stack: reason?.stack,
      promise: promise.toString()
    });
    process.exit(1);
  });

  // Handle SIGTERM (graceful shutdown)
  process.on('SIGTERM', () => {
    logger.info('SIGTERM received - starting graceful shutdown');
    process.exit(0);
  });

  // Handle SIGINT (Ctrl+C)
  process.on('SIGINT', () => {
    logger.info('SIGINT received - starting graceful shutdown');
    process.exit(0);
  });
};

// Error types for better error handling
export enum ErrorTypes {
  API_ERROR = 'APIError',
  VALIDATION_ERROR = 'ValidationError',
  AUTHENTICATION_ERROR = 'AuthenticationError',
  AUTHORIZATION_ERROR = 'AuthorizationError',
  DATABASE_ERROR = 'DatabaseError',
  CACHE_ERROR = 'CacheError',
  AI_SERVICE_ERROR = 'AIServiceError',
  RATE_LIMIT_ERROR = 'RateLimitError',
  FILE_UPLOAD_ERROR = 'FileUploadError',
  TIMEOUT_ERROR = 'TimeoutError',
  NOT_FOUND_ERROR = 'NotFoundError',
  INTERNAL_SERVER_ERROR = 'InternalServerError'
}

// Helper function to create standardized error responses
export const createErrorResponse = (
  message: string,
  code: number,
  type: ErrorTypes,
  details?: any,
  requestId?: string
) => {
  return {
    success: false,
    error: {
      message,
      code,
      type,
      ...(details && { details })
    },
    requestId: requestId || 'unknown',
    timestamp: new Date().toISOString()
  };
};



------------------------------------------------------------
FILE: backend\ai-service\src\middleware\rateLimit.ts
------------------------------------------------------------
// src/middleware/rateLimit.ts
import { redis } from '@/config/redis';
import type { NextFunction, Request, RequestHandler, Response } from 'express';
import rateLimit, {
  type ClientRateLimitInfo,
  type RateLimitRequestHandler,
  type Store as RateLimitStore,
} from 'express-rate-limit';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Central config (can move to config/env)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const RATE_LIMIT_CONFIG = {
  ai: { windowMs: 15 * 60 * 1000, max: 10, prefix: 'rl:ai:' },         // 10 per 15m
  discovery: { windowMs: 5 * 60 * 1000, max: 3, prefix: 'rl:disc:' },   // 3 per 5m
  api: { windowMs: 15 * 60 * 1000, max: 100, prefix: 'rl:api:' },       // 100 per 15m
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Minimal request shape (avoid importing Express Request types here)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
type MaybeAuthed = {
  user?: { id?: string | null | undefined; role?: string | null | undefined };
  ip?: string;
  originalUrl?: string;
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Redis-backed store for express-rate-limit v7
 * (Do NOT `implements Store` to avoid cross-package type conflicts)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
class RateLimitRedisStore {
  private readonly _prefix: string;
  private readonly _windowMs: number;

  constructor(windowMs: number, prefix = 'rl:') {
    this._prefix = prefix;
    this._windowMs = windowMs;
  }

  async increment(key: string): Promise<ClientRateLimitInfo> {
    const redisKey = `${this._prefix}${key}`;
    try {
      const client = redis.getClient();
      const totalHits = await client.incr(redisKey);

      // set expiry on first hit
      if (totalHits === 1) {
        await client.expire(redisKey, Math.ceil(this._windowMs / 1000));
      }

      const ttlSec = await client.ttl(redisKey);
      // resetTime is REQUIRED by ClientRateLimitInfo
      const resetTime =
        ttlSec > 0
          ? new Date(Date.now() + ttlSec * 1000)
          : new Date(Date.now() + this._windowMs);

      return { totalHits, resetTime };
    } catch {
      // If Redis is unavailable, be permissive but still provide a resetTime
      return { totalHits: 1, resetTime: new Date(Date.now() + this._windowMs) };
    }
  }

  async decrement(key: string): Promise<void> {
    try {
      await redis.getClient().decr(`${this._prefix}${key}`);
    } catch {
      // swallow
    }
  }

  async resetKey(key: string): Promise<void> {
    try {
      await redis.getClient().del(`${this._prefix}${key}`);
    } catch {
      // swallow
    }
  }

  // Optional: some versions may call resetAll; implement as no-op
  async resetAll(): Promise<void> {
    // Implement SCAN/DEL by prefix if you need global resets
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Factory (uses `unknown` to avoid type-forks between @types/express trees)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export function createRateLimiter(options: {
  windowMs: number;
  max: number | ((req: unknown) => number);
  message?: string;
  skipSuccessfulRequests?: boolean;
  keyGenerator?: (req: unknown, res: unknown) => string;
  prefix?: string;
}): RateLimitRequestHandler {
  const {
    windowMs,
    max,
    message = 'Too many requests',
    skipSuccessfulRequests = false,
    keyGenerator,
    prefix = 'rl:',
  } = options;

  return rateLimit({
    windowMs,

    // ValueDeterminingMiddleware<number> compatible
    max: (req: unknown) => {
      // functional max support
      if (typeof max === 'function') {
        try {
          return max(req);
        } catch {
          return 100;
        }
      }
      // super_admin bypass (unlimited)
      const r = req as MaybeAuthed;
      if (r?.user?.role === 'super_admin') return Number.MAX_SAFE_INTEGER;
      return max;
    },

    standardHeaders: true,
    legacyHeaders: false,

    // Cast through unknown to satisfy possible distinct type trees
    store: new RateLimitRedisStore(windowMs, prefix) as unknown as RateLimitStore,

    keyGenerator: (req: unknown, res: unknown): string => {
      if (keyGenerator) {
        const k = keyGenerator(req, res);
        // Must always return a string
        return (k ?? '').toString() || (req as MaybeAuthed).ip || 'unknown';
      }
      const r = req as MaybeAuthed;
      const id = (r?.user?.id ?? '').toString().trim();
      return id || r?.ip || 'unknown';
    },

    skipSuccessfulRequests,

    handler: (req: unknown, res: unknown): void => {
      const _res = res as {
        setHeader: (k: string, v: string) => void;
        status: (c: number) => { json?: (b: unknown) => void };
      };
      const _req = req as MaybeAuthed;

      _res.setHeader('Retry-After', Math.ceil(windowMs / 1000).toString());
      _res
        .status(429)
        .json?.({
          success: false,
          error: { code: 'RATE_LIMIT_EXCEEDED', message },
          meta: { timestamp: new Date().toISOString(), path: _req?.originalUrl || '' },
        });
    },
  });
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Preconfigured limiters (raw RateLimitRequestHandler)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export const aiRateLimit: RateLimitRequestHandler = createRateLimiter({
  ...RATE_LIMIT_CONFIG.ai,
  message: 'AI request limit exceeded',
  prefix: RATE_LIMIT_CONFIG.ai.prefix,
  // Admins can do more AI calls
  max: (req) => ((req as MaybeAuthed).user?.role === 'admin' ? 50 : RATE_LIMIT_CONFIG.ai.max),
  keyGenerator: (req) => {
    const r = req as MaybeAuthed;
    const id = (r?.user?.id ?? '').toString().trim();
    return id || r?.ip || 'unknown';
  },
});

export const discoveryRateLimit: RateLimitRequestHandler = createRateLimiter({
  ...RATE_LIMIT_CONFIG.discovery,
  message: 'Discovery request limit exceeded',
  prefix: RATE_LIMIT_CONFIG.discovery.prefix,
  keyGenerator: (req) => {
    const r = req as MaybeAuthed;
    const id = (r?.user?.id ?? '').toString().trim();
    return id || r?.ip || 'unknown';
  },
});

export const apiRateLimit: RateLimitRequestHandler = createRateLimiter({
  ...RATE_LIMIT_CONFIG.api,
  message: 'API request limit exceeded',
  prefix: RATE_LIMIT_CONFIG.api.prefix,
  skipSuccessfulRequests: true,
  keyGenerator: (req) => {
    const r = req as MaybeAuthed;
    const id = (r?.user?.id ?? '').toString().trim();
    return id || r?.ip || 'unknown';
  },
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Wrappers to plain Express RequestHandler (fix type tree mismatches)
 * Use these in your routers: aiRateLimitMw/discoveryRateLimitMw/apiRateLimitMw
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const asMiddleware = (rl: RateLimitRequestHandler): RequestHandler =>
  (req: Request, res: Response, next: NextFunction) =>
    (rl as unknown as (req: Request, res: Response, next: NextFunction) => void)(req, res, next);

export const aiRateLimitMw: RequestHandler = asMiddleware(aiRateLimit);
export const discoveryRateLimitMw: RequestHandler = asMiddleware(discoveryRateLimit);
export const apiRateLimitMw: RequestHandler = asMiddleware(apiRateLimit);



------------------------------------------------------------
FILE: backend\ai-service\src\middleware\validation.ts
------------------------------------------------------------
import { APIError } from '@/utils/errors';
import { NextFunction, Request, Response } from 'express';
import Joi from 'joi';

const discoveryRequestSchema = Joi.object({
  dataSourceId: Joi.string().uuid().required(),
  schemas: Joi.array().items(Joi.string()).optional(),
  tables: Joi.array().items(Joi.string()).optional(),
  options: Joi.object({
    sampleSize: Joi.number().min(10).max(10000).default(100),
    includeData: Joi.boolean().default(true),
    analysisDepth: Joi.string().valid('basic', 'detailed', 'comprehensive').default('detailed')
  }).optional()
});

const nlQuerySchema = Joi.object({
  query: Joi.string().min(3).max(500).required(),
  context: Joi.object({
    schemas: Joi.array().items(Joi.string()).optional(),
    tables: Joi.array().items(Joi.string()).optional(),
    fields: Joi.array().items(Joi.string()).optional()
  }).optional()
});

const analysisRequestSchema = Joi.object({
  schema: Joi.object({
    name: Joi.string().required(),
    tables: Joi.array().items(Joi.object({
      schema: Joi.string().required(),
      name: Joi.string().required(),
      columns: Joi.array().items(Joi.object({
        name: Joi.string().required(),
        type: Joi.string().required(),
        nullable: Joi.boolean().required(),
        description: Joi.string().optional()
      })).required()
    })).required()
  }).required()
});

export const validateDiscoveryRequest = (req: Request, res: Response, next: NextFunction): void => {
  void res;
  const { error } = discoveryRequestSchema.validate(req.body);
  if (error) {
    next(new APIError(`Validation error: ${error.details[0].message}`, 400));
    return;
  }
  next();
};

export const validateNLQuery = (req: Request, res: Response, next: NextFunction): void => {
  void res;
  const { error } = nlQuerySchema.validate(req.body);
  if (error) {
    next(new APIError(`Validation error: ${error.details[0].message}`, 400));
    return;
  }
  next();
};

export const validateAnalysisRequest = (req: Request, res: Response, next: NextFunction): void => {
  void res;
  const { error } = analysisRequestSchema.validate(req.body);
  if (error) {
    next(new APIError(`Validation error: ${error.details[0].message}`, 400));
    return;
  }
  next();
};



------------------------------------------------------------
FILE: backend\ai-service\src\models\Analysis.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: backend\ai-service\src\models\DataField.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: backend\ai-service\src\models\Discovery.ts
------------------------------------------------------------
// src/models/Discovery.ts
import { db } from '@/config/database';
import { logger } from '@/utils/logger';

/** Domain model */
export interface DiscoverySession {
  sessionId: string;
  userId: string;
  dataSourceId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  results?: unknown; // if present, must not be undefined (exactOptionalPropertyTypes)
  error?: string;    // if present, must not be undefined
  createdAt: Date;
  updatedAt: Date;
}

/** Shape returned by Postgres (snake_case) */
interface DbDiscoveryRow {
  session_id: string;
  user_id: string;
  data_source_id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  results: unknown | null;
  error: string | null;
  created_at: Date;
  updated_at: Date;
}

export class DiscoveryModel {
  static async create(session: Partial<DiscoverySession>): Promise<DiscoverySession> {
    try {
      const result = await db.query(
        `INSERT INTO discovery_sessions 
           (session_id, user_id, data_source_id, status, progress, created_at, updated_at)
         VALUES ($1,        $2,     $3,            $4,    $5,      NOW(),     NOW())
         RETURNING *`,
        [
          session.sessionId,
          session.userId,
          session.dataSourceId,
          session.status,
          session.progress,
        ]
      );

      const row = (result.rows as unknown as DbDiscoveryRow[])[0];
      return this.mapFromDb(row);
    } catch (error) {
      logger.error('Failed to create discovery session:', error);
      throw error;
    }
  }

  static async findById(sessionId: string): Promise<DiscoverySession | null> {
    try {
      const result = await db.query(
        'SELECT * FROM discovery_sessions WHERE session_id = $1',
        [sessionId]
      );

      const rows = result.rows as unknown as DbDiscoveryRow[];
      if (rows.length === 0) return null;
      return this.mapFromDb(rows[0]);
    } catch (error) {
      logger.error('Failed to find discovery session:', error);
      throw error;
    }
  }

  static async findByUserId(
    userId: string,
    limit = 20,
    offset = 0
  ): Promise<DiscoverySession[]> {
    try {
      const result = await db.query(
        `SELECT * FROM discovery_sessions
          WHERE user_id = $1
          ORDER BY created_at DESC
          LIMIT $2 OFFSET $3`,
        [userId, limit, offset]
      );

      const rows = result.rows as unknown as DbDiscoveryRow[];
      return rows.map((row) => this.mapFromDb(row));
    } catch (error) {
      logger.error('Failed to find discovery sessions by user:', error);
      throw error;
    }
  }

  static async update(
    sessionId: string,
    updates: Partial<DiscoverySession>
  ): Promise<DiscoverySession | null> {
    try {
      const setClause: string[] = [];
      const values: unknown[] = [];
      let paramIndex = 1;

      // Build dynamic SET list (convert camelCase -> snake_case)
      for (const [key, value] of Object.entries(updates)) {
        if (key === 'sessionId') continue; // never update PK here
        const dbKey = key.replace(/[A-Z]/g, (ltr) => `_${ltr.toLowerCase()}`);
        setClause.push(`${dbKey} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }

      if (setClause.length === 0) return null;

      // always set updated_at
      setClause.push(`updated_at = NOW()`);

      // WHERE param
      values.push(sessionId);

      const result = await db.query(
        `UPDATE discovery_sessions
            SET ${setClause.join(', ')}
          WHERE session_id = $${paramIndex}
          RETURNING *`,
        values
      );

      const rows = result.rows as unknown as DbDiscoveryRow[];
      if (rows.length === 0) return null;
      return this.mapFromDb(rows[0]);
    } catch (error) {
      logger.error('Failed to update discovery session:', error);
      throw error;
    }
  }

  static async delete(sessionId: string, userId: string): Promise<boolean> {
    try {
      const result = await db.query(
        'DELETE FROM discovery_sessions WHERE session_id = $1 AND user_id = $2',
        [sessionId, userId]
      );
      return result.rowCount > 0;
    } catch (error) {
      logger.error('Failed to delete discovery session:', error);
      throw error;
    }
  }

  /** Map DB row -> domain object, respecting exactOptionalPropertyTypes */
  private static mapFromDb(row: DbDiscoveryRow): DiscoverySession {
    const base: DiscoverySession = {
      sessionId: row.session_id,
      userId: row.user_id,
      dataSourceId: row.data_source_id,
      status: row.status,
      progress: row.progress,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };

    // Only assign optional fields if they are non-null/defined
    if (row.results !== null && row.results !== undefined) {
      (base as { results: unknown }).results = row.results;
    }
    if (row.error !== null && row.error !== undefined) {
      (base as { error: string }).error = row.error;
    }

    return base;
  }
}



------------------------------------------------------------
FILE: backend\ai-service\src\processors\DataProcessor.ts
------------------------------------------------------------
// src/processors/DataProcessor.ts
import type {
  DataSample,
  IDataProcessor,
  QualityIssue,
} from '@/services/AnalysisService';

export class DataProcessor implements IDataProcessor {
  async analyzeSampleData(
    samples: DataSample[],
  ): Promise<{ analysis: Record<string, unknown>[]; qualityIssues: QualityIssue[] }> {
    const analysis: Record<string, unknown>[] = [];
    const qualityIssues: QualityIssue[] = [];

    for (const s of samples) {
      const values = Array.isArray(s.values) ? s.values : [];
      const nonNull = values.filter((v) => v !== null && v !== undefined);
      const nulls = values.length - nonNull.length;

      const uniqueCount = new Set(nonNull.map((v) => JSON.stringify(v))).size;

      analysis.push({
        column: s.columnName,
        count: values.length,
        nulls,
        nullRate: values.length ? +(nulls / values.length * 100).toFixed(2) : 0,
        uniqueCount,
        sample: nonNull.slice(0, 5),
      });

      if (nulls > 0) {
        qualityIssues.push({
          column: s.columnName,
          type: 'null_values',
          severity: nulls / (values.length || 1) > 0.2 ? 'High' : 'Low',
          count: nulls,
          message: 'Column contains null/undefined values',
          sample: values.slice(0, 5),
        });
      }

      const lower = s.columnName.toLowerCase();

      if (lower.includes('email')) {
        const bad = nonNull.filter(
          (v) => typeof v === 'string' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v),
        );
        if (bad.length) {
          qualityIssues.push({
            column: s.columnName,
            type: 'format_inconsistency',
            severity: bad.length / (nonNull.length || 1) > 0.05 ? 'Medium' : 'Low',
            count: bad.length,
            message: 'Invalid email addresses detected',
            sample: bad.slice(0, 5),
          });
        }
      }

      if (lower.includes('phone')) {
        const bad = nonNull.filter(
          (v) => typeof v === 'string' && !/^\+?[0-9().\- ]{7,}$/.test(v),
        );
        if (bad.length) {
          qualityIssues.push({
            column: s.columnName,
            type: 'format_inconsistency',
            severity: bad.length / (nonNull.length || 1) > 0.05 ? 'Medium' : 'Low',
            count: bad.length,
            message: 'Invalid phone numbers detected',
            sample: bad.slice(0, 5),
          });
        }
      }
    }

    return { analysis, qualityIssues };
  }
}

export default DataProcessor;



------------------------------------------------------------
FILE: backend\ai-service\src\processors\FieldProcessor.ts
------------------------------------------------------------
// src/processors/FieldProcessor.ts
export interface FieldInfo {
  name: string;
  type: string;
  nullable: boolean;
  description?: string;
}

export type Classification = 'PII' | 'PHI' | 'Financial' | 'General';
export type Sensitivity = 'Low' | 'Medium' | 'High';

export interface ProcessedField extends FieldInfo {
  classification: Classification;
  sensitivity: Sensitivity;
  patterns: string[];
}

/** Very lightweight field classifier used by SchemaProcessor */
export class FieldProcessor {
  processFields(fields: FieldInfo[]): ProcessedField[] {
    return fields.map((f) => {
      const classification = this.classify(f);
      const sensitivity = this.sensitivityFromClass(classification);
      const patterns = this.detectPatterns(f);

      return { ...f, classification, sensitivity, patterns };
    });
  }

  private classify(f: FieldInfo): Classification {
    const n = f.name.toLowerCase();
    if (/(email|first_?name|last_?name|phone|ssn|address)/.test(n)) return 'PII';
    if (/(health|medical|patient|diagnosis)/.test(n)) return 'PHI';
    if (/(payment|amount|price|card|invoice|billing)/.test(n)) return 'Financial';
    return 'General';
    }

  private sensitivityFromClass(c: Classification): Sensitivity {
    if (c === 'PHI') return 'High';
    if (c === 'PII' || c === 'Financial') return 'Medium';
    return 'Low';
  }

  private detectPatterns(f: FieldInfo): string[] {
    const out: string[] = [];
    const n = f.name.toLowerCase();
    if (n.includes('email')) out.push('email');
    if (n.includes('phone')) out.push('phone');
    if (/(date|timestamp)/.test(f.type.toLowerCase())) out.push('date');
    return out;
  }
}

export default FieldProcessor;



------------------------------------------------------------
FILE: backend\ai-service\src\processors\SchemaProcessor.ts
------------------------------------------------------------
// src/processors/SchemaProcessor.ts
import { logger } from '@utils/logger';
import FieldProcessor, { FieldInfo } from './FieldProcessor';

export interface SchemaInfo {
  name: string;
  tables: TableInfo[];
}

export interface TableInfo {
  schema: string;
  name: string;
  columns: FieldInfo[];
  rowCount?: number;
  relationships?: RelationshipInfo[];
}

export interface RelationshipInfo {
  type: 'foreign_key' | 'one_to_many' | 'many_to_many';
  targetTable: string;
  targetColumn: string;
  sourceColumn: string;
}

export interface ProcessedTable extends TableInfo {
  processedColumns: Array<
    FieldInfo & { classification: string; sensitivity: string; patterns: string[] }
  >;
  governance: {
    classification: string;
    sensitivity: string;
    complianceFrameworks: string[];
    suggestedPolicies: string[];
  };
}

export interface SchemaSummary {
  totalTables: number;
  totalColumns: number;
  sensitiveDataTables: number;
  complianceRequirements: string[];
  recommendations: string[];
}

export interface ProcessedSchema {
  name: string;
  tables: ProcessedTable[];
  summary: SchemaSummary;
}

export class SchemaProcessor {
  private readonly fieldProcessor: FieldProcessor;

  constructor() {
    this.fieldProcessor = new FieldProcessor();
  }

  public async processSchema(schema: SchemaInfo): Promise<ProcessedSchema> {
    try {
      logger.info('Processing schema', { schema: schema.name, tables: schema.tables.length });

      const processedTables = await Promise.all(
        schema.tables.map((table) => this.processTable(table))
      );

      const summary = this.generateSchemaSummary(processedTables);

      return { name: schema.name, tables: processedTables, summary };
    } catch (error) {
      logger.error('Schema processing failed:', error);
      throw error;
    }
  }

  private async processTable(table: TableInfo): Promise<ProcessedTable> {
    try {
      const processedColumns = this.fieldProcessor.processFields(table.columns);
      const governance = this.generateTableGovernance(processedColumns);

      return { ...table, processedColumns, governance };
    } catch (error) {
      logger.error('Table processing failed:', { table: table.name, error });
      throw error;
    }
  }

  private generateTableGovernance(
    processedColumns: ProcessedTable['processedColumns']
  ): ProcessedTable['governance'] {
    const classifications = processedColumns.map((c) => c.classification);
    const sensitivities = processedColumns.map((c) => c.sensitivity);

    const hasPhiData = classifications.includes('PHI');
    const hasPiiData = classifications.includes('PII');
    const hasFinancialData = classifications.includes('Financial');

    let classification = 'General';
    if (hasPhiData) classification = 'PHI';
    else if (hasPiiData) classification = 'PII';
    else if (hasFinancialData) classification = 'Financial';

    let sensitivity = 'Low';
    if (sensitivities.includes('High')) sensitivity = 'High';
    else if (sensitivities.includes('Medium')) sensitivity = 'Medium';

    const complianceFrameworks: string[] = [];
    if (hasPhiData) complianceFrameworks.push('HIPAA');
    if (hasPiiData) complianceFrameworks.push('GDPR', 'CCPA');
    if (hasFinancialData) complianceFrameworks.push('SOX', 'PCI-DSS');

    const suggestedPolicies: string[] = [];
    if (sensitivity === 'High') {
      suggestedPolicies.push('Data encryption required', 'Access approval required', 'Regular access reviews');
    }
    if (hasPiiData || hasPhiData) {
      suggestedPolicies.push('Data retention policy', 'Right to be forgotten procedures');
    }

    return { classification, sensitivity, complianceFrameworks, suggestedPolicies };
  }

  private generateSchemaSummary(tables: ProcessedTable[]): SchemaSummary {
    const totalTables = tables.length;
    const totalColumns = tables.reduce((sum, t) => sum + t.columns.length, 0);
    const sensitiveDataTables = tables.filter(
      (t) => t.governance.sensitivity === 'High' || t.governance.sensitivity === 'Medium'
    ).length;

    const complianceSet = new Set<string>();
    for (const t of tables) {
      for (const f of t.governance.complianceFrameworks) complianceSet.add(f);
    }

    const recommendations: string[] = [
      `${sensitiveDataTables} of ${totalTables} tables contain sensitive data`,
      'Implement role-based access controls',
      'Regular compliance audits recommended',
      'Consider data classification labels',
    ];
    if (complianceSet.has('GDPR')) recommendations.push('GDPR compliance review required');
    if (complianceSet.has('HIPAA')) recommendations.push('HIPAA security controls needed');

    return {
      totalTables,
      totalColumns,
      sensitiveDataTables,
      complianceRequirements: Array.from(complianceSet),
      recommendations,
    };
  }
}

// export both ways so AnalysisService can `new (mod.SchemaProcessor ?? mod.default)()`
export default SchemaProcessor;



------------------------------------------------------------
FILE: backend\ai-service\src\prompts\fieldDiscovery.ts
------------------------------------------------------------
// src/prompts/fieldDiscovery.ts

/* eslint-disable max-lines */
type Sensitivity =
  | 'Low'
  | 'Medium'
  | 'High'
  | 'Critical';

type Classification =
  | 'General'
  | 'PII'
  | 'PHI'
  | 'Financial';

export interface FieldDiscoveryColumn {
  name: string;
  type: string;
  nullable: boolean;
  description?: string | null | undefined;
  /** Optional small set of example values for extra context */
  exampleValues?: readonly unknown[] | null | undefined;
}

export interface FieldDiscoveryResultField {
  name: string;
  type: string;
  classification: Classification;
  sensitivity: Sensitivity;
  description: string;
  suggestedRules: string[];
  dataPatterns: string[];
  businessContext: string;
}

export interface FieldDiscoveryRequest {
  schema: string;
  tableName: string;
  /** Optional business context of the table */
  context?: string | null | undefined;
  /** Table columns */
  columns: readonly FieldDiscoveryColumn[];
  /** Optional sample data (records/rows) */
  sampleData?: readonly Record<string, unknown>[] | null | undefined;
  /** Optional region for compliance nuance */
  region?: 'US' | 'EU' | 'Global';
  /** Optional hint for how deep the analysis should go */
  aiAnalysisDepth?: 'basic' | 'detailed' | 'comprehensive';
}

export const FIELD_DISCOVERY_SYSTEM_PROMPT = `
You are an expert data governance analyst specializing in:
- Field classification and data sensitivity analysis
- Compliance requirements (GDPR, HIPAA, CCPA, SOX, PCI-DSS)
- Data quality and governance best practices
- Business context understanding

GENERAL PRINCIPLES
- Be precise, practical, and implementation-oriented.
- Prefer least-privilege and data minimization.
- Recommend enforceable validation and indexing strategies when useful.

RESPONSE FORMAT (STRICT)
- Respond with STRICT JSON only. Do NOT include markdown, prose, or comments.
- Use these enums exactly:
  classification: "General" | "PII" | "PHI" | "Financial"
  sensitivity: "Low" | "Medium" | "High" | "Critical"
- Confidence is 0..1 (number).
- Recommendations arrays must be concise and actionable.
`.trim();

/**
 * Build a robust user prompt for field discovery.
 * - Strong typing (no implicit any)
 * - Sanitizes and truncates inputs to control token size
 * - Adds light heuristics to give the model helpful hints
 */
export function buildFieldDiscoveryPrompt(
  request: FieldDiscoveryRequest,
  opts?: {
    maxSampleRows?: number;
    maxCharsPerValue?: number;
    maxColumns?: number;
  }
): string {
  const maxSampleRows = Number.isFinite(opts?.maxSampleRows) ? Math.max(0, Number(opts?.maxSampleRows)) : 5;
  const maxCharsPerValue = Number.isFinite(opts?.maxCharsPerValue) ? Math.max(16, Number(opts?.maxCharsPerValue)) : 120;
  const maxColumns = Number.isFinite(opts?.maxColumns) ? Math.max(1, Number(opts?.maxColumns)) : 200;

  const cleanContext = sanitizeText(request.context);
  const cleanRegion = request.region ?? 'Global';
  const depth = request.aiAnalysisDepth ?? 'detailed';

  const columns = (request.columns ?? []).slice(0, maxColumns).map(safeColumn);
  const hints = buildHeuristicHints(columns);

  const sample = pruneSampleData(request.sampleData ?? [], maxSampleRows, maxCharsPerValue);

  const columnsBlock = columns
    .map((col) => {
      const nullable = col.nullable ? 'NULLABLE' : 'NOT NULL';
      const desc = col.description ? ` - ${sanitizeInline(col.description)}` : '';
      const examples = (col.exampleValues && col.exampleValues.length)
        ? ` (examples: ${stringifyInline(col.exampleValues.slice(0, 3), maxCharsPerValue)})`
        : '';
      return `- ${col.name} (${col.type}) ${nullable}${desc}${examples}`;
    })
    .join('\n');

  const sampleBlock = sample.length
    ? `Sample Data (first ${sample.length} rows):
${JSON.stringify(sample, null, 2)}`
    : '';

  const hintsBlock = hints.length
    ? `Heuristic Hints:
${hints.map((h) => `- ${h}`).join('\n')}`
    : '';

  // Final strict instructions to shape output for downstream services
  const strictJsonContract = `
RETURN STRICT JSON ONLY (no markdown, no comments) with this structure:
{
  "fields": [
    {
      "name": "field_name",
      "type": "data_type",
      "classification": "PII|PHI|Financial|General",
      "sensitivity": "High|Medium|Low|Critical",
      "description": "clear business meaning and purpose",
      "suggestedRules": ["specific quality rule 1", "specific quality rule 2"],
      "dataPatterns": ["observed pattern 1", "observed pattern 2"],
      "businessContext": "business context and usage"
    }
  ],
  "recommendations": {
    "governance": ["actionable governance recommendation 1", "recommendation 2"],
    "quality": ["actionable quality recommendation 1", "recommendation 2"],
    "compliance": ["specific compliance requirement 1", "requirement 2"]
  },
  "confidence": 0.0-1.0
}

CONSTRAINTS
- Keep arrays concise (max 5 items each) and prioritize high impact actions.
- Prefer column-specific recommendations over generic advice.
- Match enum values exactly as specified.
- If uncertain about a field, mark classification "General" with lower confidence.
`.trim();

  const userPrompt = `
Analyze the following database table and provide comprehensive field classification.

Context:
- Schema: ${sanitizeInline(request.schema)}
- Table: ${sanitizeInline(request.tableName)}
- Region: ${cleanRegion}
- Depth: ${depth}
${cleanContext ? `- Business Context: ${sanitizeInline(cleanContext)}` : ''}

Columns:
${columnsBlock}

${sampleBlock ? `\n${sampleBlock}\n` : ''}

${hintsBlock ? `\n${hintsBlock}\n` : ''}

${strictJsonContract}

FOCUS AREAS
1) Accurate classification based on names, types, and sample data.
2) Practical quality rules (validation, uniqueness, ranges, referential integrity).
3) Specific compliance requirements (GDPR/HIPAA/PCI-DSS/CCPA/SOX) relevant to the region.
4) Clear business value and usage context for each field.
5) Actionable, high-impact recommendations.
`.trim();

  return userPrompt;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Helpers
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function sanitizeText(input?: string | null | undefined): string | undefined {
  if (!input) return undefined;
  const trimmed = input.trim();
  if (!trimmed) return undefined;
  // very light sanitization to cut obvious prompt-injection vectors
  return trimmed.replace(/[<>]/g, '');
}

function sanitizeInline(input: string): string {
  return sanitizeText(input) ?? '';
}

function safeColumn(col: FieldDiscoveryColumn): FieldDiscoveryColumn {
  return {
    name: String(col.name).trim(),
    type: String(col.type).trim(),
    nullable: Boolean(col.nullable),
    description: col.description ?? undefined,
    exampleValues: col.exampleValues ?? undefined,
  };
}

function stringifyInline(values: readonly unknown[], maxCharsPerValue: number): string {
  return values
    .map((v) => compactValue(v, maxCharsPerValue))
    .join(', ');
}

function compactValue(v: unknown, maxCharsPerValue: number): string {
  try {
    const s = typeof v === 'string' ? v : JSON.stringify(v);
    const trimmed = (s ?? '').toString();
    if (trimmed.length <= maxCharsPerValue) return trimmed;
    return trimmed.slice(0, maxCharsPerValue) + 'â€¦';
  } catch {
    return '[unserializable]';
  }
}

function pruneSampleData(
  rows: readonly Record<string, unknown>[],
  maxRows: number,
  maxCharsPerValue: number
): Record<string, unknown>[] {
  const limited = rows.slice(0, Math.max(0, maxRows));
  return limited.map((row) => {
    const out: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(row)) {
      if (v === null || v === undefined) {
        out[k] = v as null | undefined;
        continue;
      }
      if (typeof v === 'string') {
        out[k] = redactString(v, maxCharsPerValue);
      } else if (typeof v === 'number' || typeof v === 'boolean') {
        out[k] = v;
      } else if (v instanceof Date) {
        out[k] = v.toISOString();
      } else {
        // stringify and truncate complex values
        out[k] = compactValue(v, maxCharsPerValue);
      }
    }
    return out;
  });
}

function redactString(s: string, maxChars: number): string {
  // simple redactions for PII-ish patterns
  const emailRx = /([A-Z0-9._%+-]+)@([A-Z0-9.-]+\.[A-Z]{2,})/gi;
  const phoneRx = /\+?\d{1,3}[-.\s]?\(?\d{2,4}\)?[-.\s]?\d{2,4}[-.\s]?\d{2,6}/g;
  const ssnRx = /\b\d{3}-?\d{2}-?\d{4}\b/g;

  let out = s.replace(emailRx, (_, user, host) => `${user[0]}***@${host}`);
  out = out.replace(phoneRx, (m) => m.slice(0, 3) + '***' + m.slice(-2));
  out = out.replace(ssnRx, '***-**-****');

  if (out.length <= maxChars) return out;
  return out.slice(0, maxChars) + 'â€¦';
}

function buildHeuristicHints(columns: readonly FieldDiscoveryColumn[]): string[] {
  const hints: string[] = [];

  for (const col of columns) {
    const name = col.name.toLowerCase();
    const type = col.type.toLowerCase();

    if (/email/.test(name)) {
      hints.push(`Column "${col.name}" likely contains email addresses â†’ consider "PII" with Medium sensitivity and format validation.`);
    }
    if (/(phone|mobile|cell)/.test(name)) {
      hints.push(`Column "${col.name}" likely contains phone numbers â†’ consider "PII"; recommend E.164 normalization and validation.`);
    }
    if (/(ssn|social[_-]?security)/.test(name)) {
      hints.push(`Column "${col.name}" may be SSN â†’ consider "PII" with High sensitivity; encryption at rest, restricted access.`);
    }
    if (/(dob|date[_-]?of[_-]?birth|birth[_-]?date)/.test(name) || (type.includes('date') && /birth/.test(name))) {
      hints.push(`Column "${col.name}" looks like date of birth â†’ "PII" with Medium/High sensitivity depending on jurisdiction.`);
    }
    if (/(card|cc|credit[_-]?card)/.test(name)) {
      hints.push(`Column "${col.name}" may be card data â†’ classify "Financial" with High sensitivity; tokenize or avoid storing PAN.`);
    }
    if (/(amount|price|salary|income|revenue)/.test(name)) {
      hints.push(`Column "${col.name}" is financial metric â†’ classify "Financial" (usually Medium sensitivity), enforce numeric ranges.`);
    }
    if (/(patient|diagnosis|medical|icd|phi)/.test(name)) {
      hints.push(`Column "${col.name}" suggests PHI â†’ classify "PHI" with High/Critical sensitivity and HIPAA safeguards.`);
    }
    if (/(ip[_-]?address|ipv4|ipv6)/.test(name)) {
      hints.push(`Column "${col.name}" may store IPs â†’ treat as "PII" in some frameworks; consider anonymization/retention policy.`);
    }
    if (/password|secret|token|api[_-]?key/.test(name)) {
      hints.push(`Column "${col.name}" looks like a credential/secret â†’ do not store raw; hash/tokenize and restrict access.`);
    }
  }

  return Array.from(new Set(hints)).slice(0, 12); // cap to keep the prompt lean
}



------------------------------------------------------------
FILE: backend\ai-service\src\prompts\naturalLanguage.ts
------------------------------------------------------------
export const NATURAL_LANGUAGE_SYSTEM_PROMPT = `You are an expert SQL analyst and data translator specializing in:
- Converting natural language to SQL queries
- Database schema understanding
- Query optimization and safety
- Business intelligence and analytics

Convert user queries into safe, efficient SQL statements with detailed explanations.`;

export const buildNaturalLanguagePrompt = (query: any): string => {
  const contextInfo = query.context ? `
Available Database Context:
- Schemas: ${query.context.schemas?.join(', ') || 'None specified'}
- Tables: ${query.context.tables?.join(', ') || 'None specified'}  
- Key Fields: ${query.context.fields?.join(', ') || 'None specified'}
` : '';

  return `Convert this natural language query to SQL:

User Query: "${query.query}"

${contextInfo}

Please provide a comprehensive JSON response:
{
  "sql": "Complete SELECT statement with proper formatting",
  "explanation": "Detailed step-by-step explanation of the query logic",
  "tables": ["table1", "table2"],
  "fields": ["field1", "field2", "field3"],
  "joinTypes": ["INNER", "LEFT", "RIGHT"],
  "aggregations": ["COUNT", "SUM", "AVG"],
  "filters": ["WHERE conditions applied"],
  "orderBy": ["Sorting criteria"],
  "confidence": 0.95,
  "warnings": ["Potential performance issues", "Security considerations"],
  "suggestions": ["Query optimization tips", "Alternative approaches"],
  "estimatedComplexity": "Simple|Medium|Complex",
  "estimatedExecutionTime": "Fast|Medium|Slow"
}

Important considerations:
1. Generate safe, read-only queries (SELECT only)
2. Include proper WHERE clauses to limit results
3. Use appropriate JOINs based on relationships
4. Consider performance implications
5. Flag potential security risks
6. Provide clear explanations for business users
7. Suggest LIMIT clauses for large datasets`;
};


------------------------------------------------------------
FILE: backend\ai-service\src\prompts\qualityRules.ts
------------------------------------------------------------
export const QUALITY_RULES_SYSTEM_PROMPT = `You are a data quality expert specializing in:
- Data validation and quality rules
- Business rule implementation
- Data profiling and anomaly detection
- Quality metrics and monitoring

Generate specific, measurable, and implementable data quality rules.`;

export const buildQualityRulesPrompt = (fieldInfo: any): string => {
  return `Generate specific data quality rules for the following field:

Field Information:
- Name: ${fieldInfo.name}
- Data Type: ${fieldInfo.type}
- Classification: ${fieldInfo.classification}
- Sensitivity: ${fieldInfo.sensitivity}
- Business Context: ${fieldInfo.businessContext}
- Observed Patterns: ${JSON.stringify(fieldInfo.dataPatterns || [])}
- Sample Data: ${JSON.stringify(fieldInfo.sampleData || [])}

Please provide a JSON response with specific, actionable quality rules:
{
  "rules": [
    {
      "name": "Descriptive rule name",
      "type": "validation|format|range|completeness|uniqueness|consistency",
      "description": "Detailed description of what the rule checks",
      "implementation": "Specific implementation details or SQL/logic",
      "severity": "Critical|High|Medium|Low",
      "automated": true|false,
      "frequency": "Real-time|Daily|Weekly|Monthly"
    }
  ]
}

Focus on:
1. Specific, measurable criteria
2. Clear implementation guidance
3. Appropriate severity levels
4. Automation feasibility
5. Business impact consideration`;
};


------------------------------------------------------------
FILE: backend\ai-service\src\routes\analysis.ts
------------------------------------------------------------
import { AnalysisController } from '@/controllers/AnalysisController';
import { authenticateToken } from '@/middleware/auth';
import { validateAnalysisRequest } from '@/middleware/validation';
import { Router } from 'express';

const router = Router();
const analysisController = new AnalysisController();

// All analysis routes require authentication
router.use(authenticateToken);

// Analysis endpoints
router.post('/schema', validateAnalysisRequest, analysisController.analyzeSchema);
router.post('/data-sample', analysisController.analyzeDataSample);
router.post('/quality-check', analysisController.performQualityCheck);

export default router;


------------------------------------------------------------
FILE: backend\ai-service\src\routes\discovery.ts
------------------------------------------------------------
import { DiscoveryController } from '@/controllers/DiscoveryController';
import { authenticateToken } from '@/middleware/auth';
import { aiRateLimitMw, discoveryRateLimitMw } from '@/middleware/rateLimit';
import { validateDiscoveryRequest, validateNLQuery } from '@/middleware/validation';
import { NextFunction, Request, Response, Router } from 'express';

const router = Router();
const controller = new DiscoveryController();

const asyncHandler =
  <T extends (req: Request, res: Response, next: NextFunction) => Promise<any>>(fn: T) =>
  (req: Request, res: Response, next: NextFunction) =>
    Promise.resolve(fn.call(controller, req, res, next)).catch(next);

// In dev weâ€™ll allow requests without a token; see auth middleware below
router.use(authenticateToken);

router.post('/', discoveryRateLimitMw, validateDiscoveryRequest, asyncHandler(controller.startDiscovery));
router.post('/query', aiRateLimitMw, validateNLQuery, asyncHandler(controller.processNaturalLanguageQuery));
router.post('/quality-rules', aiRateLimitMw, asyncHandler(controller.generateQualityRules));
router.post('/explain-violation', aiRateLimitMw, asyncHandler(controller.explainViolation));

router.get('/', asyncHandler(controller.listDiscoverySessions));
router.get('/:sessionId', asyncHandler(controller.getDiscoveryStatus));
router.delete('/:sessionId', asyncHandler(controller.deleteDiscoverySession));

export default router;



------------------------------------------------------------
FILE: backend\ai-service\src\routes\index.ts
------------------------------------------------------------
import { HealthController } from '@/controllers/HealthController';
import { Router } from 'express';
import analysisRoutes from './analysis';
import discoveryRoutes from './discovery';

const router = Router();
const healthController = new HealthController();

// Health check routes
router.get('/health', healthController.checkHealth);
router.get('/health/ready', healthController.checkReadiness);
router.get('/health/live', healthController.checkLiveness);

// Feature routes
router.use('/discovery', discoveryRoutes);
router.use('/analysis', analysisRoutes);

// API documentation endpoint
router.get('/docs', (req, res) => {
  void req;
  res.json({
    service: 'CWIC AI Service',
    version: process.env.APP_VERSION || '1.0.0',
    description: 'AI-powered data discovery and governance service',
    endpoints: {
      discovery: {
        'POST /api/discovery': 'Start field discovery session',
        'GET /api/discovery/:sessionId': 'Get discovery status and results',
        'GET /api/discovery': 'List discovery sessions',
        'DELETE /api/discovery/:sessionId': 'Delete discovery session',
        'POST /api/discovery/query': 'Process natural language query',
        'POST /api/discovery/quality-rules': 'Generate quality rules',
        'POST /api/discovery/explain-violation': 'Explain data quality violation'
      },
      analysis: {
        'POST /api/analysis/schema': 'Analyze database schema',
        'POST /api/analysis/data-sample': 'Analyze data samples',
        'POST /api/analysis/quality-check': 'Perform quality analysis'
      },
      health: {
        'GET /api/health': 'Service health status',
        'GET /api/health/ready': 'Readiness check',
        'GET /api/health/live': 'Liveness check'
      }
    }
  });
});

export default router;



------------------------------------------------------------
FILE: backend\ai-service\src\scripts\cleanup.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: backend\ai-service\src\scripts\migrate.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: backend\ai-service\src\scripts\seed.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: backend\ai-service\src\server.ts
------------------------------------------------------------
// src/server.ts
import { logger } from '@utils/logger';
import App from './app';

const PORT = Number(process.env.PORT ?? 3003);     // << default 3003, not 8003
const HOST = process.env.HOST || '0.0.0.0';

function start() {
  try {
    const expressApp = new App().getApp();

    // Ensure a simple health endpoint exists here (even if App already has one)
    expressApp.get('/health', (_req, res) => {
      res.json({ ok: true, service: 'ai-service', pid: process.pid });
    });

    const server = expressApp.listen(PORT, HOST, () => {
      logger.info(`ðŸš€ AI Service listening on http://${HOST}:${PORT}`);
      logger.info(`ðŸ“ Health: http://${HOST}:${PORT}/health`);
      logger.info(`ðŸ§­ Docs:   http://${HOST}:${PORT}/api/docs`);
      logger.info(`ðŸŒ± NODE_ENV=${process.env.NODE_ENV || 'development'}`);
    });

    server.on('error', (err: any) => {
      logger.error('HTTP server error:', {
        message: err?.message,
        code: err?.code,
        stack: err?.stack,
      });
    });

    const shutdown = (signal: string) => {
      logger.warn(`Received ${signal}. Shutting down...`);
      server.close(() => {
        logger.info('HTTP server closed');
        process.exit(0);
      });
      setTimeout(() => process.exit(1), 5000).unref();
    };

    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));

    process.on('uncaughtException', (err) => {
      logger.error('Uncaught exception:', { message: err.message, stack: err.stack });
    });
    process.on('unhandledRejection', (reason: any) => {
      logger.error('Unhandled rejection:', { reason: reason?.message || String(reason), stack: reason?.stack });
    });
  } catch (err: any) {
    logger.error('Fatal startup error:', { message: err.message, stack: err.stack });
  }
}

start();



------------------------------------------------------------
FILE: backend\ai-service\src\services\AIService.ts
------------------------------------------------------------
import { openai } from '@config/openai';
import { logger } from '@utils/logger';
import { CacheService } from './CacheService';

export interface FieldDiscoveryRequest {
  schema: string;
  tableName: string;
  columns: Array<{
    name: string;
    type: string;
    nullable: boolean;
    description?: string;
  }>;
  sampleData?: any[];
  context?: string;
}

export interface FieldDiscoveryResponse {
  fields: Array<{
    name: string;
    type: string;
    classification: 'PII' | 'PHI' | 'Financial' | 'General';
    sensitivity: 'High' | 'Medium' | 'Low';
    description: string;
    suggestedRules: string[];
    dataPatterns: string[];
    businessContext: string;
  }>;
  recommendations: {
    governance: string[];
    quality: string[];
    compliance: string[];
  };
  confidence: number;
  isAiGenerated: boolean; // Track if this came from AI or fallback
}

export interface NaturalLanguageQuery {
  query: string;
  context?: {
    schemas: string[];
    tables: string[];
    fields: string[];
  };
}

export interface QueryResult {
  sql: string;
  explanation: string;
  tables: string[];
  fields: string[];
  confidence: number;
  warnings: string[];
  isAiGenerated: boolean;
}

export class AIService {
  private cacheService: CacheService;

  constructor() {
    this.cacheService = new CacheService();
  }

  public async discoverFields(request: FieldDiscoveryRequest): Promise<FieldDiscoveryResponse> {
    try {
      const cacheKey = `field_discovery:${JSON.stringify(request)}`;
      const cached = await this.cacheService.get(cacheKey);
      
      if (cached) {
        logger.info('Returning cached field discovery result');
        return JSON.parse(cached);
      }

      // Check if OpenAI is available
      if (!openai.isAvailable()) {
        logger.warn('OpenAI not available - using fallback field discovery');
        return this.fallbackFieldDiscovery(request);
      }

      const prompt = this.buildFieldDiscoveryPrompt(request);
      
      const response = await openai.createChatCompletion({
        model: process.env.OPENAI_MODEL || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: `You are an expert data governance analyst specializing in field classification, 
                     data sensitivity analysis, and compliance requirements. Analyze database fields 
                     and provide comprehensive governance recommendations.`
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: parseInt(process.env.OPENAI_MAX_TOKENS || '4000'),
        temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.1'),
        response_format: { type: 'json_object' }
      });

      if (!response || !response.choices[0]?.message?.content) {
        logger.warn('No response from OpenAI - using fallback');
        return this.fallbackFieldDiscovery(request);
      }

      const result = JSON.parse(response.choices[0].message.content) as FieldDiscoveryResponse;
      result.isAiGenerated = true;
      
      // Cache the result for 1 hour
      await this.cacheService.set(cacheKey, JSON.stringify(result), 3600);
      
      logger.info('Field discovery completed successfully with AI', {
        schema: request.schema,
        table: request.tableName,
        fieldsAnalyzed: request.columns.length
      });

      return result;

    } catch (error) {
      logger.error('AI field discovery failed, using fallback:', error);
      return this.fallbackFieldDiscovery(request);
    }
  }

  public async processNaturalLanguageQuery(query: NaturalLanguageQuery): Promise<QueryResult> {
    try {
      const cacheKey = `nlq:${JSON.stringify(query)}`;
      const cached = await this.cacheService.get(cacheKey);
      
      if (cached) {
        logger.info('Returning cached natural language query result');
        return JSON.parse(cached);
      }

      // Check if OpenAI is available
      if (!openai.isAvailable()) {
        logger.warn('OpenAI not available - using fallback query processing');
        return this.fallbackNaturalLanguageQuery(query);
      }

      const prompt = this.buildNLQueryPrompt(query);
      
      const response = await openai.createChatCompletion({
        model: process.env.OPENAI_MODEL || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: `You are an expert SQL analyst. Convert natural language queries into 
                     SQL statements with detailed explanations and safety warnings.`
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: parseInt(process.env.OPENAI_MAX_TOKENS || '4000'),
        temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.1'),
        response_format: { type: 'json_object' }
      });

      if (!response || !response.choices[0]?.message?.content) {
        logger.warn('No response from OpenAI - using fallback');
        return this.fallbackNaturalLanguageQuery(query);
      }

      const result = JSON.parse(response.choices[0].message.content) as QueryResult;
      result.isAiGenerated = true;
      
      // Cache the result for 30 minutes
      await this.cacheService.set(cacheKey, JSON.stringify(result), 1800);
      
      logger.info('Natural language query processed successfully with AI');
      return result;

    } catch (error) {
      logger.error('AI query processing failed, using fallback:', error);
      return this.fallbackNaturalLanguageQuery(query);
    }
  }

  public async generateQualityRules(fieldInfo: any): Promise<string[]> {
    try {
      if (!openai.isAvailable()) {
        logger.warn('OpenAI not available - using fallback quality rules');
        return this.fallbackQualityRules(fieldInfo);
      }

      const prompt = `Generate data quality rules for the following field:
        Field Name: ${fieldInfo.name}
        Data Type: ${fieldInfo.type}
        Classification: ${fieldInfo.classification}
        Sample Data: ${JSON.stringify(fieldInfo.sampleData || [])}
        
        Return a JSON array of specific, actionable quality rules.`;

      const response = await openai.createChatCompletion({
        model: process.env.OPENAI_MODEL || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are a data quality expert. Generate specific, measurable quality rules.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 1000,
        temperature: 0.1,
        response_format: { type: 'json_object' }
      });

      if (!response || !response.choices[0]?.message?.content) {
        return this.fallbackQualityRules(fieldInfo);
      }

      const result = JSON.parse(response.choices[0].message.content);
      return result.rules || this.fallbackQualityRules(fieldInfo);

    } catch (error) {
      logger.error('AI quality rule generation failed, using fallback:', error);
      return this.fallbackQualityRules(fieldInfo);
    }
  }

  public async explainViolation(violation: any): Promise<string> {
    try {
      if (!openai.isAvailable()) {
        return this.fallbackViolationExplanation(violation);
      }

      const prompt = `Explain this data quality violation in simple terms:
        Rule: ${violation.rule}
        Field: ${violation.field}
        Value: ${violation.value}
        Error: ${violation.error}
        
        Provide a clear explanation and suggested fix.`;

      const response = await openai.createChatCompletion({
        model: process.env.OPENAI_MODEL || 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are a helpful data analyst explaining quality issues.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.3
      });

      if (!response || !response.choices[0]?.message?.content) {
        return this.fallbackViolationExplanation(violation);
      }

      return response.choices[0].message.content;

    } catch (error) {
      logger.error('AI violation explanation failed, using fallback:', error);
      return this.fallbackViolationExplanation(violation);
    }
  }

  // Fallback methods for when AI is not available
  private fallbackFieldDiscovery(request: FieldDiscoveryRequest): FieldDiscoveryResponse {
    const fields = request.columns.map(col => {
      const classification = this.classifyFieldBasic(col.name, col.type);
      const sensitivity = this.determineSensitivityBasic(classification);
      
      return {
        name: col.name,
        type: col.type,
        classification,
        sensitivity,
        description: `${col.type} field containing ${classification.toLowerCase()} data`,
        suggestedRules: this.getBasicQualityRules(col.type, classification),
        dataPatterns: this.detectBasicPatterns(col.name, col.type),
        businessContext: `Data field in ${request.tableName} table`
      };
    });

    return {
      fields,
      recommendations: {
        governance: ['Implement data classification policy', 'Set up access controls'],
        quality: ['Add data validation rules', 'Monitor data quality metrics'],
        compliance: ['Review compliance requirements', 'Implement audit logging']
      },
      confidence: 0.7, // Lower confidence for rule-based classification
      isAiGenerated: false
    };
  }

  private fallbackNaturalLanguageQuery(query: NaturalLanguageQuery): QueryResult {
    // Simple keyword-based SQL generation
    const lowerQuery = query.query.toLowerCase();
    let sql = 'SELECT ';
    
    if (lowerQuery.includes('count') || lowerQuery.includes('how many')) {
      sql += 'COUNT(*) ';
    } else {
      sql += '* ';
    }
    
    sql += 'FROM ';
    
    // Try to detect table names from context or query
    if (query.context?.tables && query.context.tables.length > 0) {
      sql += query.context.tables[0];
    } else if (lowerQuery.includes('user')) {
      sql += 'users';
    } else if (lowerQuery.includes('order')) {
      sql += 'orders';
    } else {
      sql += 'table_name';
    }

    return {
      sql,
      explanation: 'Basic SQL query generated using keyword matching (AI not available)',
      tables: query.context?.tables || ['table_name'],
      fields: query.context?.fields || ['*'],
      confidence: 0.3, // Low confidence for keyword-based generation
      warnings: ['AI service not available - this is a basic keyword-based query'],
      isAiGenerated: false
    };
  }

  private fallbackQualityRules(fieldInfo: any): string[] {
    const rules = [];
    
    if (fieldInfo.type?.includes('varchar') || fieldInfo.type?.includes('text')) {
      rules.push('Validate string length');
      rules.push('Check for null values');
    }
    
    if (fieldInfo.type?.includes('int') || fieldInfo.type?.includes('number')) {
      rules.push('Validate numeric range');
      rules.push('Check for negative values');
    }
    
    if (fieldInfo.name?.toLowerCase().includes('email')) {
      rules.push('Validate email format');
    }
    
    if (fieldInfo.name?.toLowerCase().includes('phone')) {
      rules.push('Validate phone number format');
    }
    
    return rules.length > 0 ? rules : ['Basic data validation required'];
  }

  private fallbackViolationExplanation(violation: any): string {
    return `Data quality issue detected in field "${violation.field}". The rule "${violation.rule}" failed because: ${violation.error}. Please review the data and apply appropriate corrections.`;
  }

  // Helper methods for basic classification
  private classifyFieldBasic(name: string, type: string): 'PII' | 'PHI' | 'Financial' | 'General' {
    const lowerName = name.toLowerCase();
    
    if (lowerName.includes('email') || lowerName.includes('phone') || lowerName.includes('name')) {
      return 'PII';
    }
    if (lowerName.includes('medical') || lowerName.includes('health')) {
      return 'PHI';
    }
    if (lowerName.includes('payment') || lowerName.includes('amount') || lowerName.includes('price')) {
      return 'Financial';
    }
    
    return 'General';
  }

  private determineSensitivityBasic(classification: string): 'High' | 'Medium' | 'Low' {
    switch (classification) {
      case 'PHI': return 'High';
      case 'PII': case 'Financial': return 'Medium';
      default: return 'Low';
    }
  }

  private getBasicQualityRules(type: string, classification: string): string[] {
    const rules = ['Not null validation'];
    
    if (type.includes('varchar')) {
      rules.push('String length validation');
    }
    
    if (classification === 'PII' || classification === 'PHI') {
      rules.push('Data encryption required');
    }
    
    return rules;
  }

  private detectBasicPatterns(name: string, type: string): string[] {
    const patterns = [];
    
    if (name.toLowerCase().includes('email')) {
      patterns.push('Email format');
    }
    if (name.toLowerCase().includes('phone')) {
      patterns.push('Phone number format');
    }
    if (type.includes('date') || type.includes('timestamp')) {
      patterns.push('Date format');
    }
    
    return patterns;
  }

  // Existing helper methods...
  private buildFieldDiscoveryPrompt(request: FieldDiscoveryRequest): string {
    return `Analyze the following database table and provide comprehensive field classification:

Schema: ${request.schema}
Table: ${request.tableName}
Context: ${request.context || 'Not provided'}

Columns:
${request.columns.map(col => 
  `- ${col.name} (${col.type}) ${col.nullable ? 'NULLABLE' : 'NOT NULL'} ${col.description ? '- ' + col.description : ''}`
).join('\n')}

${request.sampleData ? `Sample Data (first 5 rows):
${JSON.stringify(request.sampleData.slice(0, 5), null, 2)}` : ''}

Please provide a JSON response with comprehensive field analysis.`;
  }

  private buildNLQueryPrompt(query: NaturalLanguageQuery): string {
    const contextInfo = query.context ? `
Available Context:
- Schemas: ${query.context.schemas?.join(', ') || 'None'}
- Tables: ${query.context.tables?.join(', ') || 'None'}
- Fields: ${query.context.fields?.join(', ') || 'None'}
` : '';

    return `Convert this natural language query to SQL:
"${query.query}"

${contextInfo}

Please provide a JSON response with SQL and explanation.`;
  }
}


------------------------------------------------------------
FILE: backend\ai-service\src\services\AnalysisService.ts
------------------------------------------------------------
// src/services/AnalysisService.ts
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';

// Import concrete classes but DO NOT rely on their exported types
// (your current module doesn't export DataProcessor/DataSample types)
import * as DataProcessorMod from '@/processors/DataProcessor';
import * as SchemaProcessorMod from '@/processors/SchemaProcessor';
import { AIService } from './AIService';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Minimal contracts (kept small to avoid coupling & missing exports)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export type Severity = 'Low' | 'Medium' | 'High' | 'Critical';
export type RuleStatus = 'passed' | 'warning' | 'failed';

export interface DataSample {
  columnName: string;
  values: unknown[];
}

export interface QualityIssue {
  column: string;
  type:
    | 'null_values'
    | 'format_inconsistency'
    | 'out_of_range'
    | 'uniqueness'
    | 'referential'
    | 'custom';
  severity: Severity;
  count: number;
  sample?: unknown[];
  message?: string;
}

export interface IDataProcessor {
  analyzeSampleData(
    samples: DataSample[],
  ): Promise<{ analysis: Record<string, unknown>[]; qualityIssues: QualityIssue[] }>;
}

export interface SchemaInfo {
  name: string;
  // optional extra fields your processor might use
  [k: string]: unknown;
}

export interface ISchemaProcessor {
  processSchema(schema: SchemaInfo): Promise<unknown>;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Result types
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export interface QualityRuleResult {
  ruleId: string;
  ruleName: string;
  status: RuleStatus;
  testedRecords: number;
  passedRecords: number;
  failedRecords: number;
  successRate: number; // 0..100
  aiExplanation?: string;
  recommendations?: string[];
}

export interface AnalysisSummary {
  totalColumns: number;
  qualityIssues: number;
  highSeverityIssues: number;
}

export interface DataSampleAnalysisResult {
  analysis: ReadonlyArray<Record<string, unknown>>;
  qualityIssues: ReadonlyArray<QualityIssue>;
  recommendations: ReadonlyArray<string>;
  summary: AnalysisSummary;
  analysisMetadata: {
    analyzedAt: string;
    analyzedBy: string;
    version: string;
  };
}

export interface SchemaAIInsights {
  overallAssessment: string;
  riskAreas: string[];
  complianceGaps: string[];
  optimizationOpportunities: string[];
}

export interface SchemaAnalysisResult {
  processed: unknown;
  aiInsights: SchemaAIInsights;
  analysisMetadata: {
    analyzedAt: string;
    analyzedBy: string;
    version: string;
  };
}

export interface QualityCheckResult {
  dataSourceId: string;
  results: ReadonlyArray<QualityRuleResult>;
  summary: {
    totalRules: number;
    passed: number;
    failed: number;
    warnings: number;
  };
  analysisMetadata: {
    analyzedAt: string;
    analyzedBy: string;
    version: string;
  };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Utils
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const SERVICE_VERSION = '1.0';

function asApiError(err: unknown, fallback: string, status = 500): APIError {
  if (err instanceof APIError) return err;
  const msg = err instanceof Error ? err.message : fallback;
  return new APIError(msg, status, err);
}

async function withTimeout<T>(p: Promise<T>, ms: number, label: string): Promise<T> {
  let t: NodeJS.Timeout | undefined;
  try {
    const timeout = new Promise<never>((_, rej) =>
      (t = setTimeout(() => rej(new APIError(`${label} timed out after ${ms}ms`, 504)), ms)),
    );
    return await Promise.race([p, timeout]);
  } finally {
    if (t) clearTimeout(t);
  }
}

function isHigh(sev: Severity): boolean {
  return sev === 'High' || sev === 'Critical';
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Service
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export class AnalysisService {
  private readonly schemaProcessor: ISchemaProcessor;
  private readonly dataProcessor: IDataProcessor;
  private readonly ai: AIService;
  private readonly aiTimeoutMs: number;

  constructor(deps?: {
    schemaProcessor?: ISchemaProcessor;
    dataProcessor?: IDataProcessor;
    aiService?: AIService;
    aiTimeoutMs?: number;
  }) {
    // Instantiate from modules if not injected
    const DefaultSchemaProcessor =
    ( SchemaProcessorMod as any).SchemaProcessor ?? (SchemaProcessorMod as any).default;
    const DefaultDataProcessor =
    (DataProcessorMod as any).DataProcessor ?? (DataProcessorMod as any).default;


    this.schemaProcessor = deps?.schemaProcessor ?? new DefaultSchemaProcessor();
    this.dataProcessor = deps?.dataProcessor ?? new DefaultDataProcessor();
    this.ai = deps?.aiService ?? new AIService();
    this.aiTimeoutMs = deps?.aiTimeoutMs ?? Number(process.env.AI_TIMEOUT_MS ?? 8000);
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Schema Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  public async analyzeSchema(schema: SchemaInfo, userId: string): Promise<SchemaAnalysisResult> {
    try {
      this.assertUser(userId);
      this.assertSchema(schema);

      logger.info('AnalysisService: schema analysis start', { userId, schema: schema.name });
      const processed = await this.schemaProcessor.processSchema(schema);

      const aiInsights = await this.safeSchemaInsights(processed);

      const res: SchemaAnalysisResult = {
        processed,
        aiInsights,
        analysisMetadata: {
          analyzedAt: new Date().toISOString(),
          analyzedBy: userId,
          version: SERVICE_VERSION,
        },
      };

      logger.info('AnalysisService: schema analysis complete', { userId, schema: schema.name });
      return res;
    } catch (err) {
      logger.error('AnalysisService: schema analysis error', { error: err });
      throw asApiError(err, 'Schema analysis failed', 500);
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Data Sample Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  public async analyzeDataSample(samples: DataSample[], userId: string): Promise<DataSampleAnalysisResult> {
    try {
      this.assertUser(userId);
      this.assertSamples(samples);

      logger.info('AnalysisService: data sample analysis start', { userId, samples: samples.length });

      const { analysis, qualityIssues } = await this.dataProcessor.analyzeSampleData(samples);

      const recommendations = await this.buildDataRecommendations(analysis, qualityIssues);

      const res: DataSampleAnalysisResult = {
        analysis,
        qualityIssues,
        recommendations,
        summary: {
          totalColumns: samples.length,
          qualityIssues: qualityIssues.length,
          highSeverityIssues: qualityIssues.filter((q) => isHigh(q.severity)).length,
        },
        analysisMetadata: {
          analyzedAt: new Date().toISOString(),
          analyzedBy: userId,
          version: SERVICE_VERSION,
        },
      };

      logger.info('AnalysisService: data sample analysis complete', {
        userId,
        samplesAnalyzed: samples.length,
        issuesFound: qualityIssues.length,
      });
      return res;
    } catch (err) {
      logger.error('AnalysisService: data sample analysis error', { error: err });
      throw asApiError(err, 'Data sample analysis failed', 500);
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Quality Check (mocked engine) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  public async performQualityCheck(
    dataSourceId: string,
    rules: ReadonlyArray<Record<string, unknown>> | undefined,
    userId: string,
  ): Promise<QualityCheckResult> {
    try {
      this.assertUser(userId);
      if (!dataSourceId) throw new APIError('dataSourceId is required', 400);

      logger.info('AnalysisService: quality check start', {
        userId,
        dataSourceId,
        rules: rules?.length ?? 0,
      });

      const base = this.mockQualityResults(rules ?? []);
      const enhanced = await this.enhanceRuleResults(base);

      const summary = {
        totalRules: rules?.length ?? 0,
        passed: enhanced.filter((r) => r.status === 'passed').length,
        failed: enhanced.filter((r) => r.status === 'failed').length,
        warnings: enhanced.filter((r) => r.status === 'warning').length,
      };

      const res: QualityCheckResult = {
        dataSourceId,
        results: enhanced,
        summary,
        analysisMetadata: {
          analyzedAt: new Date().toISOString(),
          analyzedBy: userId,
          version: SERVICE_VERSION,
        },
      };

      logger.info('AnalysisService: quality check complete', {
        userId,
        dataSourceId,
        rulesChecked: rules?.length ?? 0,
      });
      return res;
    } catch (err) {
      logger.error('AnalysisService: quality check error', { error: err });
      throw asApiError(err, 'Quality check failed', 500);
    }
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * Private: AI insights for schema
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async safeSchemaInsights(processed: unknown): Promise<SchemaAIInsights> {
    type TableGov = {
      sensitivity?: Severity | string;
      classification?: 'General' | 'PII' | 'PHI' | 'Financial' | string;
      complianceFrameworks?: string[];
      suggestedPolicies?: string[];
    };
    type MinimalProcessed = { name?: string; tables?: { governance?: TableGov }[] };

    const schema = (processed as MinimalProcessed) ?? {};
    const tables: { governance?: TableGov }[] = Array.isArray(schema.tables) ? [...schema.tables] : [];

    // Safety: ensure mutable arrays (avoid readonly assignment issues)
    const snapshot = tables.slice(0, 100).map((t) => ({
      sensitivity: (t.governance?.sensitivity ?? 'Low').toString(),
      classification: (t.governance?.classification ?? 'General').toString(),
      frameworks: Array.isArray(t.governance?.complianceFrameworks)
        ? [...t.governance!.complianceFrameworks!]
        : ([] as string[]),
      policyCount: Array.isArray(t.governance?.suggestedPolicies) ? t.governance!.suggestedPolicies!.length : 0,
    }));

    // If AI service exposes a summarization helper, call it. Otherwise, fall back.
    const hasSummarize =
      this.ai && (typeof (this.ai as any).safeSummarize === 'function' || typeof (this.ai as any).summarize === 'function');

    let overallAssessment = this.fallbackOverallAssessment(tables);
    if (hasSummarize) {
      try {
        const fn = (this.ai as any).safeSummarize ?? (this.ai as any).summarize;
        const out = await withTimeout(
          Promise.resolve(fn.call(this.ai, { topic: 'schema-assessment', payload: { tableCount: tables.length, snapshot } })),
          this.aiTimeoutMs,
          'AI schema assessment',
        );
        if (typeof out === 'string' && out.trim()) overallAssessment = out.trim();
      } catch {
        // keep fallback
      }
    }

    return {
      overallAssessment,
      riskAreas: this.deriveRiskAreas(tables),
      complianceGaps: this.deriveComplianceGaps(tables),
      optimizationOpportunities: this.deriveOptimizations(tables),
    };
  }

  private fallbackOverallAssessment(
    tables: ReadonlyArray<{ governance?: { sensitivity?: string; classification?: string; complianceFrameworks?: string[] } }>,
  ): string {
    const total = tables.length || 1;
    const sensitive = tables.filter((t) => (t.governance?.sensitivity ?? 'Low') !== 'Low').length;
    const frameworks = new Set<string>();
    for (const t of tables) {
      const list = t.governance?.complianceFrameworks ?? [];
      for (let i = 0; i < list.length; i++) frameworks.add(list[i] as string);
    }
    if (sensitive / total > 0.5) {
      return `High-risk schema: ${sensitive}/${total} tables contain non-low sensitivity data. ${frameworks.size} compliance frameworks detected. Prioritize governance.`;
    }
    if (sensitive > 0) {
      return `Moderate-risk schema: ${sensitive} sensitive tables. Frameworks: ${[...frameworks].join(', ') || 'None'}. Maintain standard governance.`;
    }
    return 'Low-risk schema: mostly general data. Basic governance practices are sufficient.';
  }

  private deriveRiskAreas(tables: ReadonlyArray<{ governance?: { sensitivity?: string; classification?: string } }>): string[] {
    const risks: string[] = [];
    const hi = tables.filter(
      (t) => (t.governance?.sensitivity ?? 'Low') === 'High' || (t.governance?.sensitivity ?? 'Low') === 'Critical',
    ).length;
    if (hi) risks.push(`${hi} table(s) contain highly sensitive data (strict access & encryption).`);

    const pii = tables.filter((t) => t.governance?.classification === 'PII').length;
    if (pii) risks.push(`${pii} table(s) contain PII; ensure privacy controls & minimization.`);

    const phi = tables.filter((t) => t.governance?.classification === 'PHI').length;
    if (phi) risks.push(`${phi} table(s) contain PHI; HIPAA safeguards required.`);

    return risks;
  }

  private deriveComplianceGaps(tables: ReadonlyArray<{ governance?: { complianceFrameworks?: string[] } }>): string[] {
    const frameworks = new Set<string>();
    for (const t of tables) {
      const list = t.governance?.complianceFrameworks ?? [];
      for (let i = 0; i < list.length; i++) frameworks.add(list[i] as string);
    }
    const gaps: string[] = [];
    if (frameworks.has('GDPR')) gaps.push('Validate GDPR data subject rights, retention, and DPIA for high-risk processing.');
    if (frameworks.has('HIPAA')) gaps.push('Perform HIPAA security risk analysis and enforce PHI audit controls.');
    if (frameworks.has('PCI-DSS')) gaps.push('Confirm segmentation & encryption for cardholder data.');
    return gaps;
  }

  private deriveOptimizations(
    tables: ReadonlyArray<{ governance?: { suggestedPolicies?: string[]; classification?: string } }>,
  ): string[] {
    const out: string[] = [];
    let noPolicy = 0;
    let general = 0;
    for (let i = 0; i < tables.length; i++) {
      const g = tables[i]?.governance;
      if (!g) continue;
      if (!Array.isArray(g.suggestedPolicies) || g.suggestedPolicies.length === 0) noPolicy++;
      if (g.classification === 'General') general++;
    }
    if (noPolicy) out.push(`${noPolicy} table(s) lack governance policies; define baseline classification and retention.`);
    if (tables.length && general / tables.length > 0.8) {
      out.push('Large share of tables classified as General; consider targeted reclassification review.');
    }
    out.push('Automate periodic discovery and policy drift detection.');
    out.push('Schedule quarterly compliance checks for sensitive domains.');
    return out;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * Private: Data recommendations
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private async buildDataRecommendations(
    analysis: ReadonlyArray<Record<string, unknown>>,
    issues: ReadonlyArray<QualityIssue>,
  ): Promise<string[]> {
    const recs = new Set<string>();
    const hi = issues.filter((q) => isHigh(q.severity)).length;
    if (hi) recs.add(`Address ${hi} high/critical quality issues immediately.`);

    if (issues.some((q) => q.type === 'null_values')) recs.add('Add NOT NULL/CHECK constraints or upstream validation.');
    if (issues.some((q) => q.type === 'format_inconsistency')) recs.add('Standardize formats with validation/canonicalization.');

    // Optional AI tip if method exists
    const hasSummarize =
      this.ai && (typeof (this.ai as any).safeSummarize === 'function' || typeof (this.ai as any).summarize === 'function');
    if (hasSummarize) {
      try {
        const fn = (this.ai as any).safeSummarize ?? (this.ai as any).summarize;
        const maybe = await withTimeout(
          Promise.resolve(fn.call(this.ai, { topic: 'data-quality-highlights', payload: { issues: issues.slice(0, 50) } })),
          Math.min(this.aiTimeoutMs, 3000),
          'AI data tip',
        );
        if (typeof maybe === 'string' && maybe.trim()) recs.add(maybe.trim());
      } catch {
        // ignore AI failure
      }
    }

    recs.add('Enable continuous monitoring & alerting for key quality dimensions.');
    recs.add('Publish a data quality dashboard with issue backlog & owners.');

    return Array.from(recs);
  }

  private mockQualityResults(_rules: ReadonlyArray<Record<string, unknown>>): QualityRuleResult[] {
    return [
      {
        ruleId: 'email_format',
        ruleName: 'Email Format Validation',
        status: 'passed',
        testedRecords: 1000,
        passedRecords: 998,
        failedRecords: 2,
        successRate: 99.8,
      },
      {
        ruleId: 'phone_format',
        ruleName: 'Phone Number Format',
        status: 'warning',
        testedRecords: 1000,
        passedRecords: 950,
        failedRecords: 50,
        successRate: 95.0,
      },
      {
        ruleId: 'null_check',
        ruleName: 'Required Field Validation',
        status: 'failed',
        testedRecords: 1000,
        passedRecords: 800,
        failedRecords: 200,
        successRate: 80.0,
      },
    ];
  }

  private async enhanceRuleResults(results: ReadonlyArray<QualityRuleResult>): Promise<QualityRuleResult[]> {
    const out: QualityRuleResult[] = [];
    const hasSummarize =
      this.ai && (typeof (this.ai as any).safeSummarize === 'function' || typeof (this.ai as any).summarize === 'function');
    for (let i = 0; i < results.length; i++) {
      const r = results[i];
      const baseExp = this.baseRuleExplanation(r);
      const baseRecs = this.baseRuleRecommendations(r);

      let aiNote: string | undefined;
      if (hasSummarize) {
        try {
          const fn = (this.ai as any).safeSummarize ?? (this.ai as any).summarize;
          const maybe = await withTimeout(
            Promise.resolve(fn.call(this.ai, { topic: 'quality-rule-explanation', payload: { id: r.ruleId, status: r.status, rate: r.successRate } })),
            Math.min(this.aiTimeoutMs, 3000),
            `AI note for ${r.ruleId}`,
          );
          if (typeof maybe === 'string' && maybe.trim()) aiNote = maybe.trim();
        } catch {
          // ignore
        }
      }

      out.push({
        ...r,
        aiExplanation: aiNote ?? baseExp,
        recommendations: Array.from(new Set([...(r.recommendations ?? []), ...baseRecs])),
      });
    }
    return out;
  }

  private baseRuleExplanation(r: QualityRuleResult): string {
    if (r.status === 'passed') return `Rule "${r.ruleName}" performing well (${r.successRate}% success).`;
    if (r.status === 'warning')
      return `Rule "${r.ruleName}" shows moderate issues (${r.failedRecords} failures). Investigate upstream validation.`;
    return `Rule "${r.ruleName}" failing (${r.failedRecords} failures). Immediate remediation required.`;
  }

  private baseRuleRecommendations(r: QualityRuleResult): string[] {
    const recs: string[] = [];
    if (r.status === 'failed') {
      recs.push('Identify root cause and add upstream validation.');
      recs.push('Cleanse/backfill existing bad records.');
      recs.push('Add tests & monitoring to prevent regressions.');
    } else if (r.status === 'warning') {
      recs.push('Track trend; tighten validation where safe.');
      recs.push('Add sampling-based alerts.');
    }
    return recs;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Guards â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  private assertUser(userId: string): void {
    if (!userId || typeof userId !== 'string') throw new APIError('Invalid userId', 400);
  }

  private assertSchema(schema: unknown): asserts schema is SchemaInfo {
    if (!schema || typeof (schema as SchemaInfo).name !== 'string') {
      throw new APIError('Invalid schema payload', 400);
    }
  }

  private assertSamples(samples: unknown): asserts samples is DataSample[] {
    if (!Array.isArray(samples)) throw new APIError('samples must be an array', 400);
    if (samples.length === 0) throw new APIError('At least one sample is required', 400);
    for (let i = 0; i < samples.length; i++) {
      const s = samples[i] as Partial<DataSample>;
      if (!s || typeof s.columnName !== 'string' || !Array.isArray(s.values)) {
        throw new APIError(`Invalid sample at index ${i}`, 400);
      }
    }
  }
}



------------------------------------------------------------
FILE: backend\ai-service\src\services\CacheService.ts
------------------------------------------------------------
// src/services/CacheService.ts
import { redis } from '@/config/redis';
import { logger } from '@/utils/logger';

function toSeconds(ms: number): number {
  return Math.max(1, Math.floor(ms / 1000));
}

export class CacheService {
  private readonly defaultTTLSeconds: number;

  constructor() {
    const raw = process.env.REDIS_TTL ?? '3600';
    const ttlNum = Number(raw);
    // If someone passed milliseconds (very large), normalize to seconds.
    this.defaultTTLSeconds = ttlNum > 7 * 24 * 3600 ? toSeconds(ttlNum) : (ttlNum || 3600);
  }

  /* ----------------------- Basic primitives ----------------------- */

  public async get(key: string): Promise<string | null> {
    try {
      return await redis.get(key);
    } catch (error) {
      logger.error('Cache GET error', { key, error });
      return null;
    }
  }

  public async getJSON<T = unknown>(key: string): Promise<T | null> {
    const v = await this.get(key);
    if (v == null) return null;
    try {
      return JSON.parse(v) as T;
    } catch {
      return null;
    }
  }

  /**
   * Set a value with TTL (seconds). Accepts string or any JSON-serializable value.
   * Works with both:
   *  - node-redis v4: client.set(key, value, { EX: ttl })
   *  - custom wrappers: redis.set(key, value, ttl)
   */
  public async set(key: string, value: unknown, ttlSeconds?: number): Promise<void> {
    const ttl = ttlSeconds ?? this.defaultTTLSeconds;
    const toStore = typeof value === 'string' ? value : JSON.stringify(value);

    try {
      // Prefer modern API via underlying client (node-redis v4)
      const client: any = redis.getClient?.() ?? null;
      if (client && typeof client.set === 'function') {
        try {
          await client.set(key, toStore, { EX: ttl });
          return;
        } catch {
          // fall through to wrapper style
        }
      }

      // Fallback to wrapper style: redis.set(key, value, ttl)
      const maybe = (redis as any).set;
      if (typeof maybe === 'function') {
        if (maybe.length >= 3) {
          await maybe.call(redis, key, toStore, ttl);
        } else {
          await maybe.call(redis, key, toStore);
          // If wrapper ignores TTL, try to set it via EXPIRE
          if (client && typeof client.expire === 'function') {
            await client.expire(key, ttl);
          }
        }
      }
    } catch (error) {
      logger.error('Cache SET error', { key, error });
      // don't throw â€” cache is best effort
    }
  }

  public async del(key: string): Promise<void> {
    try {
      await redis.del(key);
    } catch (error) {
      logger.error('Cache DEL error', { key, error });
    }
  }

  /**
   * Normalize EXISTS return to boolean whether itâ€™s number or boolean.
   */
  public async exists(key: string): Promise<boolean> {
    try {
      const raw = await (redis as any).exists?.(key);
      const n = typeof raw === 'number' ? raw : raw ? 1 : 0;
      return n > 0;
    } catch (error) {
      logger.error('Cache EXISTS error', { key, error });
      return false;
    }
  }

  /* ----------------------- Bulk helpers ----------------------- */

  /**
   * Flush keys by pattern safely. Uses scanIterator (node-redis v4),
   * falls back to SCAN or KEYS if needed.
   */
  public async flushPattern(pattern: string): Promise<void> {
    try {
      const client: any = redis.getClient?.() ?? null;
      if (!client) return;

      const batch: string[] = [];
      const flushBatch = async () => {
        if (batch.length) {
          await client.del(batch.splice(0, batch.length));
        }
      };

      if (typeof client.scanIterator === 'function') {
        // Best path: async iterator with MATCH/COUNT
        for await (const key of client.scanIterator({ MATCH: pattern, COUNT: 1000 })) {
          batch.push(key as string);
          if (batch.length >= 1000) await flushBatch();
        }
        await flushBatch();
        return;
      }

      if (typeof client.scan === 'function') {
        // Fallback: manual SCAN loop
        let cursor = '0';
        do {
          const [next, keys]: [string, string[]] = await client.scan(cursor, {
            MATCH: pattern,
            COUNT: 1000,
          });
          cursor = next;
          if (keys?.length) {
            batch.push(...keys);
            if (batch.length >= 1000) await flushBatch();
          }
        } while (cursor !== '0');
        await flushBatch();
        return;
      }

      if (typeof client.keys === 'function') {
        // Last resort: KEYS (blocking)
        const keys: string[] = await client.keys(pattern);
        if (keys.length) await client.del(keys);
      }
    } catch (error) {
      logger.error('Cache FLUSH PATTERN error', { pattern, error });
    }
  }

  /* ----------------------- Stats & diagnostics ----------------------- */

  public async getStats(): Promise<Record<string, string | number>> {
    try {
      const client: any = redis.getClient?.() ?? null;
      if (!client || typeof client.info !== 'function') return {};
      const info: string = await client.info('stats');
      return this.parseRedisInfo(info);
    } catch (error) {
      logger.error('Cache STATS error', { error });
      return {};
    }
  }

  private parseRedisInfo(info: string): Record<string, string | number> {
    const stats: Record<string, string | number> = {};
    const lines = info.split(/\r?\n/);

    for (const line of lines) {
      if (!line || line.startsWith('#')) continue; // skip comments / blanks
      const idx = line.indexOf(':');
      if (idx <= 0) continue;

      const key = line.slice(0, idx).trim();
      const raw = line.slice(idx + 1).trim();

      const n = Number(raw);
      stats[key] = Number.isFinite(n) && raw !== '' ? n : raw;
    }
    return stats;
    }
}

// Optional singleton export
export const cacheService = new CacheService();



------------------------------------------------------------
FILE: backend\ai-service\src\services\DefaultDataProcessor.ts
------------------------------------------------------------
// src/services/DefaultDataProcessor.ts
import type { DataSample, IDataProcessor, QualityIssue } from '@/services/AnalysisService';

export class DefaultDataProcessor implements IDataProcessor {
  constructor(private readonly log: (msg: string, meta?: unknown) => void = () => {}) {}

  async analyzeSampleData(
    samples: DataSample[],
  ): Promise<{ analysis: Record<string, unknown>[]; qualityIssues: QualityIssue[] }> {
    this.log('DefaultDataProcessor.analyzeSampleData', { columns: samples.length });

    const analysis: Record<string, unknown>[] = [];
    const qualityIssues: QualityIssue[] = [];

    for (const s of samples) {
      const values = Array.isArray(s.values) ? s.values : [];
      const nonNull = values.filter(v => v !== null && v !== undefined);
      const nulls = values.length - nonNull.length;
      const uniqueCount = new Set(nonNull.map(v => JSON.stringify(v))).size;

      analysis.push({
        column: s.columnName,
        count: values.length,
        nulls,
        nullRate: values.length ? +(nulls / values.length * 100).toFixed(2) : 0,
        uniqueCount,
        sample: nonNull.slice(0, 5),
      });

      if (nulls > 0) {
        qualityIssues.push({
          column: s.columnName,
          type: 'null_values',
          severity: nulls / Math.max(values.length, 1) > 0.2 ? 'High' : 'Low',
          count: nulls,
          message: 'Column contains null/undefined values',
          sample: values.slice(0, 5),
        });
      }

      const lower = s.columnName.toLowerCase();
      if (lower.includes('email')) {
        const bad = nonNull.filter(v => typeof v === 'string' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v));
        if (bad.length) {
          qualityIssues.push({
            column: s.columnName,
            type: 'format_inconsistency',
            severity: bad.length / Math.max(nonNull.length, 1) > 0.05 ? 'Medium' : 'Low',
            count: bad.length,
            message: 'Invalid email addresses detected',
            sample: bad.slice(0, 5),
          });
        }
      }
    }

    return { analysis, qualityIssues };
  }
}

export default DefaultDataProcessor;



------------------------------------------------------------
FILE: backend\ai-service\src\services\DiscoveryService.ts
------------------------------------------------------------
// src/services/DiscoveryService.ts
import { db } from '@/config/database';
import { APIError } from '@/utils/errors';
import { logger } from '@/utils/logger';
import { v4 as uuidv4 } from 'uuid';
import { AIService, type FieldDiscoveryRequest } from './AIService';

export interface DiscoverySession {
  sessionId: string;
  userId: string;
  dataSourceId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  results?: unknown;
  error?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface StartDiscoveryRequest {
  userId: string;
  dataSourceId: string;
  schemas?: string[];
  tables?: string[];
  options?: {
    sampleSize?: number;
    includeData?: boolean;
    analysisDepth?: 'basic' | 'detailed' | 'comprehensive';
  };
}

// shape as returned from DB
type DbSessionRow = {
  session_id: string;
  user_id: string;
  data_source_id: string;
  status: DiscoverySession['status'];
  progress: number;
  results: unknown | null;
  error: string | null;
  created_at: Date;
  updated_at: Date;
};

// local helper type for metadata
type ColumnDef = { name: string; type: string; nullable: boolean; description?: string };
type TableMeta = { schema: string; name: string; columns: ColumnDef[] };

export class DiscoveryService {
  private readonly aiService = new AIService();

  public async startDiscovery(request: StartDiscoveryRequest): Promise<DiscoverySession> {
    try {
      const sessionId = uuidv4();

      // Create discovery session
      const session = await this.createSession({
        sessionId,
        userId: request.userId,
        dataSourceId: request.dataSourceId,
        status: 'pending',
        progress: 0,
      });

      // Kick off async processing
      setImmediate(() =>
        this.processDiscovery(session, request).catch((err) => {
          const msg = err instanceof Error ? err.message : String(err);
          logger.error('Discovery background task fatal error', { sessionId, error: msg });
        })
      );

      logger.info('Discovery session started', { sessionId, dataSourceId: request.dataSourceId });
      return session;
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Failed to start discovery', { error: msg });
      throw new APIError('Failed to start discovery', 500, err);
    }
  }

  public async getSession(sessionId: string): Promise<DiscoverySession | null> {
    try {
      const result = await db.query('SELECT * FROM discovery_sessions WHERE session_id = $1', [sessionId]);
      if (result.rows.length === 0) return null;
      return this.mapSessionFromDb(result.rows[0] as DbSessionRow);
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Failed to get discovery session', { sessionId, error: msg });
      throw new APIError('Failed to get session', 500, err);
    }
  }

  public async listSessions(userId: string, limit = 20, offset = 0): Promise<DiscoverySession[]> {
    try {
      const result = await db.query(
        `SELECT * FROM discovery_sessions 
         WHERE user_id = $1 
         ORDER BY created_at DESC 
         LIMIT $2 OFFSET $3`,
        [userId, limit, offset]
      );

      return (result.rows as DbSessionRow[]).map((row) => this.mapSessionFromDb(row));
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Failed to list discovery sessions', { userId, error: msg });
      throw new APIError('Failed to list sessions', 500, err);
    }
  }

  public async deleteSession(sessionId: string, userId: string): Promise<void> {
    try {
      const result = await db.query('DELETE FROM discovery_sessions WHERE session_id = $1 AND user_id = $2', [
        sessionId,
        userId,
      ]);

      if (result.rowCount === 0) {
        throw new APIError('Session not found', 404);
      }

      logger.info('Discovery session deleted', { sessionId });
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Failed to delete discovery session', { sessionId, error: msg });
      throw err instanceof APIError ? err : new APIError('Failed to delete session', 500, err);
    }
  }

  /* --------------------------- Internals --------------------------- */

  private async createSession(session: Partial<DiscoverySession>): Promise<DiscoverySession> {
    const result = await db.query(
      `INSERT INTO discovery_sessions 
       (session_id, user_id, data_source_id, status, progress, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
       RETURNING *`,
      [session.sessionId, session.userId, session.dataSourceId, session.status, session.progress]
    );
    return this.mapSessionFromDb(result.rows[0] as DbSessionRow);
  }

  private async updateSession(sessionId: string, updates: Partial<DiscoverySession>): Promise<void> {
    const setClause: string[] = [];
    const values: unknown[] = [];
    let i = 1;

    for (const [key, value] of Object.entries(updates)) {
      if (key === 'sessionId') continue;
      // convert camelCase to snake_case
      const dbKey = key.replace(/[A-Z]/g, (m) => `_${m.toLowerCase()}`);
      setClause.push(`${dbKey} = $${i++}`);
      values.push(value);
    }

    if (setClause.length === 0) return;

    setClause.push(`updated_at = NOW()`);
    values.push(sessionId);

    await db.query(`UPDATE discovery_sessions SET ${setClause.join(', ')} WHERE session_id = $${i}`, values);
  }

  private async processDiscovery(session: DiscoverySession, request: StartDiscoveryRequest): Promise<void> {
    try {
      await this.updateSession(session.sessionId, { status: 'processing', progress: 10 });

      const dataSource = await this.getDataSource(request.dataSourceId);
      if (!dataSource) throw new Error('Data source not found');

      await this.updateSession(session.sessionId, { progress: 20 });

      // Retrieve metadata
      const metadata = await this.getSchemaMetadata(dataSource, request.schemas, request.tables);
      await this.updateSession(session.sessionId, { progress: 40 });

      const results: Array<{ schema: string; table: string; analysis: unknown }> = [];
      const totalTables = metadata.length || 1;

      for (let idx = 0; idx < metadata.length; idx++) {
        const table = metadata[idx];

        // Optional sample data
        let sampleData: unknown[] = [];
        if (request.options?.includeData) {
          sampleData = await this.getSampleData(
            dataSource,
            table.schema,
            table.name,
            request.options.sampleSize ?? 100
          );
        }

        // IMPORTANT: make columns mutable (clone), not readonly
        const columns: ColumnDef[] = table.columns.map((c) => ({ ...c }));

        const discoveryRequest: FieldDiscoveryRequest = {
          schema: table.schema,
          tableName: table.name,
          columns,            // mutable array now
          sampleData,         // always an array
          context: `Discovery session for ${String(dataSource.name ?? dataSource.id)}`,
        };

        const analysis = await this.aiService.discoverFields(discoveryRequest);

        results.push({ schema: table.schema, table: table.name, analysis });

        // progress: 40 â†’ 90 during table loop
        const progress = 40 + Math.floor(((idx + 1) / totalTables) * 50);
        await this.updateSession(session.sessionId, { progress });
      }

      await this.updateSession(session.sessionId, {
        status: 'completed',
        progress: 100,
        results: { tables: results, summary: this.generateSummary(results) },
      });

      logger.info('Discovery completed successfully', {
        sessionId: session.sessionId,
        tablesProcessed: results.length,
      });
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      logger.error('Discovery processing failed', { sessionId: session.sessionId, error: msg });

      await this.updateSession(session.sessionId, { status: 'failed', error: msg });
    }
  }

  private async getDataSource(dataSourceId: string): Promise<any | null> {
    const result = await db.query('SELECT * FROM data_sources WHERE id = $1', [dataSourceId]);
    return result.rows[0] ?? null;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private async getSchemaMetadata(
    _dataSource: any,
    _schemas?: string[],
    _tables?: string[]
  ): Promise<TableMeta[]> {
    // TODO: replace with real connector fetch
    return [
      {
        schema: 'public',
        name: 'users',
        columns: [
          { name: 'id', type: 'integer', nullable: false },
          { name: 'email', type: 'varchar', nullable: false },
          { name: 'first_name', type: 'varchar', nullable: true },
          { name: 'last_name', type: 'varchar', nullable: true },
          { name: 'phone', type: 'varchar', nullable: true },
          { name: 'created_at', type: 'timestamp', nullable: false },
        ],
      },
    ];
  }

  private async getSampleData(
    _dataSource: any,
    _schema: string,
    _table: string,
    _limit: number
  ): Promise<unknown[]> {
    // TODO: replace with actual sampling query
    return [
      { id: 1, email: 'john@example.com', first_name: 'John', last_name: 'Doe', phone: '+1234567890' },
      { id: 2, email: 'jane@example.com', first_name: 'Jane', last_name: 'Smith', phone: '+1987654321' },
    ];
  }

  private generateSummary(results: ReadonlyArray<{ analysis: any }>): {
    totalTables: number;
    totalFields: number;
    classifications: Record<string, number>;
    sensitivities: Record<string, number>;
    recommendations: string[];
  } {
    let totalFields = 0;
    const classifications: Record<string, number> = Object.create(null);
    const sensitivities: Record<string, number> = Object.create(null);

    for (const t of results) {
      const fields: ReadonlyArray<any> = Array.isArray(t.analysis?.fields) ? t.analysis.fields : [];
      totalFields += fields.length;

      for (const f of fields) {
        const cls = String(f.classification ?? 'Unknown');
        const sen = String(f.sensitivity ?? 'Unknown');
        classifications[cls] = (classifications[cls] ?? 0) + 1;
        sensitivities[sen] = (sensitivities[sen] ?? 0) + 1;
      }
    }

    const recommendations = results
      .flatMap((t) => {
        const gov: unknown = t.analysis?.recommendations?.governance;
        return Array.isArray(gov) ? gov : [];
      })
      .slice(0, 10);

    return {
      totalTables: results.length,
      totalFields,
      classifications,
      sensitivities,
      recommendations,
    };
  }

  private mapSessionFromDb(row: DbSessionRow): DiscoverySession {
    // Build with conditional spreads to satisfy exactOptionalPropertyTypes:
    const base: Omit<DiscoverySession, 'results' | 'error'> = {
      sessionId: row.session_id,
      userId: row.user_id,
      dataSourceId: row.data_source_id,
      status: row.status,
      progress: row.progress,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };

    return {
      ...base,
      ...(row.results !== null ? { results: row.results } : {}),
      ...(row.error !== null ? { error: row.error } : {}),
    };
  }
}



------------------------------------------------------------
FILE: backend\ai-service\src\utils\errors.ts
------------------------------------------------------------
export class APIError extends Error {
  public statusCode: number;
  public isOperational: boolean;
  public details?: any;

  constructor(message: string, statusCode = 500, details?: any) {
    super(message);
    this.name = 'APIError';
    this.statusCode = statusCode;
    this.isOperational = true;
    this.details = details;

    // Ensure proper prototype chain
    Object.setPrototypeOf(this, APIError.prototype);

    // Capture stack trace
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends APIError {
  constructor(message: string, details?: any) {
    super(message, 400, details);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends APIError {
  constructor(message = 'Authentication required') {
    super(message, 401);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends APIError {
  constructor(message = 'Insufficient permissions') {
    super(message, 403);
    this.name = 'AuthorizationError';
  }
}

export class NotFoundError extends APIError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404);
    this.name = 'NotFoundError';
  }
}

export class ConflictError extends APIError {
  constructor(message = 'Resource conflict') {
    super(message, 409);
    this.name = 'ConflictError';
  }
}

export class RateLimitError extends APIError {
  constructor(message = 'Rate limit exceeded') {
    super(message, 429);
    this.name = 'RateLimitError';
  }
}

export class ExternalServiceError extends APIError {
  constructor(service: string, message?: string) {
    super(message || `External service ${service} is unavailable`, 503);
    this.name = 'ExternalServiceError';
  }
}


------------------------------------------------------------
FILE: backend\ai-service\src\utils\gracefulShutdown.ts
------------------------------------------------------------
// src/utils/gracefulShutdown.ts
import { Server } from 'http';
import { logger } from './logger';

interface ShutdownOptions {
  timeout?: number; // Timeout in milliseconds
  signals?: string[]; // Signals to listen for
  forceExitDelay?: number; // Delay before force exit
}

/**
 * Production-ready graceful shutdown handler
 */
export class GracefulShutdown {
  private server: Server;
  private isShuttingDown: boolean = false;
  private connections: Set<any> = new Set();
  private options: Required<ShutdownOptions>;
  private shutdownTimeout: NodeJS.Timeout | null = null;
  private forceExitTimeout: NodeJS.Timeout | null = null;

  constructor(server: Server, options: ShutdownOptions = {}) {
    this.server = server;
    this.options = {
      timeout: options.timeout || 30000, // 30 seconds default
      signals: options.signals || ['SIGTERM', 'SIGINT', 'SIGUSR2'],
      forceExitDelay: options.forceExitDelay || 5000 // 5 seconds before force exit
    };

    this.setupConnectionTracking();
    this.setupSignalHandlers();
  }

  /**
   * Track active connections
   */
  private setupConnectionTracking(): void {
    this.server.on('connection', (connection) => {
      this.connections.add(connection);
      
      connection.on('close', () => {
        this.connections.delete(connection);
      });

      // Handle connection errors
      connection.on('error', (error) => {
        logger.warn('Connection error during shutdown:', error);
        this.connections.delete(connection);
      });
    });
  }

  /**
   * Setup signal handlers for graceful shutdown
   */
  private setupSignalHandlers(): void {
    this.options.signals.forEach((signal) => {
      process.on(signal, () => {
        logger.info(`Received ${signal} signal, starting graceful shutdown...`);
        this.initiateShutdown(signal);
      });
    });

    // Handle uncaught exceptions during shutdown
    process.on('uncaughtException', (error) => {
      logger.error('Uncaught exception during shutdown:', error);
      if (this.isShuttingDown) {
        this.forceExit(1);
      }
    });

    // Handle unhandled promise rejections during shutdown
    process.on('unhandledRejection', (reason, promise) => {
      logger.error('Unhandled promise rejection during shutdown:', { reason, promise });
      if (this.isShuttingDown) {
        this.forceExit(1);
      }
    });
  }

  /**
   * Initiate graceful shutdown process
   */
  private async initiateShutdown(signal: string): Promise<void> {
    if (this.isShuttingDown) {
      logger.warn('Shutdown already in progress, ignoring signal');
      return;
    }

    this.isShuttingDown = true;
    const startTime = Date.now();

    logger.info('Starting graceful shutdown process...', {
      signal,
      activeConnections: this.connections.size,
      timeout: this.options.timeout
    });

    // Set timeout for forced shutdown
    this.shutdownTimeout = setTimeout(() => {
      logger.warn('Graceful shutdown timeout reached, forcing shutdown');
      this.forceShutdown();
    }, this.options.timeout);

    // Set force exit timeout
    this.forceExitTimeout = setTimeout(() => {
      logger.error('Force exit timeout reached, terminating process');
      this.forceExit(1);
    }, this.options.timeout + this.options.forceExitDelay);

    try {
      // Step 1: Stop accepting new connections
      await this.stopAcceptingConnections();

      // Step 2: Close existing connections gracefully
      await this.closeExistingConnections();

      // Step 3: Cleanup resources
      await this.cleanupResources();

      // Step 4: Exit gracefully
      const duration = Date.now() - startTime;
      logger.info(`Graceful shutdown completed successfully in ${duration}ms`);
      
      this.clearTimeouts();
      process.exit(0);

    } catch (error) {
      logger.error('Error during graceful shutdown:', error);
      this.forceExit(1);
    }
  }

  /**
   * Stop accepting new connections
   */
  private async stopAcceptingConnections(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.server.listening) {
        logger.info('Server not listening, skipping connection stop');
        return resolve();
      }

      logger.info('Stopping server from accepting new connections...');
      
      this.server.close((error) => {
        if (error) {
          logger.error('Error stopping server:', error);
          return reject(error);
        }
        
        logger.info('Server stopped accepting new connections');
        resolve();
      });
    });
  }

  /**
   * Close existing connections gracefully
   */
  private async closeExistingConnections(): Promise<void> {
    if (this.connections.size === 0) {
      logger.info('No active connections to close');
      return;
    }

    logger.info(`Closing ${this.connections.size} active connections...`);

    // Give connections time to finish naturally
    await this.waitForConnectionsToClose(5000);

    // Force close remaining connections
    if (this.connections.size > 0) {
      logger.warn(`Force closing ${this.connections.size} remaining connections`);
      this.connections.forEach((connection) => {
        try {
          connection.destroy();
        } catch (error) {
          logger.warn('Error destroying connection:', error);
        }
      });
      this.connections.clear();
    }

    logger.info('All connections closed');
  }

  /**
   * Wait for connections to close naturally
   */
  private async waitForConnectionsToClose(timeout: number): Promise<void> {
    const startTime = Date.now();
    
    while (this.connections.size > 0 && (Date.now() - startTime) < timeout) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  /**
   * Cleanup application resources
   */
  private async cleanupResources(): Promise<void> {
    logger.info('Cleaning up application resources...');

    try {
      // Import and close database connections
      const { db } = await import('@/config/database');
      if (db && typeof db.close === 'function') {
        await db.close();
        logger.info('Database connections closed');
      }
    } catch (error) {
      logger.warn('Error closing database connections:', error);
    }

    try {
      // Import and close Redis connections
      const { redis } = await import('@/config/redis');
      if (redis && typeof redis.close === 'function') {
        await redis.close();
        logger.info('Redis connections closed');
      }
    } catch (error) {
      logger.warn('Error closing Redis connections:', error);
    }

    // Clear any intervals or timeouts
    this.clearApplicationTimers();

    logger.info('Resource cleanup completed');
  }

  /**
   * Clear application timers and intervals
   */
  private clearApplicationTimers(): void {
    // Clear any global intervals or timeouts
    // This is a placeholder - you can add specific timer cleanup here
    logger.debug('Application timers cleared');
  }

  /**
   * Force shutdown when graceful shutdown fails
   */
  private forceShutdown(): void {
    logger.warn('Forcing immediate shutdown...');

    // Destroy all connections immediately
    this.connections.forEach((connection) => {
      try {
        connection.destroy();
      } catch (error) {
        logger.warn('Error destroying connection during force shutdown:', error);
      }
    });

    this.connections.clear();
    
    // Force close server
    try {
      this.server.close();
    } catch (error) {
      logger.warn('Error force closing server:', error);
    }

    this.clearTimeouts();
    this.forceExit(1);
  }

  /**
   * Force exit the process
   */
  private forceExit(code: number): void {
    logger.error(`Force exiting with code ${code}`);
    this.clearTimeouts();
    process.exit(code);
  }

  /**
   * Clear shutdown timeouts
   */
  private clearTimeouts(): void {
    if (this.shutdownTimeout) {
      clearTimeout(this.shutdownTimeout);
      this.shutdownTimeout = null;
    }

    if (this.forceExitTimeout) {
      clearTimeout(this.forceExitTimeout);
      this.forceExitTimeout = null;
    }
  }

  /**
   * Get shutdown status
   */
  public isShutdownInProgress(): boolean {
    return this.isShuttingDown;
  }

  /**
   * Get active connections count
   */
  public getActiveConnectionsCount(): number {
    return this.connections.size;
  }
}

/**
 * Simple graceful shutdown function (backwards compatible)
 */
export function gracefulShutdown(server: Server, options?: ShutdownOptions): GracefulShutdown {
  return new GracefulShutdown(server, options);
}

/**
 * Enhanced graceful shutdown with custom cleanup
 */
export function createGracefulShutdown(
  server: Server, 
  options: ShutdownOptions = {},
  customCleanup?: () => Promise<void>
): GracefulShutdown {
  const shutdown = new GracefulShutdown(server, options);

  // Add custom cleanup if provided
  if (customCleanup) {
    const originalCleanup = (shutdown as any).cleanupResources;
    (shutdown as any).cleanupResources = async function() {
      await originalCleanup.call(this);
      try {
        await customCleanup();
        logger.info('Custom cleanup completed');
      } catch (error) {
        logger.error('Error in custom cleanup:', error);
      }
    };
  }

  return shutdown;
}

// Export default
export default gracefulShutdown;


------------------------------------------------------------
FILE: backend\ai-service\src\utils\logger.ts
------------------------------------------------------------
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';

const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    return `${timestamp} [${level}]: ${message} ${Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''}`;
  })
);

// Create logger instance
export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: { 
    service: 'ai-service',
    version: process.env.APP_VERSION || '1.0.0'
  },
  transports: [
    // Console transport
    new winston.transports.Console({
      format: process.env.NODE_ENV === 'production' ? logFormat : consoleFormat
    }),

    // File transport for errors
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: process.env.LOG_FILE_MAX_SIZE || '20m',
      maxFiles: process.env.LOG_FILE_MAX_FILES || '14d',
      zippedArchive: true
    }),

    // File transport for all logs
    new DailyRotateFile({
      filename: 'logs/combined-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      maxSize: process.env.LOG_FILE_MAX_SIZE || '20m',
      maxFiles: process.env.LOG_FILE_MAX_FILES || '14d',
      zippedArchive: true
    })
  ],

  // Handle exceptions and rejections
  exceptionHandlers: [
    new winston.transports.File({ filename: 'logs/exceptions.log' })
  ],
  rejectionHandlers: [
    new winston.transports.File({ filename: 'logs/rejections.log' })
  ]
});

// Create child logger for specific modules
export const createChildLogger = (module: string) => {
  return logger.child({ module });
};


------------------------------------------------------------
FILE: backend\ai-service\src\utils\responses.ts
------------------------------------------------------------
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  meta?: {
    requestId?: string;
    timestamp: string;
    version: string;
  };
}

export const successResponse = <T>(
  data: T,
  message = 'Success',
  pagination?: any
): ApiResponse<T> => {
  return {
    success: true,
    data,
    message,
    ...(pagination && { pagination }),
    meta: {
      timestamp: new Date().toISOString(),
      version: process.env.APP_VERSION || '1.0.0'
    }
  };
};

export const errorResponse = (
  message: string,
  code = 500,
  details?: any
): ApiResponse => {
  return {
    success: false,
    message,
    ...(details && { data: details }),
    meta: {
      timestamp: new Date().toISOString(),
      version: process.env.APP_VERSION || '1.0.0'
    }
  };
};

export const paginatedResponse = <T>(
  data: T[],
  page: number,
  limit: number,
  total: number,
  message = 'Success'
): ApiResponse<T[]> => {
  return {
    success: true,
    data,
    message,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    },
    meta: {
      timestamp: new Date().toISOString(),
      version: process.env.APP_VERSION || '1.0.0'
    }
  };
};


------------------------------------------------------------
FILE: backend\ai-service\src\utils\validator.ts
------------------------------------------------------------
// src/utils/validator.ts
import type { RequestHandler } from 'express';
import Joi, { Schema, ValidationOptions } from 'joi';

/**
 * Common primitives
 */
const uuid = Joi.string().guid({ version: ['uuidv4', 'uuidv5'] });

const email = Joi.string()
  .email({ tlds: { allow: false } })
  .max(254);

const password = Joi.string()
  .min(8)
  // at least one lowercase, one uppercase, one digit, one special
  .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[ !"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]).{8,}$/)
  .messages({
    'string.pattern.base':
      'Password must include upper & lower case letters, a number, and a special character.',
  });

/**
 * E.164-ish phone: optional leading +, then 7â€“15 digits (first digit cannot be 0)
 * If you want strictly E.164 (1â€“15 digits, no leading 0), use /^\+[1-9]\d{1,14}$/
 */
const phone = Joi.string()
  .pattern(/^\+?[1-9]\d{6,14}$/)
  .messages({
    'string.pattern.base': 'Phone must be a valid international number (e.g., +15551234567).',
  });

const nonEmptyString = Joi.string().trim().min(1);

const dateISO = Joi.date().iso();

/**
 * Reusable â€œfieldâ€ library
 */
export const Fields = {
  uuid,
  email,
  password,
  phone,
  nonEmptyString,
  dateISO,
  // add as needed:
  // intId: Joi.number().integer().positive(),
  // url: Joi.string().uri({ scheme: [/https?/] }),
};

/**
 * Example composed schemas you can import directly
 */
export const Schemas = {
  // Auth
  register: Joi.object({
    email: Fields.email.required(),
    password: Fields.password.required(),
    fullName: Fields.nonEmptyString.required(),
    phone: Fields.phone.optional(),
  }),

  login: Joi.object({
    email: Fields.email.required(),
    password: Joi.string().required(),
  }),

  // Users
  userCreate: Joi.object({
    email: Fields.email.required(),
    password: Fields.password.required(),
    firstName: Fields.nonEmptyString.required(),
    lastName: Fields.nonEmptyString.required(),
    phone: Fields.phone.optional(),
  }),

  userUpdate: Joi.object({
    email: Fields.email.optional(),
    firstName: Fields.nonEmptyString.optional(),
    lastName: Fields.nonEmptyString.optional(),
    phone: Fields.phone.optional(),
  }).min(1), // at least one field

  // Generic id param
  idParam: Joi.object({ id: Fields.uuid.required() }),

  // Pagination / filtering example
  paginationQuery: Joi.object({
    page: Joi.number().integer().min(1).default(1),
    pageSize: Joi.number().integer().min(1).max(200).default(25),
    search: Joi.string().trim().max(200).optional(),
    sortBy: Joi.string().trim().max(64).optional(),
    sortDir: Joi.string().valid('asc', 'desc').default('asc'),
  }),
} as const;

/**
 * Central validator helper (useful outside of Express too)
 */
export function validate<T>(
  value: unknown,
  schema: Schema,
  options: ValidationOptions = { abortEarly: false, stripUnknown: true }
): T {
  const { error, value: out } = schema.validate(value, options);
  if (error) {
    // Throw a structured error (you may map to your APIError)
    const details = error.details.map(d => d.message);
    throw new Error(`Validation failed: ${details.join('; ')}`);
  }
  return out as T;
}

/**
 * Express middlewares for validation
 */
type MiddlewareBuilder = (schema: Schema, options?: ValidationOptions) => RequestHandler;

export const validateBody: MiddlewareBuilder = (schema, options = { abortEarly: false, stripUnknown: true }) =>
  (req, _res, next) => {
    try {
      req.body = validate(req.body, schema, options);
      next();
    } catch (e) {
      next(e);
    }
  };

export const validateQuery: MiddlewareBuilder = (schema, options = { abortEarly: false, stripUnknown: true }) =>
  (req, _res, next) => {
    try {
      req.query = validate(req.query, schema, options);
      next();
    } catch (e) {
      next(e);
    }
  };

export const validateParams: MiddlewareBuilder = (schema, options = { abortEarly: false, stripUnknown: true }) =>
  (req, _res, next) => {
    try {
      req.params = validate(req.params, schema, options);
      next();
    } catch (e) {
      next(e);
    }
  };



====================================================================================================
  PIPELINE SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\pipeline-service\src\app.ts
------------------------------------------------------------
import cors from 'cors';
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

export const app = express();

const corsOrigin = process.env.CORS_ORIGIN || 'http://localhost:5173';
app.use(helmet());
app.use(cors({ origin: corsOrigin }));
app.use(express.json());
app.use(morgan('dev'));

app.get('/health', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'pipeline-service', status: 'ok' });
});

app.get('/', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'pipeline-service', message: 'Service up and running' });
});



------------------------------------------------------------
FILE: backend\pipeline-service\src\server.ts
------------------------------------------------------------
import { app } from './app.js';

const fallback = Number(process.env.FALLBACK_PORT || 3004);
const port = Number(process.env.PORT || fallback);

app.listen(port, () => {
  console.log(`[${process.env.SERVICE_NAME || 'pipeline-service'}] listening on :${port}`);
});



====================================================================================================
  NOTIFICATION SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\notification-service\src\app.ts
------------------------------------------------------------
import cors from 'cors';
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

export const app = express();

const corsOrigin = process.env.CORS_ORIGIN || 'http://localhost:5173';
app.use(helmet());
app.use(cors({ origin: corsOrigin }));
app.use(express.json());
app.use(morgan('dev'));

app.get('/health', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'notification-service', status: 'ok' });
});

app.get('/', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'notification-service', message: 'Service up and running' });
});



------------------------------------------------------------
FILE: backend\notification-service\src\server.ts
------------------------------------------------------------
import { app } from './app.js';

const fallback = Number(process.env.FALLBACK_PORT || 3007);
const port = Number(process.env.PORT || fallback);

app.listen(port, () => {
  console.log(`[${process.env.SERVICE_NAME || 'notification-service'}] listening on :${port}`);
});



====================================================================================================
  INTEGRATION SERVICE - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: backend\integration-service\src\app.ts
------------------------------------------------------------
import cors from 'cors';
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

export const app = express();

const corsOrigin = process.env.CORS_ORIGIN || 'http://localhost:5173';
app.use(helmet());
app.use(cors({ origin: corsOrigin }));
app.use(express.json());
app.use(morgan('dev'));

app.get('/health', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'integration-service', status: 'ok' });
});

app.get('/', (_req, res) => {
  res.json({ service: process.env.SERVICE_NAME || 'integration-service', message: 'Service up and running' });
});



------------------------------------------------------------
FILE: backend\integration-service\src\server.ts
------------------------------------------------------------
import { app } from './app.js';

const fallback = Number(process.env.FALLBACK_PORT || 3006);
const port = Number(process.env.PORT || fallback);

app.listen(port, () => {
  console.log(`[${process.env.SERVICE_NAME || 'integration-service'}] listening on :${port}`);
});



====================================================================================================
  FRONTEND - APPLICATION CODE
====================================================================================================


------------------------------------------------------------
FILE: frontend\src\App.tsx
------------------------------------------------------------
import { Layout } from '@/components/layout'
import { AIAssistant } from '@/pages/AIAssistant'
import { Connections } from '@/pages/Connections'
import { Dashboard } from '@/pages/Dashboard'
import { DataCatalog } from '@/pages/DataCatalog'
import { DataLineage } from '@/pages/DataLineage'
import { DataQuality } from '@/pages/DataQuality'
import { Governance } from '@/pages/Governance'
import { Monitoring } from '@/pages/Monitoring'
import { Pipelines } from '@/pages/Pipelines'
import { Requests } from '@/pages/Requests'
import { Settings } from '@/pages/Settings'
import { Navigate, Route, Routes } from 'react-router-dom'

export default function App() {
  return (
    <Layout>
      <Routes>
        <Route path="/" element={<Navigate to="/dashboard" replace />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/ai-assistant" element={<AIAssistant />} />
        <Route path="/data-catalog" element={<DataCatalog />} />
        <Route path="/data-quality" element={<DataQuality />} />
        <Route path="/data-lineage" element={<DataLineage />} />
        <Route path="/pipelines" element={<Pipelines />} />
        <Route path="/requests" element={<Requests />} />
        <Route path="/connections" element={<Connections />} />
        <Route path="/governance" element={<Governance />} />
        <Route path="/monitoring" element={<Monitoring />} />
        <Route path="/settings" element={<Settings />} />
        <Route path="*" element={<Navigate to="/dashboard" replace />} />
      </Routes>
    </Layout>
  )
}



------------------------------------------------------------
FILE: frontend\src\common\ConfirmDialog.tsx
------------------------------------------------------------
export const ConfirmDialog=()=>null;


------------------------------------------------------------
FILE: frontend\src\common\DataTable.tsx
------------------------------------------------------------
export const DataTable=()=>null;


------------------------------------------------------------
FILE: frontend\src\common\ErrorBoundary.tsx
------------------------------------------------------------
export default function ErrorBoundary(){return null;}


------------------------------------------------------------
FILE: frontend\src\common\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\common\LoadingSpinner.tsx
------------------------------------------------------------
export const LoadingSpinner=()=>(<div className='animate-spin'>â³</div>);


------------------------------------------------------------
FILE: frontend\src\components\common\ConfirmDialog.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\common\DataTable.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\common\ErrorBoundary.tsx
------------------------------------------------------------
// src/components/common/ErrorBoundary.tsx
import * as React from 'react'

type Props = {
  children: React.ReactNode
  /** Optional custom fallback UI */
  fallback?: React.ReactNode
  /** Called when the user clicks â€œTry againâ€ */
  onReset?: () => void
}

type State = {
  hasError: boolean
  error?: Error
}

class ErrorBoundary extends React.Component<Props, State> {
  state: State = { hasError: false }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    // Log to your telemetry here (Sentry, Datadog, etc.)
    console.error('ErrorBoundary caught an error', error, info)
  }

  private handleReset = () => {
    this.setState({ hasError: false, error: undefined })
    this.props.onReset?.()
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) return <>{this.props.fallback}</>

      return (
        <div className="min-h-screen bg-gray-50 flex items-center justify-center p-6">
          <div className="max-w-md w-full rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
            <h2 className="text-lg font-semibold text-gray-900">Something went wrong</h2>
            <p className="mt-2 text-sm text-gray-600">
              The page crashed. You can try again or reload the app.
            </p>
            {this.state.error && (
              <pre className="mt-3 max-h-32 overflow-auto rounded bg-gray-100 p-2 text-xs text-gray-700">
                {this.state.error.message}
              </pre>
            )}
            <div className="mt-4 flex gap-2">
              <button
                type="button"
                onClick={this.handleReset}
                className="inline-flex items-center rounded-lg bg-blue-600 px-3 py-2 text-sm font-medium text-white hover:bg-blue-700"
              >
                Try again
              </button>
              <button
                type="button"
                onClick={() => window.location.reload()}
                className="inline-flex items-center rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                Reload
              </button>
            </div>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary
export { ErrorBoundary }




------------------------------------------------------------
FILE: frontend\src\components\common\index.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\common\LoadingSpinner.tsx
------------------------------------------------------------
// src/components/common/LoadingSpinner.tsx
import React from 'react'

export type LoadingSpinnerProps = {
  size?: number
  color?: string
  className?: string
  /** Optional accessible label shown next to the spinner */
  label?: string
  /** If true, render inline (no block wrapper spacing) */
  inline?: boolean
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 24,
  color = 'currentColor',
  className = '',
  label,
  inline = false,
}) => {
  const content = (
    <>
      <svg
        className={`animate-spin ${label ? 'mr-2' : ''} ${className}`}
        width={size}
        height={size}
        viewBox="0 0 24 24"
        fill="none"
        role="img"
        aria-hidden={label ? 'true' : 'false'}
      >
        <circle cx="12" cy="12" r="10" stroke={color} strokeWidth="4" className="opacity-25" />
        <path d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" fill={color} className="opacity-75" />
      </svg>
      {label ? (
        <span className="text-sm text-gray-700" aria-live="polite" aria-atomic="true">
          {label}
        </span>
      ) : null}
    </>
  )

  return inline ? (
    <span className="inline-flex items-center" role="status">
      {content}
    </span>
  ) : (
    <div className="flex items-center" role="status">
      {content}
    </div>
  )
}

export default LoadingSpinner



------------------------------------------------------------
FILE: frontend\src\components\features\ai-assistant\ActionButtons.tsx
------------------------------------------------------------
import React from 'react';

interface ActionButtonsProps {
  onClearChat: () => void;
  onRetry: () => void;
  disabled?: boolean;
  messageCount: number;
  characterCount: number;
  maxCharacters?: number;
}

export const ActionButtons: React.FC<ActionButtonsProps> = ({
  onClearChat,
  onRetry,
  disabled = false,
  messageCount,
  characterCount,
  maxCharacters = 500
}) => {
  return (
    <div className="action-buttons">
      <div className="button-group">
        <button
          onClick={onClearChat}
          disabled={disabled || messageCount === 0}
          className="action-btn clear-btn"
          title="Clear chat history"
        >
          ðŸ—‘ï¸ Clear Chat
        </button>
        
        <button
          onClick={onRetry}
          disabled={disabled || messageCount === 0}
          className="action-btn retry-btn"
          title="Retry last message"
        >
          ðŸ”„ Retry
        </button>
      </div>
      
      <div className="chat-info">
        <span className="message-count">
          Messages: {messageCount}
        </span>
        
        <span className={`character-count ${characterCount > maxCharacters * 0.9 ? 'warning' : ''}`}>
          {characterCount}/{maxCharacters}
        </span>
      </div>
    </div>
  );
};

// Default export for compatibility
export default ActionButtons;


------------------------------------------------------------
FILE: frontend\src\components\features\ai-assistant\ChatInterface.tsx
------------------------------------------------------------
// src/components/ai/ChatInterface.tsx
import aiAssistantService from '@/services/api/aiAssistant';
import {
  AlertTriangle,
  CheckCheck,
  Copy,
  Database,
  RotateCcw,
  Send,
  Shield,
  Sparkles,
  Trash2,
  Zap
} from 'lucide-react';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';

/* =========================
   Types / Props
   ========================= */
type MessageKind = 'user' | 'assistant' | 'system' | 'error';

interface AIMessage {
  id: string;
  type: MessageKind;
  content: string;
  timestamp: Date;
  metadata?: {
    processingTime?: number;
    confidence?: number;
    status?: 'sending' | 'delivered' | 'error';
  };
}

interface ChatInterfaceProps {
  className?: string;
  placeholder?: string;
  /** Hide internal header to avoid duplicate page headings */
  showHeader?: boolean; // default false
}

/* =========================
   Env / Feature flags
   ========================= */
const USE_BACKEND = import.meta.env.VITE_USE_AI_BACKEND === 'true';

/* =========================
   Utilities
   ========================= */
const cx = (...parts: Array<string | false | undefined | null>) =>
  parts.filter(Boolean).join(' ');

const fmtTime = (d: Date) =>
  d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

/** Very small â€œnormalizerâ€ for backend responses */
const normalizeBackendResponse = (res: any): { text: string; meta?: any } => {
  if (!res) return { text: 'No response from AI service.' };

  const d = res.data ?? res; // allow raw or { data }
  const candidates = [
    typeof d?.message === 'string' ? d.message : undefined,
    typeof d?.text === 'string' ? d.text : undefined,
    typeof d?.answer === 'string' ? d.answer : undefined,
    typeof d?.results === 'string' ? d.results : undefined,
  ].filter((v) => typeof v === 'string' && v.trim().length > 0) as string[];

  if (candidates.length) {
    return { text: candidates[0], meta: res.meta };
  }

  // Render objects/arrays sensibly
  if (d?.results && typeof d.results === 'object') {
    return {
      text: '```json\n' + JSON.stringify(d.results, null, 2) + '\n```',
      meta: res.meta,
    };
  }

  if (res?.error?.message) {
    return { text: `âš ï¸ ${res.error.message}`, meta: res.meta };
  }
  return { text: 'No response from AI service.', meta: res.meta };
};

/* =========================
   Mock AI (unchanged logic)
   ========================= */
const mockAIService = {
  async sendMessage(content: string): Promise<{ message: string; processingTime: number; confidence: number }> {
    const processingTime = 1200 + Math.random() * 1800;
    await new Promise((r) => setTimeout(r, processingTime));

    const responses: Record<string, { message: string; confidence: number }> = {
      'show me data quality issues': {
        message: `ðŸ” **Data Quality Analysis Complete**

**Overall Quality Score: 87/100** âœ…

**Critical Issues Identified:**
â€¢ **Missing Values**: 234 records in customer_email (12.3% of dataset)
â€¢ **Duplicate Records**: 12 duplicate entries in orders table
â€¢ **Format Issues**: 5 invalid date formats in transaction_date field
â€¢ **Outliers**: 89 statistical outliers in revenue_amount column

**Quality Metrics by Category:**
ðŸ“Š **Completeness**: 94.2% (Target: 95%)
ðŸ“‹ **Validity**: 89.7% (Target: 92%)
ðŸ”„ **Consistency**: 91.3% (Target: 90%) âœ…
ðŸŽ¯ **Accuracy**: 85.8% (Target: 88%)

**Immediate Actions Required:**
1. âœ… Implement email validation rules for customer_email
2. âš ï¸ Add unique constraints to prevent order duplicates
3. ðŸ”§ Standardize date formats across all transaction tables
4. ðŸ“ˆ Review outlier detection thresholds for revenue data

**Estimated Fix Time**: 2-3 business days
**Impact**: Will improve overall data quality to 93/100`,
        confidence: 0.94,
      },
      'find sensitive data in my database': {
        message: `ðŸ›¡ï¸ **Sensitive Data Discovery Report**

**PII Detection Summary:**
Found **67,234 sensitive records** across 15 database tables

**Sensitive Data Breakdown:**
ðŸ”´ **Social Security Numbers**: 1,247 records
   â€¢ Tables: customers, employees, contractors
   â€¢ Encryption Status: âŒ Unencrypted

ðŸ’³ **Credit Card Numbers**: 892 records
   â€¢ Tables: payments, billing_history
   â€¢ Encryption Status: âš ï¸ Partially encrypted

ðŸ“§ **Email Addresses**: 45,123 records
   â€¢ Tables: customers, marketing_contacts, employees
   â€¢ Encryption Status: âŒ Plain text

**Compliance Status:**
ðŸŸ¡ **GDPR**: 67% compliant (Needs consent tracking)
ðŸŸ¡ **CCPA**: 72% compliant (Missing data deletion processes)
ðŸ”´ **PCI-DSS**: 23% compliant (Critical - credit card data exposed)
ðŸŸ¡ **HIPAA**: 58% compliant (Healthcare data needs encryption)

**Critical Actions (Within 24 Hours):**
1. ðŸš¨ **Immediate**: Encrypt all credit card data
2. ðŸ”’ **High Priority**: Implement data masking for SSNs
3. ðŸ“ **Required**: Add consent tracking for email collection
4. ðŸ—‚ï¸ **Compliance**: Establish data retention policies

**Risk Level**: HIGH - Potential regulatory fines up to $2.1M`,
        confidence: 0.96,
      },
      'generate quality rules for customer data': {
        message: `âš™ï¸ **AI-Generated Data Quality Rules**

**Customer Data Validation Rules Created:**

**1. Email Validation Rule**
\`\`\`sql
RULE: email_format_validation
REGEX: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$
APPLIES_TO: customer_email, contact_email, billing_email
SEVERITY: HIGH
\`\`\`

**2. Phone Number Standardization**
\`\`\`sql
RULE: phone_standardization
FORMAT: (XXX) XXX-XXXX
VALIDATION: LENGTH = 14 AND STARTS_WITH('(')
APPLIES_TO: phone_number, mobile_number, emergency_contact
SEVERITY: MEDIUM
\`\`\`

**Implementation Summary:**
âœ… **Rules Created**: 6 validation rules
ðŸ“Š **Coverage**: 98% of customer data fields
âš¡ **Performance Impact**: <2% query overhead
ðŸŽ¯ **Expected Quality Improvement**: 23% increase

**Deployment Status**: Ready for immediate implementation`,
        confidence: 0.91,
      },
      "what's the status of my pipelines?": {
        message: `ðŸ“Š **Real-Time Pipeline Status Dashboard**

**System Overview**: 8 of 10 pipelines operational

**ðŸŸ¢ HEALTHY PIPELINES (6)**

**Customer Data Sync Pipeline**
â€¢ Source: Salesforce â†’ Snowflake Data Warehouse
â€¢ Status: âœ… Running smoothly
â€¢ Last Execution: 2 minutes ago
â€¢ Records Processed: 45,231 (batched)
â€¢ Success Rate: 99.7%

**Transaction Processing Pipeline**
â€¢ Source: Payment Gateway â†’ PostgreSQL
â€¢ Status: âœ… Real-time processing
â€¢ Last Transaction: 15 seconds ago
â€¢ Records/Hour: 3,694 transactions
â€¢ Latency: 0.3s average

**ðŸ”´ FAILED PIPELINES (2)**

**Inventory Sync Pipeline**
â€¢ Source: ERP System â†’ Data Warehouse
â€¢ Status: âŒ Connection timeout
â€¢ Error: Database connection lost at 14:23
â€¢ **Action Required**: Manual intervention needed

**ðŸ“ˆ Performance Metrics (24h)**
â€¢ Total Records Processed: 2.3M
â€¢ Average Processing Time: 1.2 minutes
â€¢ Success Rate: 92.3%`,
        confidence: 0.88,
      },
      hello: {
        message: `ðŸ‘‹ **Welcome to CWIC AI Assistant!**

I'm your intelligent data governance companion, designed to help you navigate the complex world of data management with ease.

**ðŸ” Data Discovery & Cataloging**
â€¢ Automated discovery and lineage tracking
â€¢ Smart cataloging with AI-powered metadata

**ðŸ“Š Data Quality Management**
â€¢ Real-time monitoring and scoring
â€¢ Anomaly detection and validation rules

**ðŸ›¡ï¸ Compliance & Governance**
â€¢ PII/PHI discovery and classification
â€¢ GDPR / CCPA / HIPAA / PCI-DSS checks

**âš™ï¸ Pipeline & Workflow Management**
â€¢ Pipeline health monitoring
â€¢ Optimization recommendations

What would you like to explore first?`,
        confidence: 0.99,
      },
    };

    const lower = content.toLowerCase();
    for (const [key, resp] of Object.entries(responses)) {
      if (lower.includes(key)) {
        return { message: resp.message, processingTime, confidence: resp.confidence };
      }
    }
    return {
      message: `I understand you're asking about "${content}". Try topics like **"data quality issues"** or **"sensitive data discovery"**.`,
      processingTime,
      confidence: 0.85,
    };
  },
};

/* =========================
   Simple Markdown-ish renderer
   (bold, lists, code fences)
   ========================= */
const MarkdownBlock: React.FC<{ text: string }> = ({ text }) => {
  // Split by code fences ```lang\n...\n```
  const parts = useMemo(() => {
    const result: Array<{ kind: 'code' | 'text'; lang?: string; value: string }> = [];
    const fence = /```(\w+)?\n([\s\S]*?)```/g;
    let lastIndex = 0;
    let match: RegExpExecArray | null;

    while ((match = fence.exec(text))) {
      if (match.index > lastIndex) {
        result.push({ kind: 'text', value: text.slice(lastIndex, match.index) });
      }
      result.push({ kind: 'code', lang: match[1], value: match[2] });
      lastIndex = fence.lastIndex;
    }
    if (lastIndex < text.length) result.push({ kind: 'text', value: text.slice(lastIndex) });
    return result;
  }, [text]);

  const renderInline = (s: string) => {
    // **bold**
    const segments = s.split(/(\*\*.+?\*\*)/g);
    return segments.map((seg, i) =>
      seg.startsWith('**') && seg.endsWith('**') ? <strong key={i}>{seg.slice(2, -2)}</strong> : <React.Fragment key={i}>{seg}</React.Fragment>
    );
  };

  const renderText = (t: string) => {
    // split into lines and detect bullets
    return t.split('\n').map((line, i) => {
      if (!line.trim()) return <div key={i} className="h-1" />;

      const bullet = line.trim().match(/^(\*|-|â€¢)\s+/);
      if (bullet) {
        const content = line.trim().slice(bullet[0].length);
        return (
          <div key={i} className="pl-6 relative">
            <span className="absolute left-1 top-1.5 h-1.5 w-1.5 rounded-full bg-muted-foreground/70" />
            <span>{renderInline(content)}</span>
          </div>
        );
      }
      return <div key={i}>{renderInline(line)}</div>;
    });
  };

  return (
    <>
      {parts.map((p, idx) =>
        p.kind === 'code' ? (
          <pre
            key={idx}
            className="my-3 w-full overflow-x-auto rounded-lg bg-slate-900/95 p-3 text-slate-100 text-sm shadow-inner"
          >
            <div className="mb-2 text-xs uppercase tracking-wide opacity-60">{p.lang || 'code'}</div>
            <code>{p.value}</code>
          </pre>
        ) : (
          <div key={idx} className="space-y-1">
            {renderText(p.value)}
          </div>
        )
      )}
    </>
  );
};

/* =========================
   Hook: chat state
   ========================= */
const useAIChat = () => {
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim()) return;

    const userMsg: AIMessage = {
      id: `m_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
      type: 'user',
      content: content.trim(),
      timestamp: new Date(),
      metadata: { status: 'sending' },
    };

    setMessages((prev) => [...prev, userMsg]);
    setLoading(true);
    setError(null);

    try {
      let replyText = '';
      let processingTime = 0;
      let confidence: number | undefined;

      if (USE_BACKEND) {
        const res = await aiAssistantService.sendMessageWithFallback(content, {
          cacheKey: `q:${content}`,
        });
        const norm = normalizeBackendResponse(res);
        replyText = norm.text || '';
        processingTime = res?.meta?.processingTime ?? 0;
        confidence = res?.meta?.confidence;
      } else {
        const mock = await mockAIService.sendMessage(content);
        replyText = mock.message;
        processingTime = mock.processingTime;
        confidence = mock.confidence;
      }

      // Mark user message delivered
      setMessages((prev) =>
        prev.map((m) => (m.id === userMsg.id ? { ...m, metadata: { ...m.metadata, status: 'delivered' } } : m))
      );

      const assistantMsg: AIMessage = {
        id: `a_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        type: replyText ? 'assistant' : 'error',
        content: replyText || 'No response from AI service.',
        timestamp: new Date(),
        metadata: {
          processingTime,
          confidence,
          status: replyText ? 'delivered' : 'error',
        },
      };
      setMessages((prev) => [...prev, assistantMsg]);
    } catch (e: any) {
      setError(e?.message || 'Failed to get response.');
      setMessages((prev) =>
        prev.map((m) => (m.id === userMsg.id ? { ...m, metadata: { ...m.metadata, status: 'error' } } : m))
      );
    } finally {
      setLoading(false);
    }
  }, []);

  const clear = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  const retryLast = useCallback(() => {
    const lastUser = [...messages].reverse().find((m) => m.type === 'user');
    if (lastUser) sendMessage(lastUser.content);
  }, [messages, sendMessage]);

  return { messages, loading, error, sendMessage, clear, retryLast, isTyping: loading };
};

/* =========================
   Message bubble
   ========================= */
const MessageBubble: React.FC<{ message: AIMessage; onCopy?: (ok: boolean) => void }> = ({ message, onCopy }) => {
  const [copied, setCopied] = useState(false);
  const canCopy = message.type !== 'system';

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(message.content);
      setCopied(true);
      onCopy?.(true);
      setTimeout(() => setCopied(false), 1200);
    } catch {
      onCopy?.(false);
    }
  };

  const isUser = message.type === 'user';
  const isError = message.type === 'error';

  return (
    <div
      className={cx(
        'group relative mb-3 flex w-full',
        isUser ? 'justify-end' : 'justify-start'
      )}
    >
      <div
        className={cx(
          'max-w-[85%] rounded-2xl px-4 py-3 shadow-sm ring-1',
          isUser
            ? 'bg-violet-600 text-white ring-violet-600/20'
            : isError
            ? 'bg-rose-50 text-rose-900 ring-rose-200'
            : 'bg-white text-slate-900 ring-slate-200'
        )}
      >
        {/* Content */}
        <div className="prose prose-sm max-w-none prose-headings:my-2 prose-p:my-2 prose-strong:font-semibold prose-pre:my-0 prose-ul:my-2 prose-li:my-0">
          <MarkdownBlock text={message.content} />
        </div>

        {/* Meta row */}
        <div className={cx('mt-2 flex items-center gap-2 text-[11px]', isUser ? 'text-white/80' : 'text-slate-500')}>
          <span>{fmtTime(message.timestamp)}</span>
          {typeof message.metadata?.processingTime === 'number' && (
            <span>{Math.round(message.metadata.processingTime)}ms</span>
          )}
          {typeof message.metadata?.confidence === 'number' && (
            <span>{Math.round(message.metadata.confidence * 100)}%</span>
          )}
          {canCopy && (
            <button
              onClick={handleCopy}
              className={cx(
                'ml-auto inline-flex items-center gap-1 rounded-md px-2 py-0.5 text-[11px] transition',
                isUser
                  ? 'bg-white/15 hover:bg-white/25 active:bg-white/30'
                  : 'bg-slate-100 hover:bg-slate-200 active:bg-slate-300'
              )}
              title="Copy"
              aria-label="Copy message"
            >
              {copied ? <CheckCheck size={14} /> : <Copy size={14} />}
              {copied ? 'Copied' : 'Copy'}
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

/* =========================
   Typing indicator
   ========================= */
const TypingIndicator: React.FC = () => (
  <div className="mb-3 flex w-full justify-start">
    <div className="rounded-2xl bg-white px-4 py-3 ring-1 ring-slate-200">
      <div className="flex items-center gap-2 text-slate-500">
        <div className="flex items-center gap-1">
          <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-slate-400 [animation-delay:-200ms]" />
          <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-slate-400" />
          <span className="h-1.5 w-1.5 animate-bounce rounded-full bg-slate-400 [animation-delay:200ms]" />
        </div>
        <span className="text-xs">AI is thinkingâ€¦</span>
      </div>
    </div>
  </div>
);

/* =========================
   Main component
   ========================= */
export const ChatInterface: React.FC<ChatInterfaceProps> = ({
  className,
  placeholder = 'Ask me anything about your dataâ€¦',
  showHeader = false, // avoid duplicate page titles by default
}) => {
  const [input, setInput] = useState('');
  const suggestions = useMemo(
    () => [
      'Show me data quality issues',
      'Find sensitive data in my database',
      'Generate quality rules for customer data',
      "Whatâ€™s the status of my pipelines?",
    ],
    []
  );

  const { messages, loading, error, sendMessage, clear, retryLast, isTyping } = useAIChat();
  const endRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    endRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isTyping]);

  const handleSend = useCallback(async () => {
    if (!input.trim() || loading) return;
    const msg = input.trim();
    setInput('');
    try {
      await sendMessage(msg);
    } catch {
      setInput(msg);
    }
  }, [input, loading, sendMessage]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    },
    [handleSend]
  );

  const handleSuggestion = useCallback(
    (s: string) => {
      setInput(s);
      setTimeout(() => handleSend(), 50);
    },
    [handleSend]
  );

  return (
    <div
      className={cx(
        'flex h-full min-h-[580px] w-full flex-col rounded-xl border border-slate-200 bg-slate-50/60',
        'shadow-sm backdrop-blur-[2px]',
        className
      )}
    >
      {/* Header (optional, subdued) */}
      {showHeader && (
        <div className="flex items-center justify-between border-b border-slate-200/80 px-4 py-3">
          <div className="flex items-center gap-3">
            <div className="flex h-8 w-8 items-center justify-center rounded-full bg-violet-600 text-white shadow">
              <Sparkles size={18} />
            </div>
            <div>
              <div className="text-sm font-semibold leading-tight">CWIC AI Assistant</div>
              <div className="text-xs text-slate-500 leading-tight">Your intelligent data governance companion</div>
            </div>
          </div>
          {messages.length > 0 && (
            <button
              onClick={clear}
              className="inline-flex items-center gap-2 rounded-md border border-slate-200 bg-white px-3 py-1.5 text-xs text-slate-700 hover:bg-slate-50"
              title="Clear conversation"
              aria-label="Clear conversation"
            >
              <Trash2 size={14} />
              Clear
            </button>
          )}
        </div>
      )}

      {/* Messages */}
      <div className="flex-1 overflow-y-auto px-4 py-4">
        {/* Empty welcome state */}
        {messages.length === 0 && (
          <div className="mb-4 rounded-xl border border-slate-200 bg-white p-5 shadow-sm">
            <div className="mb-4 flex items-center gap-3">
              <div className="flex h-9 w-9 items-center justify-center rounded-full bg-violet-600 text-white">
                <Sparkles size={18} />
              </div>
              <div>
                <div className="text-sm font-semibold">Welcome to CWIC AI</div>
                <div className="text-xs text-slate-500">
                  Ask about discovery, quality, compliance, or pipelines.
                </div>
              </div>
            </div>

            <div className="grid grid-cols-1 gap-3 sm:grid-cols-3">
              <div className="rounded-lg border border-slate-200 p-4">
                <Database className="mb-2 text-slate-600" size={28} />
                <div className="text-sm font-medium">Data Discovery</div>
                <div className="text-xs text-slate-500">Find and catalog data across sources</div>
              </div>
              <div className="rounded-lg border border-slate-200 p-4">
                <Zap className="mb-2 text-slate-600" size={28} />
                <div className="text-sm font-medium">Quality Analysis</div>
                <div className="text-xs text-slate-500">Monitor and improve data quality</div>
              </div>
              <div className="rounded-lg border border-slate-200 p-4">
                <Shield className="mb-2 text-slate-600" size={28} />
                <div className="text-sm font-medium">Compliance</div>
                <div className="text-xs text-slate-500">Ensure regulatory compliance</div>
              </div>
            </div>

            <div className="mt-4">
              <div className="mb-2 text-xs font-medium text-slate-600">Try asking:</div>
              <div className="flex flex-wrap gap-2">
                {suggestions.map((s) => (
                  <button
                    key={s}
                    onClick={() => handleSuggestion(s)}
                    className="rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs text-slate-700 hover:bg-slate-50"
                  >
                    {s}
                  </button>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Conversation */}
        {messages.map((m) => (
          <MessageBubble key={m.id} message={m} />
        ))}

        {isTyping && <TypingIndicator />}

        {error && (
          <div
            className="mt-3 flex items-center gap-2 rounded-md border border-amber-200 bg-amber-50 px-3 py-2 text-sm text-amber-800"
            role="alert"
          >
            <AlertTriangle size={16} />
            <span>{error}</span>
            <button
              onClick={retryLast}
              className="ml-auto inline-flex items-center gap-1 rounded-md border border-amber-200 bg-white px-2 py-1 text-xs text-amber-800 hover:bg-amber-50"
            >
              Retry
            </button>
          </div>
        )}

        <div ref={endRef} aria-hidden="true" />
      </div>

      {/* Composer */}
      <div className="border-t border-slate-200/80 bg-white/80 px-4 py-3">
        <div className="flex items-end gap-2">
          <div className="relative flex-1">
            <input
              ref={inputRef}
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={placeholder}
              disabled={loading}
              maxLength={500}
              aria-label="Message"
              className={cx(
                'w-full rounded-xl border border-slate-300 bg-white px-4 py-3 text-sm shadow-sm outline-none',
                'placeholder:text-slate-400 focus:border-violet-500 focus:ring-2 focus:ring-violet-200 disabled:opacity-60'
              )}
            />
            <div className="pointer-events-none absolute bottom-2 right-3 text-[11px] text-slate-400">
              {input.length}/500
            </div>
          </div>

          <button
            onClick={handleSend}
            disabled={!input.trim() || loading}
            className={cx(
              'inline-flex h-11 items-center justify-center gap-2 rounded-xl px-4 text-sm font-medium text-white shadow-sm transition',
              loading
                ? 'bg-violet-400'
                : 'bg-violet-600 hover:bg-violet-700 active:bg-violet-800'
            )}
            aria-label={loading ? 'Sending' : 'Send message'}
          >
            {loading ? <RotateCcw className="animate-spin" size={18} /> : <Send size={18} />}
            <span className="hidden sm:inline">{loading ? 'Sending' : 'Send'}</span>
          </button>
        </div>
        <div className="mt-1 text-[11px] text-slate-400">Press Enter to send</div>
      </div>
    </div>
  );
};

export default ChatInterface;



------------------------------------------------------------
FILE: frontend\src\components\features\ai-assistant\index.ts
------------------------------------------------------------
export { ActionButtons } from './ActionButtons';
export { ChatInterface } from './ChatInterface';
export { MessageBubble } from './MessageBubble';
export { TypingIndicator } from './TypingIndicator';

// Default exports for compatibility
export { default as ActionButtonsDefault } from './ActionButtons';
export { default as ChatInterfaceDefault } from './ChatInterface';
export { default as MessageBubbleDefault } from './MessageBubble';
export { default as TypingIndicatorDefault } from './TypingIndicator';

// Types
export type { AIMessage } from './MessageBubble';



------------------------------------------------------------
FILE: frontend\src\components\features\ai-assistant\MessageBubble.tsx
------------------------------------------------------------
import React from 'react';

export interface AIMessage {
  id: string;
  type: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date | string;
  metadata?: {
    processingTime?: number;
    confidence?: number;   // 0..1
    sources?: string[];
  };
}

export interface MessageBubbleProps {
  message: AIMessage;
  showMetadata?: boolean;
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({ message, showMetadata = false }) => {
  const isUser = message.type === 'user';
  const ts = message.timestamp instanceof Date ? message.timestamp : new Date(message.timestamp);

  const formatTime = (d: Date) => d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const lines = String(message.content || '').split('\n');

  const hasProcessing = typeof message.metadata?.processingTime === 'number';
  const hasConfidence = typeof message.metadata?.confidence === 'number';
  const hasSources   = Array.isArray(message.metadata?.sources) && message.metadata!.sources!.length > 0;

  return (
    <div className={`message-bubble ${isUser ? 'user' : 'assistant'}`}>
      <div className="message-content">
        <div className="message-text">
          {lines.map((line, i) => (
            <React.Fragment key={i}>
              {line}{i < lines.length - 1 && <br />}
            </React.Fragment>
          ))}
        </div>

        <div className="message-meta">
          <span className="timestamp">{formatTime(ts)}</span>
          {showMetadata && (
            <>
              {hasProcessing && <span className="processing-time">{message.metadata!.processingTime}ms</span>}
              {hasConfidence && (
                <span className="confidence">
                  {Math.round((message.metadata!.confidence as number) * 100)}% confident
                </span>
              )}
              {hasSources && <span className="sources">Sources: {message.metadata!.sources!.join(', ')}</span>}
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default MessageBubble;



------------------------------------------------------------
FILE: frontend\src\components\features\ai-assistant\TypingIndicator.tsx
------------------------------------------------------------
import React from 'react';

interface TypingIndicatorProps {
  className?: string;
  message?: string;
}

export const TypingIndicator: React.FC<TypingIndicatorProps> = ({ 
  className = '', 
  message = 'AI is thinking...' 
}) => {
  return (
    <div className={`typing-indicator ${className}`}>
      <div className="typing-bubble">
        <div className="typing-dots">
          <span className="dot"></span>
          <span className="dot"></span>
          <span className="dot"></span>
        </div>
        <div className="typing-message">{message}</div>
      </div>
    </div>
  );
};

// Default export for compatibility
export default TypingIndicator;


------------------------------------------------------------
FILE: frontend\src\components\features\connections\ConnectionForm.tsx
------------------------------------------------------------
import type { DataSource, DataSourceType } from '@/types/dataSources'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Input } from '@components/ui/Input'
import { Select } from '@components/ui/Select'
import * as React from 'react'

export interface ConnectionFormProps {
  initial?: Partial<DataSource>
  onSave?: (draft: Partial<DataSource>) => Promise<void> | void
  onClose?: () => void // <-- make onClose valid; your page is passing it
}

export function ConnectionForm({ initial, onSave, onClose }: ConnectionFormProps) {
  const [draft, setDraft] = React.useState<Partial<DataSource>>({
    name: initial?.name ?? '',
    type: (initial?.type as DataSourceType) ?? 'azure-sql',
    host: initial?.host ?? '',
    database: initial?.database ?? '',
    schema: initial?.schema ?? '',
    username: initial?.username ?? '',
  })

  function patch<K extends keyof DataSource>(k: K, v: DataSource[K] | string) {
    setDraft((d) => ({ ...d, [k]: v as any }))
  }

  async function submit(e: React.FormEvent) {
    e.preventDefault()
    await onSave?.(draft)
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>{initial?.id ? 'Edit Connection' : 'New Connection'}</CardTitle>
      </CardHeader>
      <CardContent>
        <form className="space-y-4" onSubmit={submit}>
          <Input placeholder="Name" value={draft.name ?? ''} onChange={(e) => patch('name', e.target.value)} />
          <Select
            label="Type"
            value={(draft.type as string) ?? 'azure-sql'}
            onChange={(e) => patch('type', e.target.value)}
            options={[
              { label: 'Azure SQL', value: 'azure-sql' },
              { label: 'Synapse', value: 'synapse' },
              { label: 'Fabric', value: 'fabric' },
              { label: 'Data Lake', value: 'data-lake' },
              { label: 'Postgres', value: 'postgres' },
              { label: 'Snowflake', value: 'snowflake' },
            ]}
          />
          <div className="grid gap-3 sm:grid-cols-2">
            <Input placeholder="Host" value={draft.host ?? ''} onChange={(e) => patch('host', e.target.value)} />
            <Input placeholder="Database" value={draft.database ?? ''} onChange={(e) => patch('database', e.target.value)} />
            <Input placeholder="Schema" value={draft.schema ?? ''} onChange={(e) => patch('schema', e.target.value)} />
            <Input placeholder="Username" value={draft.username ?? ''} onChange={(e) => patch('username', e.target.value)} />
          </div>

          <div className="flex justify-end gap-2">
            <Button variant="outline" type="button" onClick={onClose}>Cancel</Button>
            <Button type="submit">Save</Button>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\connections\DataSourceList.tsx
------------------------------------------------------------
import type { DataSource } from '@/types/dataSources'
import { Badge } from '@components/ui/Badge'
import { Card, CardContent } from '@components/ui/Card'

export function DataSourceList({
  items = [],
  onSelect,
}: {
  items?: DataSource[]
  onSelect?: (id: string) => void
}) {
  if (!items.length) {
    return <div className="text-sm text-gray-600">No data sources connected.</div>
  }
  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
      {items.map((ds) => (
        <Card
          key={ds.id}
          className="cursor-pointer transition hover:shadow-sm"
          onClick={() => onSelect?.(ds.id)}
          role="button"
          tabIndex={0}
          onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && onSelect?.(ds.id)}
        >
          <CardContent className="p-5">
            <div className="flex items-start justify-between">
              <div className="min-w-0">
                <div className="truncate text-base font-semibold text-gray-900">{ds.name}</div>
                <div className="mt-1 text-sm text-gray-600">{ds.host ?? 'â€”'}</div>
              </div>
              <div className="text-right">
                <Badge tone="neutral" className="capitalize">{ds.type}</Badge>
                {ds.status && (
                  <div className="mt-2">
                    <Badge tone={ds.status === 'healthy' ? 'success' : ds.status === 'warning' ? 'warning' : 'danger'}>
                      {ds.status}
                    </Badge>
                  </div>
                )}
              </div>
            </div>
            {ds.updatedAt && (
              <div className="mt-3 text-xs text-gray-500">Updated {new Date(ds.updatedAt).toLocaleString()}</div>
            )}
          </CardContent>
        </Card>
      ))}
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\connections\HealthMonitor.tsx
------------------------------------------------------------
import type { DataSource } from '@/types/dataSources';
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card';
import * as React from 'react';

type LegacyItem = { name: string; status: 'up' | 'down'; latencyMs?: number }

type Props =
  | { dataSources: DataSource[]; items?: never }
  | { items: LegacyItem[]; dataSources?: never }
  | { dataSources?: DataSource[]; items?: LegacyItem[] } // allow both; dataSources wins

export function HealthMonitor(props: Props) {
  // Normalize to a single render shape
  const normalized: LegacyItem[] = React.useMemo(() => {
    if (props.dataSources && props.dataSources.length) {
      return props.dataSources.map((ds) => ({
        name: ds.name,
        status: ds.status === 'down' || ds.status === 'error' ? 'down' : 'up',
        latencyMs:
          typeof ds.metadata === 'object' && ds.metadata
            ? (ds.metadata['latencyMs'] as number | undefined)
            : undefined,
      }))
    }
    return (props.items ?? []).map((x) => ({ ...x }))
  }, [props])

  const totals = React.useMemo(() => {
    const total = normalized.length
    const up = normalized.filter((i) => i.status === 'up').length
    const down = total - up
    return { total, up, down }
  }, [normalized])

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Health Monitor</CardTitle>
          <div className="text-sm text-gray-600">
            Total: <strong>{totals.total}</strong> Â· Up: <strong className="text-green-600">{totals.up}</strong> Â· Down:{' '}
            <strong className="text-red-600">{totals.down}</strong>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {normalized.length === 0 ? (
          <div className="text-sm text-gray-600">No sources to monitor.</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead className="text-left text-gray-500">
                <tr>
                  <th className="py-2 pr-4">Source</th>
                  <th className="py-2 pr-4">Status</th>
                  <th className="py-2 pr-4">Latency</th>
                </tr>
              </thead>
              <tbody>
                {normalized.map((i) => (
                  <tr key={i.name} className="border-t">
                    <td className="py-2 pr-4 font-medium text-gray-900">{i.name}</td>
                    <td className="py-2 pr-4">
                      <span
                        className={[
                          'inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium',
                          i.status === 'up'
                            ? 'bg-green-100 text-green-800'
                            : 'bg-red-100 text-red-800',
                        ].join(' ')}
                      >
                        <span
                          className={[
                            'mr-1 inline-block h-2 w-2 rounded-full',
                            i.status === 'up' ? 'bg-green-500' : 'bg-red-500',
                          ].join(' ')}
                        />
                        {i.status}
                      </span>
                    </td>
                    <td className="py-2 pr-4">
                      {typeof i.latencyMs === 'number' ? `${i.latencyMs} ms` : 'â€”'}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default HealthMonitor



------------------------------------------------------------
FILE: frontend\src\components\features\connections\index.ts
------------------------------------------------------------
export { ConnectionForm } from './ConnectionForm'
export { ConnectionTest } from './ConnectionTest'
export { DataSourceList } from './DataSourceList'
export { HealthMonitor } from './HealthMonitor'




------------------------------------------------------------
FILE: frontend\src\components\features\dashboard\ActivityFeed.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'

export type Activity = {
  id: string
  time: string            // ISO
  title: string
  detail?: string
  type?: 'info' | 'success' | 'warning' | 'error'
}

export interface ActivityFeedProps {
  items?: Activity[]
  emptyText?: string
  title?: string
  loading?: boolean
}

export function ActivityFeed({
  items = [],
  emptyText = 'No recent activity.',
  title = 'Recent Activity',
  loading,
}: ActivityFeedProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        {loading ? (
          <ul className="divide-y">
            {Array.from({ length: 5 }).map((_, i) => (
              <li key={i} className="py-3">
                <div className="h-4 w-56 rounded bg-gray-200 animate-pulse" />
                <div className="mt-2 h-4 w-72 rounded bg-gray-200 animate-pulse" />
              </li>
            ))}
          </ul>
        ) : items.length === 0 ? (
          <div className="text-sm text-gray-600">{emptyText}</div>
        ) : (
          <ul className="divide-y">
            {items.map((a) => (
              <li key={a.id} className="py-3">
                <div className="flex items-start justify-between gap-3">
                  <div>
                    <div className="text-sm font-medium text-gray-900">{a.title}</div>
                    {a.detail && <div className="text-sm text-gray-600">{a.detail}</div>}
                  </div>
                  <div className="flex items-center gap-2">
                    {a.type && <Badge tone={mapTone(a.type)}>{a.type}</Badge>}
                    <span className="text-xs text-gray-500">{fmt(a.time)}</span>
                  </div>
                </div>
              </li>
            ))}
          </ul>
        )}
      </CardContent>
    </Card>
  )
}

function mapTone(t: NonNullable<Activity['type']>) {
  return t === 'success' ? 'success'
    : t === 'warning' ? 'warning'
    : t === 'error' ? 'danger'
    : 'info'
}
function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}



------------------------------------------------------------
FILE: frontend\src\components\features\dashboard\DashboardOverview.tsx
------------------------------------------------------------
import type { Activity } from './ActivityFeed'
import { ActivityFeed } from './ActivityFeed'
import type { KPI } from './KPICards'
import { KPICards } from './KPICards'
import { QuickActions } from './QuickActions'

export interface DashboardOverviewProps {
  kpis: KPI[]
  activities: Activity[]
  loadingKpis?: boolean
  loadingActivity?: boolean
  onNewScan?: () => void
  onRefresh?: () => void
  onImport?: () => void
}

/** A layout helper that arranges KPI, actions, and activity into a single section */
export function DashboardOverview({
  kpis,
  activities,
  loadingKpis,
  loadingActivity,
  onNewScan,
  onRefresh,
  onImport,
}: DashboardOverviewProps) {
  return (
    <div className="space-y-6">
      <KPICards items={kpis} loading={loadingKpis} />
      <QuickActions onNewScan={onNewScan} onRefresh={onRefresh} onImport={onImport} />
      <ActivityFeed items={activities} loading={loadingActivity} />
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\dashboard\index.ts
------------------------------------------------------------
export { KPICards } from './KPICards'
export type { KPI } from './KPICards'

export { ActivityFeed } from './ActivityFeed'
export type { Activity } from './ActivityFeed'

export { DashboardOverview } from './DashboardOverview'
export { QuickActions } from './QuickActions'




------------------------------------------------------------
FILE: frontend\src\components\features\dashboard\KPICards.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Card, CardContent } from '@components/ui/Card'
import { Activity, Database, Shield, Users } from 'lucide-react'

export type Trend = 'up' | 'down' | 'flat'

export interface KPI {
  id: string
  label: string
  value: number | string
  diff?: number // percentage points
  trend?: Trend
  icon?: 'activity' | 'shield' | 'database' | 'users'
  tone?: 'default' | 'success' | 'warning' | 'danger' | 'info' | 'neutral'
}

export interface KPICardsProps {
  items: KPI[]
  loading?: boolean
}

export function KPICards({ items, loading }: KPICardsProps) {
  if (loading) return <KPISkeleton />
  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-4">
      {items.map((k) => (
        <Card key={k.id} className="transition hover:shadow-sm">
          <CardContent className="p-5">
            <div className="flex items-center justify-between">
              <div className="text-sm text-gray-600">{k.label}</div>
              <Icon name={k.icon} />
            </div>

            <div className="mt-2 text-2xl font-semibold text-gray-900">{k.value}</div>

            {typeof k.diff === 'number' && (
              <div className="mt-2">
                <Badge tone={diffTone(k.trend)}>{diffLabel(k.diff, k.trend)}</Badge>
              </div>
            )}
          </CardContent>
        </Card>
      ))}
    </div>
  )
}

function Icon({ name }: { name?: KPI['icon'] }) {
  const cls = 'h-6 w-6 text-blue-600'
  if (name === 'shield') return <Shield className={cls} />
  if (name === 'database') return <Database className={cls} />
  if (name === 'users') return <Users className={cls} />
  return <Activity className={cls} />
}

function diffLabel(diff: number, trend?: Trend) {
  const sign = trend === 'down' ? 'âˆ’' : trend === 'up' ? '+' : ''
  return `${sign}${Math.abs(diff).toFixed(1)}%`
}
function diffTone(trend?: Trend): NonNullable<KPI['tone']> {
  if (trend === 'up') return 'success'
  if (trend === 'down') return 'danger'
  return 'neutral'
}

function KPISkeleton() {
  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-4">
      {Array.from({ length: 4 }).map((_, i) => (
        <Card key={i}>
          <CardContent className="p-5">
            <div className="flex items-center justify-between">
              <div className="h-4 w-24 animate-pulse rounded bg-gray-200" />
              <div className="h-6 w-6 animate-pulse rounded bg-gray-200" />
            </div>
            <div className="mt-2 h-7 w-20 animate-pulse rounded bg-gray-200" />
            <div className="mt-2 h-5 w-16 animate-pulse rounded bg-gray-200" />
          </CardContent>
        </Card>
      ))}
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\dashboard\QuickActions.tsx
------------------------------------------------------------
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Play, RefreshCcw, Upload } from 'lucide-react'

export interface QuickActionsProps {
  onNewScan?: () => void
  onRefresh?: () => void
  onImport?: () => void
  busy?: boolean
}

export function QuickActions({ onNewScan, onRefresh, onImport, busy }: QuickActionsProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Quick Actions</CardTitle>
      </CardHeader>
      <CardContent className="flex flex-wrap gap-3">
        <Button onClick={onNewScan} disabled={busy} leftIcon={<Play className="h-4 w-4" />}>
          Start New Scan
        </Button>
        <Button variant="outline" onClick={onRefresh} disabled={busy} leftIcon={<RefreshCcw className="h-4 w-4" />}>
          Refresh Data
        </Button>
        <Button variant="secondary" onClick={onImport} disabled={busy} leftIcon={<Upload className="h-4 w-4" />}>
          Import Metadata
        </Button>
      </CardContent>
    </Card>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-catalog\AssetCard.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Card, CardContent } from '@components/ui/Card'
import { cn } from '@utils'

export type Asset = {
  id: string
  name: string
  description?: string
  type?: 'table' | 'view' | 'file' | 'dashboard' | 'ml-model' | string
  owner?: string
  tags?: string[]
  updatedAt?: string
  qualityScore?: number
}

export interface AssetCardProps {
  asset: Asset
  onClick?: (id: string) => void
  className?: string
}

export function AssetCard({ asset, onClick, className }: AssetCardProps) {
  const tone = typeof asset.qualityScore === 'number'
    ? asset.qualityScore >= 90 ? 'success'
      : asset.qualityScore >= 75 ? 'warning'
      : 'danger'
    : 'neutral'

  return (
    <Card
      className={cn('cursor-pointer transition hover:shadow-md', className)}
      onClick={() => onClick?.(asset.id)}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && onClick?.(asset.id)}
    >
      <CardContent className="p-5">
        <div className="flex items-start justify-between gap-3">
          <div className="min-w-0">
            <div className="truncate text-base font-semibold text-gray-900">{asset.name}</div>
            {asset.description && (
              <div className="mt-1 line-clamp-2 text-sm text-gray-600">{asset.description}</div>
            )}
            <div className="mt-2 flex flex-wrap gap-1">
              {asset.tags?.slice(0, 4).map((t) => (
                <span key={t} className="rounded bg-gray-100 px-2 py-0.5 text-[11px] text-gray-700">{t}</span>
              ))}
              {asset.tags && asset.tags.length > 4 && (
                <span className="rounded bg-gray-100 px-2 py-0.5 text-[11px] text-gray-700">+{asset.tags.length - 4}</span>
              )}
            </div>
          </div>
          <div className="text-right">
            <Badge tone="neutral">{asset.type ?? 'asset'}</Badge>
            {typeof asset.qualityScore === 'number' && (
              <div className="mt-2">
                <Badge tone={tone}>QS: {asset.qualityScore.toFixed(1)}%</Badge>
              </div>
            )}
          </div>
        </div>
        {asset.owner || asset.updatedAt ? (
          <div className="mt-3 flex flex-wrap items-center gap-3 text-xs text-gray-500">
            {asset.owner && <span>Owner: {asset.owner}</span>}
            {asset.updatedAt && <span>Updated: {fmt(asset.updatedAt)}</span>}
          </div>
        ) : null}
      </CardContent>
    </Card>
  )
}

function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-catalog\AssetDetails.tsx
------------------------------------------------------------
import type { Asset } from '@/types/dataAssets'
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Modal } from '@components/ui/Modal'
import * as React from 'react'

export function AssetDetails({
  asset,
  isOpen,
  onClose,
  onRequestAccess,
}: {
  asset: Asset | null
  isOpen: boolean
  onClose: () => void
  onRequestAccess?: (assetId: string) => void
}) {
  if (!asset) return null

  const scoreTone =
    typeof asset.qualityScore === 'number'
      ? asset.qualityScore >= 90 ? 'success' : asset.qualityScore >= 75 ? 'warning' : 'danger'
      : 'neutral'

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`Asset â€¢ ${asset.name}`} size="lg">
      <div className="space-y-5">
        <Card>
          <CardHeader>
            <CardTitle>Overview</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3 text-sm">
            <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
              <Detail label="Type"><Badge tone="neutral">{asset.type ?? 'asset'}</Badge></Detail>
              <Detail label="Owner">{asset.owner ?? 'â€”'}</Detail>
              <Detail label="Updated">{asset.updatedAt ? fmt(asset.updatedAt) : 'â€”'}</Detail>
              <Detail label="Quality">
                {typeof asset.qualityScore === 'number'
                  ? <Badge tone={scoreTone}>{asset.qualityScore.toFixed(1)}%</Badge>
                  : 'â€”'}
              </Detail>
            </div>
            {asset.description && <p className="text-gray-700">{asset.description}</p>}
            {asset.tags?.length ? (
              <div className="flex flex-wrap gap-1">
                {asset.tags.map((t) => (
                  <span key={t} className="rounded bg-gray-100 px-2 py-0.5 text-xs text-gray-700">{t}</span>
                ))}
              </div>
            ) : null}
          </CardContent>
        </Card>

        <div className="flex justify-end gap-2">
          <Button variant="outline" onClick={onClose}>Close</Button>
          <Button onClick={() => asset && onRequestAccess?.(asset.id)}>Request Access</Button>
        </div>
      </div>
    </Modal>
  )
}

function Detail({ label, children }: { label: string; children?: React.ReactNode }) {
  return (
    <div>
      <div className="text-xs text-gray-500">{label}</div>
      <div className="text-sm text-gray-900">{children}</div>
    </div>
  )
}

function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-catalog\AssetGrid.tsx
------------------------------------------------------------
// src/components/features/data-catalog/AssetGrid.tsx
import { useState } from 'react';

// Types included directly to avoid import issues
interface Asset {
  id: string;
  name: string;
  type: string;
  description?: string;
  owner?: string;
  tags?: string[];
  dataSourceId: string;
  dataSourceName: string;
  schema?: string;
  database?: string;
  rowCount?: number;
  columnCount?: number;
  sizeBytes?: number;
  quality?: 'high' | 'medium' | 'low';
  classification?: 'public' | 'internal' | 'confidential' | 'restricted';
  sensitivityLevel?: string;
  createdAt: string;
  updatedAt: string;
  lastAccessedAt?: string;
  lastProfiledAt?: string;
  queryCount?: number;
  accessCount?: number;
  popularityScore?: number;
  customProperties?: Record<string, any>;
}

interface AssetGridProps {
  items: Asset[];
  onSelect: (id: string) => void;
  loading?: boolean;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  onPageChange?: (page: number) => void;
  error?: string | null;
  isEmpty?: boolean;
  hasFilters?: boolean;
  viewMode?: 'grid' | 'list';
  onViewModeChange?: (mode: 'grid' | 'list') => void;
}

export function AssetGrid({
  items,
  onSelect,
  loading = false,
  pagination,
  onPageChange,
  error,
  isEmpty = false,
  hasFilters = false,
  viewMode = 'grid',
  onViewModeChange
}: AssetGridProps) {
  const [localViewMode, setLocalViewMode] = useState<'grid' | 'list'>(viewMode);

  const handleViewModeChange = (mode: 'grid' | 'list') => {
    setLocalViewMode(mode);
    onViewModeChange?.(mode);
  };

  // Loading skeleton
  if (loading && items.length === 0) {
    return (
      <div className="space-y-6">
        {/* View mode toggle skeleton */}
        <div className="flex justify-end">
          <div className="h-10 w-24 bg-gray-200 rounded-lg animate-pulse"></div>
        </div>
        
        {/* Grid skeleton */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {Array.from({ length: 6 }).map((_, i) => (
            <AssetCardSkeleton key={i} />
          ))}
        </div>
      </div>
    );
  }

  // Empty state
  if (isEmpty && !loading) {
    return (
      <div className="text-center py-12">
        <div className="text-6xl mb-4">ðŸ“Š</div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">No assets found</h3>
        <p className="text-gray-600 mb-4">
          {hasFilters 
            ? 'Try adjusting your filters or search terms.'
            : 'Assets will appear here after syncing your data sources.'}
        </p>
        {hasFilters && (
          <button 
            onClick={() => window.location.reload()} 
            className="text-blue-600 hover:text-blue-800"
          >
            Clear all filters
          </button>
        )}
      </div>
    );
  }

  // Error state
  if (error && !loading) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
        <div className="text-red-600 text-lg font-medium mb-2">
          Failed to load assets
        </div>
        <p className="text-red-700 mb-4">{error}</p>
        <button
          onClick={() => window.location.reload()}
          className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
        >
          Retry
        </button>
      </div>
    );
  }

  const currentViewMode = onViewModeChange ? viewMode : localViewMode;

  return (
    <div className="space-y-6">
      {/* Header with view mode toggle */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-600">
          {loading ? (
            <span className="flex items-center">
              <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              Loading assets...
            </span>
          ) : (
            <>
              Showing {items.length} of {pagination?.total || 0} assets
              {pagination && pagination.totalPages > 1 && (
                <span className="ml-2">
                  (Page {pagination.page} of {pagination.totalPages})
                </span>
              )}
            </>
          )}
        </div>

        {/* View mode toggle */}
        <div className="flex border border-gray-300 rounded-lg">
          <button
            onClick={() => handleViewModeChange('grid')}
            className={`px-3 py-2 text-sm ${
              currentViewMode === 'grid' 
                ? 'bg-blue-600 text-white' 
                : 'text-gray-600 hover:bg-gray-50'
            } rounded-l-lg`}
          >
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
            </svg>
          </button>
          <button
            onClick={() => handleViewModeChange('list')}
            className={`px-3 py-2 text-sm ${
              currentViewMode === 'list' 
                ? 'bg-blue-600 text-white' 
                : 'text-gray-600 hover:bg-gray-50'
            } rounded-r-lg`}
          >
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
            </svg>
          </button>
        </div>
      </div>

      {/* Assets Grid/List */}
      <div className={
        currentViewMode === 'grid' 
          ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6' 
          : 'space-y-4'
      }>
        {items.map(asset => (
          <AssetCard
            key={asset.id}
            asset={asset}
            onClick={() => onSelect(asset.id)}
            viewMode={currentViewMode}
          />
        ))}
      </div>

      {/* Pagination */}
      {pagination && pagination.totalPages > 1 && onPageChange && (
        <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6">
          <div className="flex flex-1 justify-between sm:hidden">
            <button
              onClick={() => onPageChange(pagination.page - 1)}
              disabled={pagination.page <= 1}
              className="relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Previous
            </button>
            <button
              onClick={() => onPageChange(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
              className="relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Next
            </button>
          </div>
          <div className="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
            <div>
              <p className="text-sm text-gray-700">
                Showing{' '}
                <span className="font-medium">{(pagination.page - 1) * pagination.limit + 1}</span>
                {' '}to{' '}
                <span className="font-medium">
                  {Math.min(pagination.page * pagination.limit, pagination.total)}
                </span>
                {' '}of{' '}
                <span className="font-medium">{pagination.total}</span> results
              </p>
            </div>
            <div>
              <nav className="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
                <button
                  onClick={() => onPageChange(pagination.page - 1)}
                  disabled={pagination.page <= 1}
                  className="relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <span className="sr-only">Previous</span>
                  <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" />
                  </svg>
                </button>

                {/* Page numbers */}
                {getPageNumbers(pagination.page, pagination.totalPages).map((pageNum, index) => (
                  pageNum === '...' ? (
                    <span key={index} className="relative inline-flex items-center px-4 py-2 text-sm font-semibold text-gray-700 ring-1 ring-inset ring-gray-300 focus:outline-offset-0">
                      ...
                    </span>
                  ) : (
                    <button
                      key={index}
                      onClick={() => onPageChange(pageNum as number)}
                      className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                        pageNum === pagination.page
                          ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                          : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0'
                      }`}
                    >
                      {pageNum}
                    </button>
                  )
                ))}

                <button
                  onClick={() => onPageChange(pagination.page + 1)}
                  disabled={pagination.page >= pagination.totalPages}
                  className="relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <span className="sr-only">Next</span>
                  <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fillRule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clipRule="evenodd" />
                  </svg>
                </button>
              </nav>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Asset Card Component
function AssetCard({ asset, onClick, viewMode }: { asset: Asset; onClick: () => void; viewMode: 'grid' | 'list' }) {
  const getAssetIcon = (type: string) => {
    const icons: Record<string, string> = {
      table: 'ðŸ—ƒï¸',
      view: 'ðŸ‘ï¸',
      materialized_view: 'ðŸ‘ï¸',
      file: 'ðŸ“„',
      stream: 'ðŸŒŠ',
      api: 'ðŸ”Œ',
      dataset: 'ðŸ“Š',
      model: 'ðŸ¤–',
      dashboard: 'ðŸ“ˆ',
      report: 'ðŸ“‹'
    };
    return icons[type] || 'ðŸ“Š';
  };

  const getQualityColor = (quality?: string) => {
    const colors = {
      high: 'bg-green-100 text-green-800',
      medium: 'bg-yellow-100 text-yellow-800',
      low: 'bg-red-100 text-red-800'
    };
    return quality ? colors[quality as keyof typeof colors] || 'bg-gray-100 text-gray-800' : 'bg-gray-100 text-gray-800';
  };

  const getClassificationColor = (classification?: string) => {
    const colors = {
      public: 'bg-blue-100 text-blue-800',
      internal: 'bg-purple-100 text-purple-800',
      confidential: 'bg-orange-100 text-orange-800',
      restricted: 'bg-red-100 text-red-800'
    };
    return classification ? colors[classification as keyof typeof colors] || 'bg-gray-100 text-gray-800' : 'bg-gray-100 text-gray-800';
  };

  const formatNumber = (num?: number) => {
    return num ? new Intl.NumberFormat().format(num) : 'â€”';
  };

  const formatRelativeTime = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) {
      return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    } else if (diffHours > 0) {
      return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    } else {
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
    }
  };

  if (viewMode === 'list') {
    return (
      <div 
        onClick={onClick}
        className="bg-white rounded-lg border p-4 hover:shadow-md transition-shadow cursor-pointer"
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4 flex-1">
            <div className="text-2xl">{getAssetIcon(asset.type)}</div>
            <div className="flex-1">
              <div className="flex items-center space-x-2">
                <h3 className="font-semibold text-gray-900">{asset.name}</h3>
                {asset.quality && (
                  <span className={`px-2 py-1 text-xs font-medium rounded-full ${getQualityColor(asset.quality)}`}>
                    {asset.quality}
                  </span>
                )}
                {asset.classification && (
                  <span className={`px-2 py-1 text-xs font-medium rounded-full ${getClassificationColor(asset.classification)}`}>
                    {asset.classification}
                  </span>
                )}
              </div>
              <p className="text-sm text-gray-600 mt-1">{asset.description}</p>
              <div className="flex items-center space-x-4 mt-2 text-xs text-gray-500">
                <span>{asset.dataSourceName}</span>
                {asset.schema && <span>{asset.schema}</span>}
                <span>{formatNumber(asset.rowCount)} rows</span>
                <span>{asset.columnCount} columns</span>
                <span>Updated {formatRelativeTime(asset.updatedAt)}</span>
              </div>
            </div>
          </div>
          <div className="flex items-center space-x-2">
            {asset.tags?.slice(0, 2).map(tag => (
              <span key={tag} className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
                {tag}
              </span>
            ))}
            {asset.tags && asset.tags.length > 2 && (
              <span className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
                +{asset.tags.length - 2}
              </span>
            )}
          </div>
        </div>
      </div>
    );
  }

  // Grid view
  return (
    <div 
      onClick={onClick}
      className="bg-white rounded-lg border p-6 hover:shadow-md transition-shadow cursor-pointer"
    >
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center space-x-3">
          <div className="text-2xl">{getAssetIcon(asset.type)}</div>
          <div>
            <h3 className="font-semibold text-gray-900">{asset.name}</h3>
            <p className="text-sm text-gray-600">{asset.dataSourceName} {asset.schema && `â€¢ ${asset.schema}`}</p>
          </div>
        </div>
        <div className="flex space-x-1">
          {asset.quality && (
            <span className={`px-2 py-1 text-xs font-medium rounded-full ${getQualityColor(asset.quality)}`}>
              {asset.quality}
            </span>
          )}
          {asset.classification && (
            <span className={`px-2 py-1 text-xs font-medium rounded-full ${getClassificationColor(asset.classification)}`}>
              {asset.classification}
            </span>
          )}
        </div>
      </div>

      <p className="text-sm text-gray-600 mb-4 line-clamp-2">{asset.description}</p>

      <div className="grid grid-cols-2 gap-4 mb-4 text-sm">
        <div>
          <div className="text-gray-500">Rows</div>
          <div className="font-medium">{formatNumber(asset.rowCount)}</div>
        </div>
        <div>
          <div className="text-gray-500">Columns</div>
          <div className="font-medium">{asset.columnCount}</div>
        </div>
      </div>

      <div className="flex items-center justify-between">
        <div className="text-xs text-gray-500">
          Updated {formatRelativeTime(asset.updatedAt)}
        </div>
        <div className="text-xs text-gray-500">
          {asset.owner?.split('@')[0]}
        </div>
      </div>

      {asset.tags && asset.tags.length > 0 && (
        <div className="mt-4 flex flex-wrap gap-2">
          {asset.tags.slice(0, 3).map(tag => (
            <span key={tag} className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
              {tag}
            </span>
          ))}
          {asset.tags.length > 3 && (
            <span className="px-2 py-1 bg-gray-100 text-gray-700 text-xs rounded">
              +{asset.tags.length - 3}
            </span>
          )}
        </div>
      )}
    </div>
  );
}

// Loading skeleton component
function AssetCardSkeleton() {
  return (
    <div className="bg-white rounded-lg border p-6">
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center space-x-3">
          <div className="w-8 h-8 bg-gray-200 rounded animate-pulse"></div>
          <div>
            <div className="h-5 w-32 bg-gray-200 rounded animate-pulse mb-2"></div>
            <div className="h-4 w-24 bg-gray-200 rounded animate-pulse"></div>
          </div>
        </div>
        <div className="flex space-x-1">
          <div className="h-6 w-16 bg-gray-200 rounded-full animate-pulse"></div>
          <div className="h-6 w-16 bg-gray-200 rounded-full animate-pulse"></div>
        </div>
      </div>

      <div className="h-4 w-full bg-gray-200 rounded animate-pulse mb-2"></div>
      <div className="h-4 w-3/4 bg-gray-200 rounded animate-pulse mb-4"></div>

      <div className="grid grid-cols-2 gap-4 mb-4">
        <div>
          <div className="h-3 w-8 bg-gray-200 rounded animate-pulse mb-1"></div>
          <div className="h-4 w-12 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div>
          <div className="h-3 w-12 bg-gray-200 rounded animate-pulse mb-1"></div>
          <div className="h-4 w-8 bg-gray-200 rounded animate-pulse"></div>
        </div>
      </div>

      <div className="flex items-center justify-between mb-4">
        <div className="h-3 w-20 bg-gray-200 rounded animate-pulse"></div>
        <div className="h-3 w-16 bg-gray-200 rounded animate-pulse"></div>
      </div>

      <div className="flex flex-wrap gap-2">
        <div className="h-6 w-12 bg-gray-200 rounded animate-pulse"></div>
        <div className="h-6 w-16 bg-gray-200 rounded animate-pulse"></div>
        <div className="h-6 w-14 bg-gray-200 rounded animate-pulse"></div>
      </div>
    </div>
  );
}

// Pagination helper
function getPageNumbers(currentPage: number, totalPages: number): (number | string)[] {
  const pages: (number | string)[] = [];
  
  if (totalPages <= 7) {
    // Show all pages if 7 or fewer
    for (let i = 1; i <= totalPages; i++) {
      pages.push(i);
    }
  } else {
    // Always show first page
    pages.push(1);
    
    if (currentPage <= 4) {
      // Show pages 2-5, then ellipsis, then last page
      for (let i = 2; i <= 5; i++) {
        pages.push(i);
      }
      pages.push('...');
      pages.push(totalPages);
    } else if (currentPage >= totalPages - 3) {
      // Show ellipsis, then last 4 pages
      pages.push('...');
      for (let i = totalPages - 4; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      // Show ellipsis, current page area, ellipsis, last page
      pages.push('...');
      for (let i = currentPage - 1; i <= currentPage + 1; i++) {
        pages.push(i);
      }
      pages.push('...');
      pages.push(totalPages);
    }
  }
  
  return pages;
}


------------------------------------------------------------
FILE: frontend\src\components\features\data-catalog\index.ts
------------------------------------------------------------
export { AssetCard } from './AssetCard'
export type { Asset } from './AssetCard'

export { AssetGrid } from './AssetGrid'

export { AssetDetails } from './AssetDetails'

export { SearchFilters } from './SearchFilters'




------------------------------------------------------------
FILE: frontend\src\components\features\data-catalog\SearchFilters.tsx
------------------------------------------------------------
// src/components/features/data-catalog/SearchFilters.tsx
import { useMemo } from 'react';

interface SearchFiltersProps {
  q: string;
  setQ: (query: string) => void;
  type: string;
  setType: (type: string) => void;
  owner: string;
  setOwner: (owner: string) => void;
  onRefresh?: () => void;
  
  // Additional filters for enhanced functionality
  quality?: string;
  setQuality?: (quality: string) => void;
  classification?: string;
  setClassification?: (classification: string) => void;
  dataSourceId?: string;
  setDataSourceId?: (dataSourceId: string) => void;
  
  // Results info
  totalResults?: number;
  isLoading?: boolean;
  hasFilters?: boolean;
  onClearFilters?: () => void;
}

const ASSET_TYPES: Array<{ value: string; label: string }> = [
  { value: '', label: 'All types' },
  { value: 'table', label: 'Table' },
  { value: 'view', label: 'View' },
  { value: 'materialized_view', label: 'Materialized View' },
  { value: 'file', label: 'File' },
  { value: 'stream', label: 'Stream' },
  { value: 'api', label: 'API' },
  { value: 'dataset', label: 'Dataset' },
  { value: 'model', label: 'Model' },
  { value: 'dashboard', label: 'Dashboard' },
  { value: 'report', label: 'Report' }
];

const QUALITY_LEVELS: Array<{ value: string; label: string }> = [
  { value: '', label: 'All quality' },
  { value: 'high', label: 'High' },
  { value: 'medium', label: 'Medium' },
  { value: 'low', label: 'Low' }
];

const CLASSIFICATIONS: Array<{ value: string; label: string }> = [
  { value: '', label: 'All classifications' },
  { value: 'public', label: 'Public' },
  { value: 'internal', label: 'Internal' },
  { value: 'confidential', label: 'Confidential' },
  { value: 'restricted', label: 'Restricted' }
];

export function SearchFilters({
  q,
  setQ,
  type,
  setType,
  owner,
  setOwner,
  onRefresh,
  quality = '',
  setQuality,
  classification = '',
  setClassification,
  dataSourceId = '',
  setDataSourceId,
  totalResults = 0,
  isLoading = false,
  hasFilters = false,
  onClearFilters
}: SearchFiltersProps) {
  
  // Determine if we have extended filters available
  const hasExtendedFilters = Boolean(setQuality || setClassification || setDataSourceId);
  
  const activeFilterCount = useMemo(() => {
    let count = 0;
    if (q.trim()) count++;
    if (type) count++;
    if (owner.trim()) count++;
    if (quality) count++;
    if (classification) count++;
    if (dataSourceId) count++;
    return count;
  }, [q, type, owner, quality, classification, dataSourceId]);

  return (
    <div className="bg-white rounded-lg border p-4 space-y-4">
      {/* Primary Filters Row */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {/* Search Input */}
        <div className="lg:col-span-2">
          <div className="relative">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              <svg className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </div>
            <input
              type="text"
              placeholder="Search by name, tag, column..."
              value={q}
              onChange={(e) => setQ(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            {q && (
              <button
                onClick={() => setQ('')}
                className="absolute inset-y-0 right-0 pr-3 flex items-center"
              >
                <svg className="h-4 w-4 text-gray-400 hover:text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}
          </div>
        </div>

        {/* Type Filter */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Type</label>
          <select
            value={type}
            onChange={(e) => setType(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            {ASSET_TYPES.map(({ value, label }) => (
              <option key={value} value={value}>{label}</option>
            ))}
          </select>
        </div>

        {/* Owner Filter */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Owner</label>
          <div className="relative">
            <input
              type="text"
              placeholder="Owner (email or name)"
              value={owner}
              onChange={(e) => setOwner(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            {owner && (
              <button
                onClick={() => setOwner('')}
                className="absolute inset-y-0 right-0 pr-3 flex items-center"
              >
                <svg className="h-4 w-4 text-gray-400 hover:text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Extended Filters Row (if available) */}
      {hasExtendedFilters && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t border-gray-200">
          {/* Quality Filter */}
          {setQuality && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Quality</label>
              <select
                value={quality}
                onChange={(e) => setQuality(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              >
                {QUALITY_LEVELS.map(({ value, label }) => (
                  <option key={value} value={value}>{label}</option>
                ))}
              </select>
            </div>
          )}

          {/* Classification Filter */}
          {setClassification && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Classification</label>
              <select
                value={classification}
                onChange={(e) => setClassification(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              >
                {CLASSIFICATIONS.map(({ value, label }) => (
                  <option key={value} value={value}>{label}</option>
                ))}
              </select>
            </div>
          )}

          {/* Data Source Filter - would need to be populated from your data sources */}
          {setDataSourceId && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Data Source</label>
              <select
                value={dataSourceId}
                onChange={(e) => setDataSourceId(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              >
                <option value="">All sources</option>
                {/* You would populate this with actual data sources */}
                <option value="1">Production PostgreSQL</option>
                <option value="2">Analytics Snowflake</option>
                <option value="3">S3 Data Lake</option>
              </select>
            </div>
          )}
        </div>
      )}

      {/* Filter Actions and Results */}
      <div className="flex items-center justify-between pt-4 border-t border-gray-200">
        <div className="flex items-center space-x-4">
          {/* Results Count */}
          <span className="text-sm text-gray-600">
            {isLoading ? (
              <span className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Loading...
              </span>
            ) : (
              <>
                {totalResults.toLocaleString()} asset{totalResults !== 1 ? 's' : ''} found
                {activeFilterCount > 0 && (
                  <span className="ml-2 px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded-full">
                    {activeFilterCount} filter{activeFilterCount !== 1 ? 's' : ''}
                  </span>
                )}
              </>
            )}
          </span>

          {/* Clear Filters */}
          {(hasFilters || activeFilterCount > 0) && onClearFilters && (
            <button
              onClick={onClearFilters}
              className="text-sm text-blue-600 hover:text-blue-800 font-medium"
            >
              Clear all filters
            </button>
          )}
        </div>

        {/* Refresh Button */}
        <div className="flex items-center space-x-2">
          {onRefresh && (
            <button
              onClick={onRefresh}
              disabled={isLoading}
              className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
            >
              <svg 
                className={`h-4 w-4 mr-1 ${isLoading ? 'animate-spin' : ''}`} 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              Refresh
            </button>
          )}
        </div>
      </div>
    </div>
  );
}


------------------------------------------------------------
FILE: frontend\src\components\features\data-quality\index.ts
------------------------------------------------------------
export { QualityOverview } from './QualityOverview'
export { QualityRules } from './QualityRules'
export { QualityTrends } from './QualityTrends'
export { ViolationsList } from './ViolationsList'

export type { QualityRule } from './QualityRules'
export type { TrendPoint } from './QualityTrends'
export type { Violation } from './ViolationsList'




------------------------------------------------------------
FILE: frontend\src\components\features\data-quality\QualityOverview.tsx
------------------------------------------------------------
// src/components/features/data-quality/QualityOverview.tsx
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { AlertTriangle, Shield, TrendingUp } from 'lucide-react'

type Totals = {
  rules: number
  activeRules: number
  violations: number
}

export type QualityOverviewProps = {
  /** Overall data quality score, 0..100 */
  score?: number
  /** Overall pass rate, 0..100 */
  passRate?: number
  /** Aggregate counts */
  totals?: Partial<Totals>
  /** ISO date string or null */
  lastUpdated?: string | null
}

/** Coerce maybe-number -> sane bounded number */
function coercePercent(v: unknown, fallback = 0): number {
  const n = typeof v === 'number' ? v : Number(v)
  if (!Number.isFinite(n)) return fallback
  return Math.min(100, Math.max(0, n))
}

/** Safe number formatter: returns e.g. "97.2%" */
function pctText(v: unknown, digits = 1, fallback = 'â€”%'): string {
  const n = typeof v === 'number' ? v : Number(v)
  if (!Number.isFinite(n)) return fallback
  return `${n.toFixed(digits)}%`
}

export function QualityOverview(props: QualityOverviewProps) {
  const score = coercePercent(props.score, 0)
  const passRate = coercePercent(props.passRate, 0)

  const activeRules = Math.max(0, Math.trunc(props.totals?.activeRules ?? 0))
  const violations = Math.max(0, Math.trunc(props.totals?.violations ?? 0))

  const updated =
    props.lastUpdated ? new Date(props.lastUpdated).toLocaleString() : 'Not available'

  return (
    <div className="grid grid-cols-1 gap-6 md:grid-cols-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-sm text-gray-600">Overall Score</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-between">
          <p className="text-3xl font-bold text-green-600">{pctText(score, 0)}</p>
          <Shield className="h-8 w-8 text-green-600" aria-hidden />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-sm text-gray-600">Pass Rate</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-between">
          <p className="text-3xl font-bold text-blue-600">{pctText(passRate, 0)}</p>
          <TrendingUp className="h-8 w-8 text-blue-600" aria-hidden />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-sm text-gray-600">Active Rules</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-between">
          <p className="text-3xl font-bold text-gray-900">{activeRules}</p>
          <Shield className="h-8 w-8 text-gray-700" aria-hidden />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-sm text-gray-600">Violations</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-between">
          <p className="text-3xl font-bold text-red-600">{violations}</p>
          <AlertTriangle className="h-8 w-8 text-red-600" aria-hidden />
        </CardContent>
      </Card>

      <div className="md:col-span-4 text-xs text-gray-500">Last updated: {updated}</div>
    </div>
  )
}

export default QualityOverview



------------------------------------------------------------
FILE: frontend\src\components\features\data-quality\QualityRules.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Input } from '@components/ui/Input'
import { Select } from '@components/ui/Select'
import { Filter, Plus } from 'lucide-react'
import * as React from 'react'

export type RuleSeverity = 'low' | 'medium' | 'high' | 'critical'
export type RuleStatus = 'active' | 'muted' | 'disabled'

export interface QualityRule {
  id: string
  name: string
  dataset: string
  severity: RuleSeverity
  status: RuleStatus
  lastRun?: string
  failures24h?: number
}

export interface QualityRulesProps {
  rules: QualityRule[]
  loading?: boolean
  onCreate?: () => void
  onToggleMute?: (id: string) => void
  onDisable?: (id: string) => void
}

export function QualityRules({ rules, loading, onCreate, onToggleMute, onDisable }: QualityRulesProps) {
  const [q, setQ] = React.useState('')
  const [sev, setSev] = React.useState('')
  const [status, setStatus] = React.useState('')

  const filtered = React.useMemo(() => {
    return rules.filter((r) => {
      const text = q.trim().toLowerCase()
      const matchText = !text || r.name.toLowerCase().includes(text) || r.dataset.toLowerCase().includes(text)
      const matchSev = !sev || r.severity === sev
      const matchStatus = !status || r.status === status
      return matchText && matchSev && matchStatus
    })
  }, [rules, q, sev, status])

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Quality Rules</CardTitle>
          <Button onClick={onCreate} leftIcon={<Plus className="h-4 w-4" />}>New Rule</Button>
        </div>
      </CardHeader>
      <CardContent>
        {/* Filters */}
        <div className="mb-4 grid grid-cols-1 gap-3 md:grid-cols-4">
          <Input value={q} onChange={(e) => setQ(e.target.value)} placeholder="Search rulesâ€¦" startIcon={<Filter className="h-4 w-4" />} />
          <Select
            label="Severity"
            value={sev}
            onChange={(e) => setSev(e.target.value)}
            options={[
              { label: 'All', value: '' },
              { label: 'Low', value: 'low' },
              { label: 'Medium', value: 'medium' },
              { label: 'High', value: 'high' },
              { label: 'Critical', value: 'critical' },
            ]}
          />
          <Select
            label="Status"
            value={status}
            onChange={(e) => setStatus(e.target.value)}
            options={[
              { label: 'All', value: '' },
              { label: 'Active', value: 'active' },
              { label: 'Muted', value: 'muted' },
              { label: 'Disabled', value: 'disabled' },
            ]}
          />
        </div>

        {/* Table */}
        {loading ? (
          <RulesSkeleton />
        ) : filtered.length === 0 ? (
          <div className="text-sm text-gray-600">No rules match your filters.</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead className="text-left text-gray-500">
                <tr>
                  <th className="py-2 pr-4">Rule</th>
                  <th className="py-2 pr-4">Dataset</th>
                  <th className="py-2 pr-4">Severity</th>
                  <th className="py-2 pr-4">Status</th>
                  <th className="py-2 pr-4">Failures (24h)</th>
                  <th className="py-2 pr-0 text-right">Actions</th>
                </tr>
              </thead>
              <tbody>
                {filtered.map((r) => (
                  <tr key={r.id} className="border-t">
                    <td className="py-2 pr-4 font-medium text-gray-900">{r.name}</td>
                    <td className="py-2 pr-4">{r.dataset}</td>
                    <td className="py-2 pr-4"><Badge tone={sevTone(r.severity)}>{r.severity}</Badge></td>
                    <td className="py-2 pr-4"><Badge tone={statusTone(r.status)}>{r.status}</Badge></td>
                    <td className="py-2 pr-4">{r.failures24h ?? 0}</td>
                    <td className="py-2 pr-0 text-right">
                      <div className="inline-flex gap-2">
                        <Button variant="outline" size="sm" onClick={() => onToggleMute?.(r.id)}>
                          {r.status === 'muted' ? 'Unmute' : 'Mute'}
                        </Button>
                        <Button variant="ghost" size="sm" onClick={() => onDisable?.(r.id)}>Disable</Button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

function sevTone(s: RuleSeverity) {
  return s === 'critical' ? 'danger' : s === 'high' ? 'warning' : s === 'medium' ? 'info' : 'neutral'
}
function statusTone(s: RuleStatus) {
  return s === 'active' ? 'success' : s === 'muted' ? 'neutral' : 'danger'
}

function RulesSkeleton() {
  return (
    <div className="space-y-2">
      {Array.from({ length: 6 }).map((_, i) => (
        <div key={i} className="h-10 w-full animate-pulse rounded bg-gray-200" />
      ))}
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-quality\QualityTrends.tsx
------------------------------------------------------------
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'

export interface TrendPoint {
  ts: string // ISO
  score: number
}

export function QualityTrends({ points = [] as TrendPoint[] }: { points?: TrendPoint[] }) {
  // Simple SVG sparkline (no external chart lib required)
  const w = 520, h = 80, pad = 6
  const ys = points.map(p => p.score)
  const min = Math.min(70, ...ys), max = Math.max(100, ...ys)
  const xStep = points.length > 1 ? (w - pad * 2) / (points.length - 1) : 0
  const path = points
    .map((p, i) => {
      const x = pad + i * xStep
      const y = pad + (1 - (p.score - min) / Math.max(1, (max - min))) * (h - pad * 2)
      return `${i === 0 ? 'M' : 'L'}${x},${y}`
    })
    .join(' ')

  return (
    <Card>
      <CardHeader><CardTitle>Quality Trends</CardTitle></CardHeader>
      <CardContent>
        {points.length === 0 ? (
          <div className="text-sm text-gray-600">No trend data available.</div>
        ) : (
          <svg width="100%" viewBox={`0 0 ${w} ${h}`} role="img" aria-label="Quality score trend">
            <path d={path} fill="none" stroke="currentColor" strokeWidth="2" />
          </svg>
        )}
      </CardContent>
    </Card>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-quality\ViolationsList.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'

export interface Violation {
  id: string
  ruleName: string
  dataset: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  count: number
  firstSeen: string // ISO
  lastSeen: string  // ISO
}

export function ViolationsList({ items = [], loading }: { items?: Violation[]; loading?: boolean }) {
  if (loading) return <ListSkeleton />
  if (!items.length) return <Card><CardContent>No violations in the selected window.</CardContent></Card>

  return (
    <Card>
      <CardHeader>
        <CardTitle>Recent Violations</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead className="text-left text-gray-500">
              <tr>
                <th className="py-2 pr-4">Rule</th>
                <th className="py-2 pr-4">Dataset</th>
                <th className="py-2 pr-4">Severity</th>
                <th className="py-2 pr-4">Count</th>
                <th className="py-2 pr-4">Last Seen</th>
              </tr>
            </thead>
            <tbody>
              {items.map((v) => (
                <tr key={v.id} className="border-t">
                  <td className="py-2 pr-4 font-medium text-gray-900">{v.ruleName}</td>
                  <td className="py-2 pr-4">{v.dataset}</td>
                  <td className="py-2 pr-4">
                    <Badge tone={v.severity === 'critical' ? 'danger' : v.severity === 'high' ? 'warning' : v.severity === 'medium' ? 'info' : 'neutral'}>
                      {v.severity}
                    </Badge>
                  </td>
                  <td className="py-2 pr-4">{v.count}</td>
                  <td className="py-2 pr-4">{fmt(v.lastSeen)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </CardContent>
    </Card>
  )
}

function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}

function ListSkeleton() {
  return (
    <div className="space-y-2">
      {Array.from({ length: 5 }).map((_, i) => (
        <div key={i} className="h-12 w-full animate-pulse rounded bg-gray-200" />
      ))}
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-sources\AddConnectionWizard.tsx
------------------------------------------------------------
// src/components/features/data-sources/AddConnectionWizard.tsx
import React, { useCallback, useEffect, useMemo, useState } from 'react';

// âœ… Use the shared app types â€“ remove any local duplicates
import type {
    CreateDataSourcePayload,
    DataSource,
    DataSourceType,
} from '@/types/dataSources';

/* =========================
   Local types for the wizard
========================= */
type ConnectorCategory = 'Databases' | 'Warehouses' | 'Storage' | 'Streaming' | 'API & Files';

type FieldType =
  | 'text'
  | 'password'
  | 'number'
  | 'textarea'
  | 'checkbox'
  | 'select'
  | 'array';

type ConnectorField = {
  key: string;
  label: string;
  type: FieldType;
  required?: boolean;
  placeholder?: string;
  help?: string;
  options?: { label: string; value: string }[];
  min?: number;
  max?: number;
  wide?: boolean;
  dependsOn?: {
    field: string;
    value?: any;
    condition?: 'equals' | 'not-equals' | 'truthy' | 'falsy';
  };
};

type ConnectionTemplate = {
  id: string;
  name: string;
  description: string;
  config: Record<string, any>;
};

type ConnectorMeta = {
  id: string;                       // UI ID (may NOT equal backend type)
  name: string;
  description: string;
  category: ConnectorCategory;
  icon?: string;
  tags?: string[];
  fields: ConnectorField[];
  defaultPort?: number;
  submitType?: DataSourceType;      // ðŸ‘ˆ what to send to backend (falls back to id if omitted)
  connectionStringPattern?: string; // only used for placeholder/example text
  templates?: ConnectionTemplate[];
  isNew?: boolean;
  isPopular?: boolean;
};

/* =========================
   Connectors
========================= */
const CATEGORIES: ConnectorCategory[] = [
  'Databases',
  'Warehouses',
  'Storage',
  'Streaming',
  'API & Files',
];

const CONNECTORS: ConnectorMeta[] = [
  // ---------- Databases ----------
  {
    id: 'postgresql',
    name: 'PostgreSQL',
    description: 'Open-source relational database',
    category: 'Databases',
    icon: 'ðŸ˜',
    tags: ['sql', 'relational', 'acid'],
    defaultPort: 5432,
    isPopular: true,
    connectionStringPattern: 'postgresql://user:password@host:5432/database',
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My PostgreSQL DB' },
      { key: 'host', label: 'Host', type: 'text', required: true, placeholder: 'localhost' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '5432', min: 1, max: 65535 },
      { key: 'database', label: 'Database', type: 'text', required: true, placeholder: 'myapp' },
      { key: 'username', label: 'Username', type: 'text', required: true, placeholder: 'postgres' },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Enable SSL', type: 'checkbox' },
      {
        key: 'sslmode',
        label: 'SSL Mode',
        type: 'select',
        options: [
          { label: 'Require', value: 'require' },
          { label: 'Verify CA', value: 'verify-ca' },
          { label: 'Verify Full', value: 'verify-full' },
        ],
        dependsOn: { field: 'ssl', value: true, condition: 'equals' },
      },
    ],
    templates: [
      {
        id: 'local',
        name: 'Local Development',
        description: 'Standard local PostgreSQL setup',
        config: { host: 'localhost', port: 5432, username: 'postgres', ssl: false },
      },
      {
        id: 'production',
        name: 'Production',
        description: 'Secure production configuration',
        config: { port: 5432, ssl: true },
      },
    ],
  },
  {
    id: 'mysql',
    name: 'MySQL',
    description: 'Popular open-source database',
    category: 'Databases',
    icon: 'ðŸ¬',
    tags: ['sql', 'relational'],
    defaultPort: 3306,
    isPopular: true,
    connectionStringPattern: 'mysql://user:password@host:3306/database',
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My MySQL DB' },
      { key: 'host', label: 'Host', type: 'text', required: true, placeholder: 'localhost' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '3306', min: 1, max: 65535 },
      { key: 'database', label: 'Database', type: 'text', required: true, placeholder: 'myapp' },
      { key: 'username', label: 'Username', type: 'text', required: true, placeholder: 'root' },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Enable SSL', type: 'checkbox' },
    ],
  },
  {
    id: 'mssql',
    submitType: 'mssql', // ðŸ‘ˆ backend type
    name: 'SQL Server',
    description: 'Microsoft SQL Server',
    category: 'Databases',
    icon: 'ðŸ¢',
    tags: ['microsoft', 'sql', 'enterprise'],
    defaultPort: 1433,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My SQL Server' },
      { key: 'host', label: 'Server', type: 'text', required: true, placeholder: 'localhost' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '1433', min: 1, max: 65535 },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'encrypt', label: 'Encrypt Connection', type: 'checkbox' },
      {
        key: 'trustServerCertificate',
        label: 'Trust Server Certificate',
        type: 'checkbox',
        dependsOn: { field: 'encrypt', value: true, condition: 'equals' },
        help: 'Use for self-signed certs (dev)',
      },
    ],
  },
  {
    id: 'azure-sql',
    submitType: 'mssql', // ðŸ‘ˆ submit to backend as MSSQL
    name: 'Azure SQL Database',
    description: 'Managed SQL Server on Azure',
    category: 'Databases',
    icon: 'ðŸŸ¦',
    tags: ['azure', 'managed', 'microsoft', 'cloud'],
    defaultPort: 1433,
    isPopular: true,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My Azure SQL' },
      { key: 'host', label: 'Server Name', type: 'text', required: true, placeholder: 'myserver.database.windows.net' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '1433', min: 1, max: 65535 },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true, placeholder: 'user@myserver' },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'encrypt', label: 'Encrypt (Required)', type: 'checkbox' },
      {
        key: 'trustServerCertificate',
        label: 'Trust Server Certificate',
        type: 'checkbox',
        dependsOn: { field: 'encrypt', value: true, condition: 'equals' },
      },
    ],
  },
  {
    id: 'mongodb',
    name: 'MongoDB',
    description: 'Document-oriented NoSQL database',
    category: 'Databases',
    icon: 'ðŸƒ',
    tags: ['nosql', 'document', 'json'],
    defaultPort: 27017,
    isPopular: true,
    connectionStringPattern: 'mongodb://user:password@host:27017/database',
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My MongoDB' },
      { key: 'host', label: 'Host', type: 'text', required: true, placeholder: 'localhost' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '27017', min: 1, max: 65535 },
      { key: 'database', label: 'Database', type: 'text', required: true, placeholder: 'myapp' },
      { key: 'username', label: 'Username', type: 'text', placeholder: 'Optional for local' },
      { key: 'password', label: 'Password', type: 'password' },
      { key: 'ssl', label: 'Enable SSL', type: 'checkbox' },
    ],
  },
  {
    id: 'redis',
    name: 'Redis',
    description: 'In-memory data store',
    category: 'Databases',
    icon: 'ðŸ“¦',
    tags: ['cache', 'memory', 'key-value'],
    defaultPort: 6379,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My Redis' },
      { key: 'host', label: 'Host', type: 'text', required: true, placeholder: 'localhost' },
      { key: 'port', label: 'Port', type: 'number', required: true, placeholder: '6379', min: 1, max: 65535 },
      { key: 'password', label: 'Password', type: 'password' },
      { key: 'database', label: 'Database Number', type: 'number', placeholder: '0', min: 0, max: 15 },
      { key: 'ssl', label: 'Use TLS', type: 'checkbox' },
      { key: 'keyPrefix', label: 'Key Prefix', type: 'text', placeholder: 'myapp:' },
    ],
  },

  // ---------- Warehouses ----------
  {
    id: 'snowflake',
    submitType: 'snowflake',
    name: 'Snowflake',
    description: 'Cloud data warehouse platform',
    category: 'Warehouses',
    icon: 'â„ï¸',
    tags: ['cloud', 'warehouse', 'analytics'],
    isPopular: true,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My Snowflake' },
      { key: 'account', label: 'Account', type: 'text', required: true, placeholder: 'xyz12345.us-east-1' },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'schema', label: 'Schema', type: 'text', placeholder: 'PUBLIC' },
      { key: 'warehouse', label: 'Warehouse', type: 'text', required: true },
      { key: 'role', label: 'Role', type: 'text', placeholder: 'Optional' },
    ],
  },
  {
    id: 'bigquery',
    submitType: 'bigquery',
    name: 'Google BigQuery',
    description: 'Google Cloud data warehouse',
    category: 'Warehouses',
    icon: 'ðŸ“Š',
    tags: ['google', 'cloud', 'analytics'],
    isNew: true,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My BigQuery' },
      { key: 'projectId', label: 'Project ID', type: 'text', required: true, placeholder: 'my-gcp-project' },
      { key: 'serviceAccount', label: 'Service Account JSON', type: 'textarea', required: true, placeholder: 'Paste JSON key here...', wide: true },
      {
        key: 'location',
        label: 'Location',
        type: 'select',
        options: [
          { label: 'US (Multi-region)', value: 'US' },
          { label: 'EU (Multi-region)', value: 'EU' },
          { label: 'asia', value: 'asia' },
        ],
      },
    ],
  },

  // ---------- Storage ----------
  {
    id: 's3',
    submitType: 's3',
    name: 'Amazon S3',
    description: 'AWS object storage service',
    category: 'Storage',
    icon: 'ðŸ“¦',
    tags: ['aws', 'storage', 'object'],
    isPopular: true,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My S3 Bucket' },
      { key: 'bucket', label: 'Bucket Name', type: 'text', required: true, placeholder: 'my-data-bucket' },
      {
        key: 'region',
        label: 'Region',
        type: 'select',
        required: true,
        options: [
          { label: 'US East (N. Virginia)', value: 'us-east-1' },
          { label: 'US West (Oregon)', value: 'us-west-2' },
          { label: 'EU (Ireland)', value: 'eu-west-1' },
          { label: 'AP (Tokyo)', value: 'ap-northeast-1' },
        ],
      },
      { key: 'accessKeyId', label: 'Access Key ID', type: 'text', required: true },
      { key: 'secretAccessKey', label: 'Secret Access Key', type: 'password', required: true },
      { key: 'prefix', label: 'Path Prefix', type: 'text', placeholder: 'data/' },
    ],
  },

  // ---------- Streaming ----------
  {
    id: 'kafka',
    submitType: 'kafka',
    name: 'Apache Kafka',
    description: 'Distributed streaming platform',
    category: 'Streaming',
    icon: 'ðŸŒŠ',
    tags: ['streaming', 'real-time', 'events'],
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My Kafka Cluster' },
      { key: 'brokers', label: 'Bootstrap Servers', type: 'array', required: true, placeholder: 'localhost:9092,localhost:9093' },
      { key: 'topics', label: 'Topics', type: 'array', placeholder: 'topic1,topic2' },
      { key: 'groupId', label: 'Consumer Group ID', type: 'text', placeholder: 'my-consumer-group' },
      {
        key: 'security',
        label: 'Security Protocol',
        type: 'select',
        options: [
          { label: 'PLAINTEXT', value: 'PLAINTEXT' },
          { label: 'SASL_SSL', value: 'SASL_SSL' },
          { label: 'SSL', value: 'SSL' },
        ],
      },
      { key: 'username', label: 'SASL Username', type: 'text', dependsOn: { field: 'security', value: 'SASL_SSL', condition: 'equals' } },
      { key: 'password', label: 'SASL Password', type: 'password', dependsOn: { field: 'security', value: 'SASL_SSL', condition: 'equals' } },
    ],
  },

  // ---------- API & Files ----------
  {
    id: 'api',
    submitType: 'api',
    name: 'REST API',
    description: 'Connect to any REST API endpoint',
    category: 'API & Files',
    icon: 'ðŸ”Œ',
    tags: ['api', 'rest', 'http'],
    isNew: true,
    fields: [
      { key: 'name', label: 'Connection Name', type: 'text', required: true, placeholder: 'My API' },
      { key: 'baseUrl', label: 'Base URL', type: 'text', required: true, placeholder: 'https://api.example.com' },
      {
        key: 'authType',
        label: 'Authentication',
        type: 'select',
        options: [
          { label: 'None', value: 'none' },
          { label: 'API Key', value: 'apikey' },
          { label: 'Bearer Token', value: 'bearer' },
          { label: 'Basic Auth', value: 'basic' },
        ],
      },
      { key: 'apiKey', label: 'API Key', type: 'password', dependsOn: { field: 'authType', value: 'apikey', condition: 'equals' } },
      { key: 'token', label: 'Bearer Token', type: 'password', dependsOn: { field: 'authType', value: 'bearer', condition: 'equals' } },
      { key: 'username', label: 'Username', type: 'text', dependsOn: { field: 'authType', value: 'basic', condition: 'equals' } },
      { key: 'password', label: 'Password', type: 'password', dependsOn: { field: 'authType', value: 'basic', condition: 'equals' } },
    ],
  },
];

/* =========================
   Helpers
========================= */
function defaultConfigFor(meta: ConnectorMeta): Record<string, any> {
  const base: Record<string, any> = {};
  if (meta.defaultPort) base.port = meta.defaultPort;

  // secure defaults
  if (meta.id === 'azure-sql') base.encrypt = true;      // â¬…ï¸ Azure SQL must encrypt
  if (meta.id === 'snowflake') base.ssl = true;          // Snowflake still uses ssl flag in many libs

  return base;
}

function getPopularConnectors(): ConnectorMeta[] {
  return CONNECTORS.filter((c) => c.isPopular);
}

function getNewConnectors(): ConnectorMeta[] {
  return CONNECTORS.filter((c) => c.isNew);
}

function parseConnectionString(_connectorId: string, url: string): Record<string, any> {
  const parsed = new URL(url);
  const cfg: Record<string, any> = {
    host: parsed.hostname || undefined,
    port: parsed.port ? parseInt(parsed.port, 10) : undefined,
    username: parsed.username || undefined,
    password: parsed.password || undefined,
    database: parsed.pathname ? parsed.pathname.replace(/^\//, '') : undefined,
  };
  Object.keys(cfg).forEach((k) => cfg[k] === undefined && delete cfg[k]);
  return cfg;
}

type MigrationPath = {
  description?: string;
  fieldMapping: Record<string, string>;
  transformations?: Record<string, (v: any) => any>;
};

function getMigrationPath(fromType: string, toType: string): MigrationPath | undefined {
  const migrations: Record<string, MigrationPath> = {
    'mysql-to-postgresql': {
      description: 'Migrate from MySQL to PostgreSQL',
      fieldMapping: { host: 'host', port: 'port', database: 'database', username: 'username', password: 'password' },
      transformations: { port: (v: number) => (v === 3306 ? 5432 : v) },
    },
    'postgresql-to-mysql': {
      description: 'Migrate from PostgreSQL to MySQL',
      fieldMapping: { host: 'host', port: 'port', database: 'database', username: 'username', password: 'password' },
      transformations: { port: (v: number) => (v === 5432 ? 3306 : v) },
    },
  };
  return migrations[`${fromType}-to-${toType}`];
}

function shouldShowField(field: ConnectorField, config: Record<string, any>): boolean {
  if (!field.dependsOn) return true;
  const { field: dep, value, condition = 'equals' } = field.dependsOn;
  const dv = config[dep];

  switch (condition) {
    case 'equals':
      return dv === value;
    case 'not-equals':
      return dv !== value;
    case 'truthy':
      return !!dv;
    case 'falsy':
      return !dv;
    default:
      return true;
  }
}

/* =========================
   Component props
========================= */
interface AddConnectionWizardProps {
  open: boolean;
  onClose: () => void;

  // âœ… matches your hook: (draft) => Promise<DataSource>
  onCreate: (draft: CreateDataSourcePayload) => Promise<DataSource>;

  onTestAfterCreate?: (id: string) => Promise<{ success: boolean; message?: string }>;
  existingConnections?: DataSource[];
  testImmediately?: boolean;
  autoDeleteOnFail?: boolean;
}

/* =========================
   Wizard
========================= */
const STEPS = ['Choose Connector', 'Configure', 'Complete'] as const;
type Step = typeof STEPS[number];

export default function AddConnectionWizard({
  open,
  onClose,
  onCreate,
  onTestAfterCreate,
  existingConnections = [],
  testImmediately = true,
  autoDeleteOnFail = true,
}: AddConnectionWizardProps) {
  const [currentStep, setCurrentStep] = useState<Step>('Choose Connector');
  const [selectedConnector, setSelectedConnector] = useState<ConnectorMeta | null>(null);
  const [config, setConfig] = useState<Record<string, any>>({});
  const [connectionString, setConnectionString] = useState('');
  const [useConnectionString, setUseConnectionString] = useState(false);
  const [selectedTemplate, setSelectedTemplate] = useState<string>('');
  const [search, setSearch] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  const [creating, setCreating] = useState(false);
  const [testing, setTesting] = useState(false);
  const [result, setResult] = useState<{ success: boolean; message: string; dataSource?: DataSource } | null>(null);

  const popularConnectors = getPopularConnectors();
  const newConnectors = getNewConnectors();

  // Reset state on open/close
  useEffect(() => {
    if (open) {
      setCurrentStep('Choose Connector');
      setSelectedConnector(null);
      setConfig({});
      setConnectionString('');
      setUseConnectionString(false);
      setSelectedTemplate('');
      setSearch('');
      setSelectedCategory('');
      setResult(null);
    }
  }, [open]);

  // Default config when connector selected
  useEffect(() => {
    if (selectedConnector) {
      setConfig(defaultConfigFor(selectedConnector));
    }
  }, [selectedConnector]);

  // Filtering
  const filteredConnectors = useMemo(() => {
    let filtered = CONNECTORS;

    if (selectedCategory) {
      filtered = filtered.filter((c) => c.category === selectedCategory);
    }

    if (search) {
      const q = search.toLowerCase();
      filtered = filtered.filter(
        (c) =>
          c.name.toLowerCase().includes(q) ||
          c.description.toLowerCase().includes(q) ||
          c.tags?.some((t) => t.toLowerCase().includes(q))
      );
    }

    return filtered;
  }, [search, selectedCategory]);

  // Parse connection string
  const handleConnectionStringParse = useCallback(() => {
    if (!selectedConnector || !connectionString) return;
    try {
      const parsed = parseConnectionString(selectedConnector.id, connectionString);
      setConfig((prev) => ({ ...prev, ...parsed }));
    } catch (e) {
      console.error('Invalid connection string:', e);
    }
  }, [selectedConnector, connectionString]);

  // Select connector
  const handleConnectorSelect = useCallback((connector: ConnectorMeta) => {
    setSelectedConnector(connector);
    setCurrentStep('Configure');
  }, []);

  // Field change
  const handleFieldChange = useCallback((key: string, value: any, fieldType?: FieldType) => {
    setConfig((prev) => {
      const next = { ...prev };
      if (fieldType === 'array') {
        if (typeof value === 'string') {
          next[key] = value.split(',').map((v) => v.trim()).filter(Boolean);
        } else {
          next[key] = Array.isArray(value) ? value : [];
        }
      } else {
        next[key] = value;
      }
      return next;
    });
  }, []);

  // Template select
  const handleTemplateSelect = useCallback((templateId: string) => {
    if (!selectedConnector) return;
    const t = selectedConnector.templates?.find((x) => x.id === templateId);
    if (!t) return;
    setConfig((prev) => ({ ...prev, ...t.config }));
    setSelectedTemplate(templateId);
  }, [selectedConnector]);

  // Create
  const handleCreate = useCallback(async () => {
    if (!selectedConnector || !onCreate) return;

    setCreating(true);
    try {
      // ðŸ” Normalize config to what backend expects
      const submitType = (selectedConnector.submitType || (selectedConnector.id as DataSourceType));
      let configToSend: Record<string, any> = { ...config };

      if (submitType === 'mssql') {
        // map `ssl` â†’ `encrypt` if user/template still set it
        if ('ssl' in configToSend) {
          configToSend.encrypt = Boolean(configToSend.ssl);
          delete configToSend.ssl;
        }
        // sensible defaults
        if (typeof configToSend.encrypt !== 'boolean') configToSend.encrypt = true;
        if (typeof configToSend.trustServerCertificate !== 'boolean') configToSend.trustServerCertificate = false;
        if (!configToSend.port) configToSend.port = 1433;
      }

      const payload: CreateDataSourcePayload = {
        name: (config.name as string) || `${selectedConnector.name} Connection`,
        type: submitType,
        description: config.description || undefined,
        connectionConfig: configToSend,
        tags: selectedConnector.tags || [],
      };

      const created = await onCreate(payload);

      let testResult: { success: boolean; message?: string } | null = null;
      if (testImmediately && onTestAfterCreate && created.id) {
        setTesting(true);
        try {
          testResult = await onTestAfterCreate(created.id);
          if (!testResult?.success && autoDeleteOnFail) {
            console.warn('Auto-delete on failed test is not implemented in the wizard.');
          }
        } catch (err) {
          testResult = { success: false, message: 'Test failed with error' };
        } finally {
          setTesting(false);
        }
      }

      setResult({
        success: true,
        message: testResult
          ? (testResult.success
              ? 'Connection created and tested successfully!'
              : `Connection created but test failed: ${testResult.message || 'Unknown error'}`)
          : 'Connection created successfully!',
        dataSource: created,
      });
      setCurrentStep('Complete');
    } catch (error: any) {
      setResult({ success: false, message: error?.message || 'Failed to create connection' });
      setCurrentStep('Complete');
    } finally {
      setCreating(false);
    }
  }, [selectedConnector, config, onCreate, onTestAfterCreate, testImmediately, autoDeleteOnFail]);

  // Navigation
  const handleNext = useCallback(() => {
    if (currentStep === 'Choose Connector' && selectedConnector) {
      setCurrentStep('Configure');
    } else if (currentStep === 'Configure') {
      handleCreate();
    }
  }, [currentStep, selectedConnector, handleCreate]);

  const handleBack = useCallback(() => {
    if (currentStep === 'Configure') {
      setCurrentStep('Choose Connector');
    } else if (currentStep === 'Complete') {
      setCurrentStep('Configure');
    }
  }, [currentStep]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200 flex-shrink-0">
          <div>
            <h2 className="text-xl font-semibold text-gray-900">Add Data Source</h2>
            <div className="flex items-center mt-2 space-x-2">
              {STEPS.map((step, index) => (
                <React.Fragment key={step}>
                  <div
                    className={`flex items-center justify-center w-8 h-8 rounded-full text-sm font-medium ${
                      currentStep === step
                        ? 'bg-blue-600 text-white'
                        : STEPS.indexOf(currentStep) > index
                        ? 'bg-green-500 text-white'
                        : 'bg-gray-200 text-gray-600'
                    }`}
                  >
                    {STEPS.indexOf(currentStep) > index ? 'âœ“' : index + 1}
                  </div>
                  {index < STEPS.length - 1 && (
                    <div
                      className={`w-8 h-0.5 ${
                        STEPS.indexOf(currentStep) > index ? 'bg-green-500' : 'bg-gray-200'
                      }`}
                    />
                  )}
                </React.Fragment>
              ))}
            </div>
          </div>
          <button onClick={onClose} className="p-2 hover:bg-gray-100 rounded-lg" aria-label="Close">
            âœ•
          </button>
        </div>

        {/* Body */}
        <div className="flex-1 overflow-y-auto p-6">
          {/* Step 1: Choose */}
          {currentStep === 'Choose Connector' && (
            <div className="space-y-6">
              <div className="flex flex-col sm:flex-row gap-4">
                <div className="flex-1">
                  <input
                    type="text"
                    placeholder="Search connectors..."
                    value={search}
                    onChange={(e) => setSearch(e.target.value)}
                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
                <select
                  value={selectedCategory}
                  onChange={(e) => setSelectedCategory(e.target.value)}
                  className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                  <option value="">All Categories</option>
                  {CATEGORIES.map((c) => (
                    <option key={c} value={c}>
                      {c}
                    </option>
                  ))}
                </select>
              </div>

              {/* Popular */}
              {!search && !selectedCategory && popularConnectors.length > 0 && (
                <div className="space-y-4">
                  <h3 className="text-lg font-medium text-gray-900">Popular</h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {popularConnectors.map((connector) => (
                      <ConnectorCard
                        key={connector.id}
                        connector={connector}
                        onClick={() => handleConnectorSelect(connector)}
                      />
                    ))}
                  </div>
                </div>
              )}

              {/* New */}
              {!search && !selectedCategory && newConnectors.length > 0 && (
                <div className="space-y-4">
                  <h3 className="text-lg font-medium text-gray-900">New</h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {newConnectors.map((connector) => (
                      <ConnectorCard
                        key={connector.id}
                        connector={connector}
                        badge="New"
                        onClick={() => handleConnectorSelect(connector)}
                      />
                    ))}
                  </div>
                </div>
              )}

              {/* All (filtered) */}
              <div className="space-y-6">
                {CATEGORIES.map((category) => {
                  const group = filteredConnectors.filter((c) => c.category === category);
                  if (group.length === 0) return null;
                  return (
                    <div key={category} className="space-y-4">
                      <h3 className="text-lg font-medium text-gray-900">{category}</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        {group.map((connector) => (
                          <ConnectorCard
                            key={connector.id}
                            connector={connector}
                            onClick={() => handleConnectorSelect(connector)}
                          />
                        ))}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Step 2: Configure */}
          {currentStep === 'Configure' && selectedConnector && (
            <div className="space-y-6">
              <div className="bg-blue-50 p-4 rounded-lg">
                <div className="flex items-center gap-3">
                  <div className="w-10 h-10 bg-white rounded-lg flex items-center justify-center text-2xl">
                    {selectedConnector.icon || 'ðŸ”—'}
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-900">{selectedConnector.name}</h3>
                    <p className="text-sm text-gray-600">{selectedConnector.description}</p>
                  </div>
                </div>
              </div>

              {/* Migration helper */}
              {existingConnections.length > 0 && (
                <MigrationHelper
                  selectedConnector={selectedConnector}
                  existingConnections={existingConnections}
                  onMigrate={(migratedConfig) => setConfig((prev) => ({ ...prev, ...migratedConfig }))}
                />
              )}

              {/* Templates */}
              {selectedConnector.templates && selectedConnector.templates.length > 0 && (
                <div className="space-y-3">
                  <h4 className="font-medium text-gray-900">Quick Setup Templates</h4>
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    {selectedConnector.templates.map((t) => (
                      <button
                        key={t.id}
                        onClick={() => handleTemplateSelect(t.id)}
                        className={`p-3 text-left border rounded-lg hover:bg-gray-50 ${
                          selectedTemplate === t.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
                        }`}
                      >
                        <div className="font-medium text-sm">{t.name}</div>
                        <div className="text-xs text-gray-600 mt-1">{t.description}</div>
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Connection string helper (placeholder only) */}
              {selectedConnector.connectionStringPattern && (
                <div className="space-y-3">
                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      id="useConnectionString"
                      checked={useConnectionString}
                      onChange={(e) => setUseConnectionString(e.target.checked)}
                      className="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                    />
                    <label htmlFor="useConnectionString" className="text-sm font-medium text-gray-900">
                      Use connection string
                    </label>
                  </div>
                  {useConnectionString && (
                    <div className="space-y-2">
                      <input
                        type="text"
                        placeholder={selectedConnector.connectionStringPattern}
                        value={connectionString}
                        onChange={(e) => setConnectionString(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent font-mono text-sm"
                      />
                      <button
                        onClick={handleConnectionStringParse}
                        className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                      >
                        Parse Connection String
                      </button>
                    </div>
                  )}
                </div>
              )}

              {/* Fields */}
              <div className="space-y-4">
                <h4 className="font-medium text-gray-900">Connection Details</h4>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  {selectedConnector.fields.map((field) => (
                    <ConfigField
                      key={field.key}
                      field={field}
                      value={config[field.key] ?? (field.type === 'checkbox' ? false : '')}
                      onChange={(v) => handleFieldChange(field.key, v, field.type)}
                      config={config}
                    />
                  ))}
                </div>
              </div>
            </div>
          )}

          {/* Step 3: Complete */}
          {currentStep === 'Complete' && result && (
            <div className="text-center space-y-6">
              <div
                className={`w-16 h-16 mx-auto rounded-full flex items-center justify-center ${
                  result.success ? 'bg-green-100 text-green-600' : 'bg-red-100 text-red-600'
                }`}
              >
                {result.success ? 'âœ“' : 'âœ—'}
              </div>
              <div>
                <h3
                  className={`text-lg font-medium ${
                    result.success ? 'text-green-900' : 'text-red-900'
                  }`}
                >
                  {result.success ? 'Connection Created!' : 'Creation Failed'}
                </h3>
                <p className="text-gray-600 mt-2">{result.message}</p>
              </div>

              {result.success && result.dataSource && (
                <div className="bg-gray-50 p-4 rounded-lg text-left">
                  <h4 className="font-medium text-gray-900 mb-2">Connection Details</h4>
                  <div className="space-y-1 text-sm text-gray-600">
                    <div>Name: {result.dataSource.name}</div>
                    <div>Type: {result.dataSource.type}</div>
                    <div>Status: {result.dataSource.status}</div>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="border-t border-gray-200 p-6 flex justify-between flex-shrink-0">
          <button
            onClick={currentStep === 'Complete' ? onClose : handleBack}
            disabled={currentStep === 'Choose Connector'}
            className="px-4 py-2 text-gray-600 hover:text-gray-800 disabled:text-gray-400 disabled:cursor-not-allowed"
          >
            {currentStep === 'Complete' ? 'Close' : 'Back'}
          </button>

          {currentStep !== 'Complete' && (
            <div className="flex gap-3">
              <button onClick={onClose} className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50">
                Cancel
              </button>
              <button
                onClick={handleNext}
                disabled={
                  (currentStep === 'Choose Connector' && !selectedConnector) ||
                  (currentStep === 'Configure' && creating) ||
                  testing
                }
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {creating || testing
                  ? 'Creating...'
                  : currentStep === 'Choose Connector'
                  ? 'Next'
                  : 'Create Connection'}
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

/* =========================
   Small components
========================= */
function ConnectorCard({
  connector,
  onClick,
  badge,
}: {
  connector: ConnectorMeta;
  onClick: () => void;
  badge?: string;
}) {
  return (
    <button
      onClick={onClick}
      className="p-4 border border-gray-200 rounded-lg hover:border-blue-300 hover:bg-blue-50 text-left transition-colors relative"
    >
      {badge && (
        <span className="absolute top-2 right-2 px-2 py-1 text-xs font-medium bg-blue-600 text-white rounded">
          {badge}
        </span>
      )}
      <div className="flex items-center gap-3">
        <div className="w-8 h-8 flex items-center justify-center text-xl">{connector.icon || 'ðŸ”—'}</div>
        <div className="flex-1 min-w-0">
          <div className="font-medium text-gray-900 truncate">{connector.name}</div>
          <div className="text-sm text-gray-600 truncate">{connector.description}</div>
        </div>
      </div>
      {connector.tags && connector.tags.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {connector.tags.slice(0, 3).map((tag) => (
            <span key={tag} className="px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded">
              {tag}
            </span>
          ))}
          {connector.tags.length > 3 && (
            <span className="px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded">
              +{connector.tags.length - 3}
            </span>
          )}
        </div>
      )}
    </button>
  );
}

function ConfigField({
  field,
  value,
  onChange,
  config,
}: {
  field: ConnectorField;
  value: any;
  onChange: (value: any) => void;
  config: Record<string, any>;
}) {
  const show = useMemo(() => shouldShowField(field, config), [field, config]);
  if (!show) return null;

  const base = 'w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';

  return (
    <div className={field.type === 'textarea' || field.wide ? 'sm:col-span-2' : ''}>
      <label className="block text-sm font-medium text-gray-700 mb-1">
        {field.label}
        {field.required && <span className="text-red-500 ml-1">*</span>}
      </label>

      {field.type === 'password' ? (
        <input
          type="password"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          required={field.required}
          className={base}
        />
      ) : field.type === 'number' ? (
        <input
          type="number"
          value={value}
          onChange={(e) => onChange(e.target.value === '' ? '' : parseInt(e.target.value, 10))}
          placeholder={field.placeholder}
          required={field.required}
          min={field.min}
          max={field.max}
          className={base}
        />
      ) : field.type === 'select' ? (
        <select
          value={value ?? ''}
          onChange={(e) => onChange(e.target.value)}
          required={field.required}
          className={base}
        >
          <option value="">Select {field.label}</option>
          {field.options?.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      ) : field.type === 'textarea' ? (
        <textarea
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          required={field.required}
          rows={3}
          className={base}
        />
      ) : field.type === 'checkbox' ? (
        <div className="flex items-center">
          <input
            type="checkbox"
            checked={!!value}
            onChange={(e) => onChange(e.target.checked)}
            className="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
          />
          {field.placeholder && <span className="ml-2 text-sm text-gray-600">{field.placeholder}</span>}
        </div>
      ) : field.type === 'array' ? (
        <input
          type="text"
          value={Array.isArray(value) ? value.join(', ') : value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          required={field.required}
          className={base}
        />
      ) : (
        <input
          type="text"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          required={field.required}
          className={base}
        />
      )}

      {field.help && <p className="mt-1 text-sm text-gray-500">{field.help}</p>}
    </div>
  );
}

function MigrationHelper({
  selectedConnector,
  existingConnections,
  onMigrate,
}: {
  selectedConnector: ConnectorMeta;
  existingConnections: DataSource[];
  onMigrate: (config: Record<string, any>) => void;
}) {
  const candidates = useMemo(() => {
    return existingConnections
      .map((conn) => {
        const path = getMigrationPath(conn.type, selectedConnector.submitType || selectedConnector.id);
        return path ? { conn, path } : null;
      })
      .filter((x): x is { conn: DataSource; path: MigrationPath } => !!x);
  }, [existingConnections, selectedConnector]);

  if (candidates.length === 0) return null;

  const handleMigration = (conn: DataSource, path: MigrationPath) => {
    const fromCfg = (conn.connectionConfig || {}) as Record<string, any>;
    const mapped = Object.entries(path.fieldMapping).reduce<Record<string, any>>((acc, [fromKey, toKey]) => {
      const val = fromCfg[fromKey];
      if (val !== undefined) {
        const xform = path.transformations?.[toKey];
        acc[toKey] = xform ? xform(val) : val;
      }
      return acc;
    }, {});
    onMigrate(mapped);
  };

  return (
    <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
      <h4 className="font-medium text-amber-900 mb-2">Migration Assistant</h4>
      <p className="text-sm text-amber-800 mb-3">Copy configuration from existing connections:</p>
      <div className="space-y-2">
        {candidates.map(({ conn, path }) => (
          <button
            key={conn.id}
            onClick={() => handleMigration(conn, path)}
            className="w-full p-2 text-left bg-white border border-amber-200 rounded hover:bg-amber-50"
          >
            <div className="font-medium text-sm">{conn.name}</div>
            <div className="text-xs text-amber-700">
              {path.description || `Migrate from ${conn.type} to ${selectedConnector.name}`}
            </div>
          </button>
        ))}
      </div>
    </div>
  );
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-sources\connectors.ts
------------------------------------------------------------
import type { ConnectionConfig, DataSourceType } from '@/types/dataSources';

/* =========================
   Types
========================= */
export type ConnectorCategory =
  | 'Databases'
  | 'Warehouses'
  | 'Storage'
  | 'Streaming'
  | 'API & Files';

export type FieldType =
  | 'text'
  | 'password'
  | 'number'
  | 'textarea'
  | 'checkbox'
  | 'select'
  | 'connectionString';

// connector ids, including aliases that submit as another backend type
export type ConnectorId =
  | DataSourceType
  | 'azure-sql'
  | 'synapse-dedicated'
  | 'synapse-serverless'
  | 'aws-rds-postgres'
  | 'aws-rds-mysql'
  | 'planetscale'
  | 'neon'
  | 'supabase';

// NOTE: key/dependsOn.field are strings to avoid TS friction with custom keys like "brokers"
export type FieldDef = {
  key: string;
  label: string;
  type: FieldType;
  placeholder?: string;
  required?: boolean;
  help?: string;
  options?: { value: string; label: string }[];
  dependsOn?: {
    field: string;
    value?: any;
    condition?: 'equals' | 'not-equals' | 'truthy' | 'falsy';
  };
  validation?: {
    pattern?: RegExp;
    min?: number;
    max?: number;
    custom?: (value: any, config: ConnectionConfig) => string | null;
  };
};

export type ConnectionTemplate = {
  name: string;
  description: string;
  config: Partial<ConnectionConfig>;
  icon?: string;
};

export type ConnectorMeta = {
  id: ConnectorId;
  submitType: DataSourceType; // what your backend expects in "type"
  label: string;
  category: ConnectorCategory;
  icon: string;
  description?: string;
  defaultPort?: number;
  fields: FieldDef[];
  tips?: string[];
  supportsConnectionString?: boolean;
  connectionStringPlaceholder?: string;
  parseConnectionString?: (url: string) => Partial<ConnectionConfig>;
  templates?: ConnectionTemplate[];
  tags?: string[];
  popularity?: number;
  isNew?: boolean;
  isBeta?: boolean;
  documentationUrl?: string;
};

/* =========================
   Validation helpers
========================= */
export const VALIDATION_PATTERNS = {
  url: /^https?:\/\/.+/,
  hostname:
    /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  snowflakeAccount: /^[a-zA-Z0-9_-]+\.snowflakecomputing\.com$/,
  azureServer: /^[a-zA-Z0-9-]+\.database\.windows\.net$/,
  gcpProject: /^[a-z][a-z0-9-]{4,28}[a-z0-9]$/,
};

/* =========================
   Connection string parsers
========================= */
export const CONNECTION_STRING_PARSERS = {
  postgresql: (url: string): Partial<ConnectionConfig> => {
    try {
      const parsed = new URL(url);
      return {
        host: parsed.hostname,
        port: parsed.port ? parseInt(parsed.port, 10) : 5432,
        database: parsed.pathname.replace(/^\//, ''),
        username: decodeURIComponent(parsed.username),
        password: decodeURIComponent(parsed.password),
        ssl:
          parsed.searchParams.get('sslmode') === 'require' ||
          parsed.searchParams.get('ssl') === 'true',
      };
    } catch {
      return {};
    }
  },

  mysql: (url: string): Partial<ConnectionConfig> => {
    try {
      const parsed = new URL(url);
      return {
        host: parsed.hostname,
        port: parsed.port ? parseInt(parsed.port, 10) : 3306,
        database: parsed.pathname.replace(/^\//, ''),
        username: decodeURIComponent(parsed.username),
        password: decodeURIComponent(parsed.password),
        ssl: parsed.searchParams.get('ssl') === 'true',
      };
    } catch {
      return {};
    }
  },

  mongodb: (url: string): Partial<ConnectionConfig> => {
    return { connectionString: url };
  },
};

/* =========================
   Templates
========================= */
const ENVIRONMENT_TEMPLATES: Record<string, ConnectionTemplate[]> = {
  postgresql: [
    {
      name: 'Local Development',
      description: 'Default PostgreSQL on localhost',
      icon: 'ðŸ’»',
      config: { host: 'localhost', port: 5432, ssl: false },
    },
    {
      name: 'Production',
      description: 'Secure production setup',
      icon: 'ðŸ”',
      config: { port: 5432, ssl: true },
    },
  ],
  mysql: [
    {
      name: 'Local Development',
      description: 'Default MySQL on localhost',
      icon: 'ðŸ’»',
      config: { host: 'localhost', port: 3306, ssl: false },
    },
    {
      name: 'Production',
      description: 'Secure production setup',
      icon: 'ðŸ”',
      config: { port: 3306, ssl: true },
    },
  ],
};

/* =========================
   Default config per connector
========================= */
export function defaultConfigFor(meta: ConnectorMeta): Partial<ConnectionConfig> {
  // Use Record<string, any> for flexibility since ConnectionConfig is a union type
  const base: Record<string, any> = {};
  
  // Set default port if specified
  if (meta.defaultPort) {
    base.port = meta.defaultPort;
  }

  // Set connector-specific defaults
  switch (meta.id) {
    case 'azure-sql':
    case 'synapse-dedicated':
    case 'synapse-serverless':
      base.ssl = true;
      base.encrypt = true;
      break;
      
    case 'neon':
    case 'supabase':
    case 'planetscale':
    case 'aws-rds-postgres':
    case 'aws-rds-mysql':
      base.ssl = true;
      break;
      
    case 'snowflake':
      base.ssl = true;
      base.warehouse = 'COMPUTE_WH';
      // Note: Snowflake doesn't use 'port', it uses the host URL
      break;
      
    case 'bigquery':
      base.location = 'US';
      // Note: BigQuery doesn't use traditional connection properties
      break;
      
    case 'redis':
      base.database = 0; // Default Redis database
      break;
      
    case 'kafka':
      base.securityProtocol = 'PLAINTEXT';
      break;
      
    case 'api':
      base.timeout = 30;
      base.authType = 'none';
      break;
      
    case 'file':
      base.format = 'csv';
      base.encoding = 'utf-8';
      base.recursive = false;
      break;
      
    case 'elasticsearch':
      base.ssl = false;
      break;
  }
    // Cast back to Partial<ConnectionConfig> for type compatibility
  return base as Partial<ConnectionConfig>;
}

/* =========================
   Connectors
========================= */
export const CONNECTORS: ConnectorMeta[] = [
  // --- Databases ---
  {
    id: 'postgresql',
    submitType: 'postgresql',
    label: 'PostgreSQL',
    category: 'Databases',
    icon: 'ðŸ˜',
    description: 'Open-source relational database',
    defaultPort: 5432,
    popularity: 95,
    supportsConnectionString: true,
    connectionStringPlaceholder: 'postgresql://user:pass@host:5432/db',
    parseConnectionString: CONNECTION_STRING_PARSERS.postgresql,
    templates: ENVIRONMENT_TEMPLATES.postgresql,
    documentationUrl: 'https://www.postgresql.org/docs/',
    fields: [
      { key: 'host', label: 'Host', type: 'text', placeholder: 'localhost', required: true, validation: { pattern: VALIDATION_PATTERNS.hostname } },
      { key: 'port', label: 'Port', type: 'number', placeholder: '5432', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Use SSL', type: 'checkbox', help: 'Enable for production' },
      {
        key: 'sslmode',
        label: 'SSL Mode',
        type: 'select',
        options: [
          { value: 'disable', label: 'Disable' },
          { value: 'require', label: 'Require' },
          { value: 'verify-ca', label: 'Verify CA' },
          { value: 'verify-full', label: 'Verify Full' },
        ],
        dependsOn: { field: 'ssl', value: true, condition: 'equals' },
      },
    ],
    tips: ['Use a read-only user', 'Consider pooling', 'Enable SSL in prod'],
    tags: ['sql', 'relational', 'open-source'],
  },
  {
    id: 'aws-rds-postgres',
    submitType: 'postgresql',
    label: 'AWS RDS PostgreSQL',
    category: 'Databases',
    icon: 'ðŸŸ ',
    description: 'Managed PostgreSQL on AWS',
    defaultPort: 5432,
    popularity: 85,
    fields: [
      { key: 'host', label: 'RDS Endpoint', type: 'text', placeholder: 'mydb.cluster-xyz.us-east-1.rds.amazonaws.com', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '5432', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Master Username', type: 'text', required: true },
      { key: 'password', label: 'Master Password', type: 'password', required: true },
      { key: 'ssl', label: 'Force SSL', type: 'checkbox' },
    ],
    tips: ['Backups', 'IAM auth', 'Security groups'],
    tags: ['aws', 'managed', 'postgresql', 'cloud'],
  },
  {
    id: 'neon',
    submitType: 'postgresql',
    label: 'Neon',
    category: 'Databases',
    icon: 'âš¡',
    description: 'Serverless PostgreSQL platform',
    defaultPort: 5432,
    popularity: 75,
    isNew: true,
    supportsConnectionString: true,
    connectionStringPlaceholder: 'postgresql://user:pass@ep-xxx.neon.tech/db',
    parseConnectionString: CONNECTION_STRING_PARSERS.postgresql,
    fields: [
      { key: 'host', label: 'Neon Host', type: 'text', placeholder: 'ep-xxx.neon.tech', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'SSL (Required)', type: 'checkbox' },
    ],
    tips: ['Pooling recommended', 'SSL required'],
    tags: ['serverless', 'postgresql', 'modern'],
  },
  {
    id: 'supabase',
    submitType: 'postgresql',
    label: 'Supabase',
    category: 'Databases',
    icon: 'ðŸŸ¢',
    description: 'Open-source Firebase alternative',
    defaultPort: 5432,
    popularity: 80,
    supportsConnectionString: true,
    connectionStringPlaceholder: 'postgresql://postgres:pass@db.xxx.supabase.co:5432/postgres',
    parseConnectionString: CONNECTION_STRING_PARSERS.postgresql,
    fields: [
      { key: 'host', label: 'Supabase Host', type: 'text', placeholder: 'db.xxx.supabase.co', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '5432', required: true },
      { key: 'database', label: 'Database', type: 'text', placeholder: 'postgres', required: true },
      { key: 'username', label: 'Username', type: 'text', placeholder: 'postgres', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'SSL (Required)', type: 'checkbox' },
    ],
    tips: ['Use dashboard for creds'],
    tags: ['baas', 'postgresql', 'open-source'],
  },
  {
    id: 'mysql',
    submitType: 'mysql',
    label: 'MySQL',
    category: 'Databases',
    icon: 'ðŸ¬',
    description: 'Popular open-source database',
    defaultPort: 3306,
    popularity: 90,
    supportsConnectionString: true,
    connectionStringPlaceholder: 'mysql://user:pass@host:3306/db',
    parseConnectionString: CONNECTION_STRING_PARSERS.mysql,
    fields: [
      { key: 'host', label: 'Host', type: 'text', placeholder: 'localhost', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '3306', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Use SSL', type: 'checkbox' },
    ],
    tips: ['Enable SSL in prod'],
    tags: ['sql', 'relational', 'open-source'],
  },
  {
    id: 'planetscale',
    submitType: 'mysql',
    label: 'PlanetScale',
    category: 'Databases',
    icon: 'ðŸª',
    description: 'Serverless MySQL platform',
    defaultPort: 3306,
    popularity: 70,
    isNew: true,
    fields: [
      { key: 'host', label: 'Host', type: 'text', placeholder: 'xxx.planetscale.dev', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'SSL (Required)', type: 'checkbox' },
    ],
    tips: ['SSL is required'],
    tags: ['serverless', 'mysql', 'modern'],
  },
  {
    id: 'mssql',
    submitType: 'mssql',
    label: 'SQL Server',
    category: 'Databases',
    icon: 'ðŸ¢',
    description: 'Microsoft SQL Server',
    defaultPort: 1433,
    popularity: 75,
    fields: [
      { key: 'host', label: 'Server', type: 'text', placeholder: 'localhost', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '1433', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Encrypt Connection', type: 'checkbox' },
      {
        key: 'trustServerCertificate',
        label: 'Trust Server Certificate',
        type: 'checkbox',
        dependsOn: { field: 'ssl', value: true, condition: 'equals' },
        help: 'Use for self-signed certs',
      },
    ],
    tips: ['Enable encryption in prod'],
    tags: ['microsoft', 'sql', 'enterprise'],
  },
  {
    id: 'azure-sql',
    submitType: 'mssql',
    label: 'Azure SQL Database',
    category: 'Databases',
    icon: 'ðŸŸ¦',
    description: 'Managed SQL Server on Azure',
    defaultPort: 1433,
    popularity: 80,
    fields: [
      {
        key: 'host',
        label: 'Server Name',
        type: 'text',
        placeholder: 'myserver.database.windows.net',
        required: true,
        validation: { pattern: VALIDATION_PATTERNS.azureServer },
      },
      { key: 'port', label: 'Port', type: 'number', placeholder: '1433', required: true },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Encrypt (Required)', type: 'checkbox' },
    ],
    tips: ['Configure firewall rules', 'Use Azure AD if possible'],
    tags: ['azure', 'managed', 'microsoft', 'cloud'],
  },
  {
    id: 'mongodb',
    submitType: 'mongodb',
    label: 'MongoDB',
    category: 'Databases',
    icon: 'ðŸƒ',
    description: 'NoSQL document database',
    defaultPort: 27017,
    popularity: 85,
    supportsConnectionString: true,
    connectionStringPlaceholder: 'mongodb+srv://user:pass@cluster.mongodb.net/db',
    parseConnectionString: CONNECTION_STRING_PARSERS.mongodb,
    fields: [
      { key: 'connectionString', label: 'Connection String (Recommended)', type: 'connectionString', placeholder: 'mongodb+srv://...' },
      { key: 'host', label: 'Host', type: 'text', placeholder: 'localhost', dependsOn: { field: 'connectionString', condition: 'falsy' } },
      { key: 'port', label: 'Port', type: 'number', placeholder: '27017', dependsOn: { field: 'connectionString', condition: 'falsy' } },
      { key: 'database', label: 'Database', type: 'text' },
      { key: 'username', label: 'Username', type: 'text' },
      { key: 'password', label: 'Password', type: 'password' },
      { key: 'ssl', label: 'Use TLS', type: 'checkbox' },
    ],
    tips: ['Prefer connection strings for Atlas'],
    tags: ['nosql', 'document', 'json'],
  },

  // --- Warehouses ---
  {
    id: 'snowflake',
    submitType: 'snowflake',
    label: 'Snowflake',
    category: 'Warehouses',
    icon: 'â„ï¸',
    description: 'Cloud data warehouse',
    popularity: 90,
    fields: [
      { key: 'host', label: 'Account Identifier', type: 'text', placeholder: 'abc123.region.snowflakecomputing.com', required: true, validation: { pattern: VALIDATION_PATTERNS.snowflakeAccount } },
      { key: 'database', label: 'Database', type: 'text', required: true },
      { key: 'warehouse', label: 'Warehouse', type: 'text', placeholder: 'COMPUTE_WH', required: true },
      { key: 'schema', label: 'Schema', type: 'text', placeholder: 'PUBLIC' },
      { key: 'username', label: 'Username', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'role', label: 'Role', type: 'text', placeholder: 'PUBLIC' },
    ],
    tips: ['Use dedicated warehouses', 'Key-pair auth for prod'],
    tags: ['warehouse', 'cloud', 'enterprise'],
  },
  {
    id: 'bigquery',
    submitType: 'bigquery',
    label: 'Google BigQuery',
    category: 'Warehouses',
    icon: 'ðŸ“Š',
    description: 'Serverless data warehouse',
    popularity: 85,
    fields: [
      {
        key: 'serviceAccountKey',
        label: 'Service Account JSON',
        type: 'textarea',
        placeholder: '{ "type": "service_account", ... }',
        required: true,
        validation: {
          custom: (value) => {
            try {
              const parsed = JSON.parse(value);
              return parsed?.type === 'service_account'
                ? null
                : 'Must be a service account JSON key';
            } catch {
              return 'Invalid JSON format';
            }
          },
        },
      },
      { key: 'projectId', label: 'Project ID', type: 'text', required: true, validation: { pattern: VALIDATION_PATTERNS.gcpProject } },
      {
        key: 'location',
        label: 'Location',
        type: 'select',
        options: [
          { value: 'US', label: 'US (Multi-region)' },
          { value: 'EU', label: 'EU (Multi-region)' },
          { value: 'us-central1', label: 'US Central 1' },
          { value: 'us-east1', label: 'US East 1' },
          { value: 'europe-west1', label: 'Europe West 1' },
        ],
      },
    ],
    tips: ['Least privilege for service accounts'],
    tags: ['google', 'serverless', 'warehouse'],
  },
  {
    id: 'synapse-dedicated',
    submitType: 'mssql',
    label: 'Azure Synapse Analytics',
    category: 'Warehouses',
    icon: 'ðŸŸ¦',
    description: 'Enterprise data warehouse',
    defaultPort: 1433,
    popularity: 70,
    fields: [
      { key: 'host', label: 'Synapse Endpoint', type: 'text', placeholder: 'myworkspace.sql.azuresynapse.net', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '1433', required: true },
      { key: 'database', label: 'SQL Pool', type: 'text', required: true },
      { key: 'username', label: 'SQL Admin User', type: 'text', required: true },
      { key: 'password', label: 'Password', type: 'password', required: true },
      { key: 'ssl', label: 'Encrypt (Required)', type: 'checkbox' },
    ],
    tips: ['Firewall rules for your IP'],
    tags: ['azure', 'warehouse', 'enterprise'],
  },

  // --- Storage ---
  {
    id: 's3',
    submitType: 's3',
    label: 'Amazon S3',
    category: 'Storage',
    icon: 'â˜ï¸',
    description: 'Object storage service',
    popularity: 95,
    fields: [
      { key: 'accessKeyId', label: 'Access Key ID', type: 'text', required: true },
      { key: 'secretAccessKey', label: 'Secret Access Key', type: 'password', required: true },
      { key: 'bucket', label: 'Bucket Name', type: 'text', required: true },
      {
        key: 'region',
        label: 'Region',
        type: 'select',
        options: [
          { value: 'us-east-1', label: 'US East (N. Virginia)' },
          { value: 'us-east-2', label: 'US East (Ohio)' },
          { value: 'us-west-2', label: 'US West (Oregon)' },
          { value: 'eu-west-1', label: 'Europe (Ireland)' },
          { value: 'eu-central-1', label: 'Europe (Frankfurt)' },
          { value: 'ap-southeast-1', label: 'AP (Singapore)' },
        ],
        required: true,
      },
      { key: 'prefix', label: 'Prefix/Folder', type: 'text', placeholder: 'data/' },
    ],
    tips: ['Prefer IAM roles', 'Enable versioning'],
    tags: ['aws', 'storage', 'object'],
  },
  {
    id: 'azure-blob',
    submitType: 'azure-blob',
    label: 'Azure Blob Storage',
    category: 'Storage',
    icon: 'ðŸŸ¦',
    description: 'Azure object storage',
    popularity: 70,
    fields: [
      { key: 'accountName', label: 'Storage Account Name', type: 'text', required: true },
      { key: 'accountKey', label: 'Account Key', type: 'password', required: true },
      { key: 'containerName', label: 'Container Name', type: 'text', required: true },
      { key: 'prefix', label: 'Blob Prefix', type: 'text', placeholder: 'data/' },
      { key: 'endpoint', label: 'Endpoint', type: 'text', placeholder: 'https://myaccount.blob.core.windows.net' },
    ],
    tips: ['Use SAS for fine-grained access'],
    tags: ['azure', 'storage', 'blob'],
  },
  {
    id: 'gcs',
    submitType: 'gcs',
    label: 'Google Cloud Storage',
    category: 'Storage',
    icon: 'â˜ï¸',
    description: 'Google object storage',
    popularity: 75,
    fields: [
      {
        key: 'serviceAccountKey',
        label: 'Service Account JSON',
        type: 'textarea',
        required: true,
        validation: {
          custom: (v) => {
            try {
              JSON.parse(v);
              return null;
            } catch {
              return 'Invalid JSON format';
            }
          },
        },
      },
      { key: 'bucketName', label: 'Bucket Name', type: 'text', required: true },
      { key: 'prefix', label: 'Object Prefix', type: 'text', placeholder: 'data/' },
      { key: 'projectId', label: 'Project ID', type: 'text', validation: { pattern: VALIDATION_PATTERNS.gcpProject } },
    ],
    tips: ['Uniform bucket-level access'],
    tags: ['google', 'storage', 'gcp'],
  },

  // --- Streaming ---
  {
    id: 'kafka',
    submitType: 'kafka',
    label: 'Apache Kafka',
    category: 'Streaming',
    icon: 'ðŸš€',
    description: 'Distributed streaming platform',
    popularity: 80,
    fields: [
      { key: 'brokers', label: 'Bootstrap Servers (CSV)', type: 'text', placeholder: 'broker1:9092,broker2:9092', required: true, help: 'Comma-separated list' },
      { key: 'consumerGroup', label: 'Consumer Group', type: 'text', placeholder: 'cwic-consumer' },
      {
        key: 'securityProtocol',
        label: 'Security Protocol',
        type: 'select',
        options: [
          { value: 'PLAINTEXT', label: 'PLAINTEXT' },
          { value: 'SASL_PLAINTEXT', label: 'SASL_PLAINTEXT' },
          { value: 'SASL_SSL', label: 'SASL_SSL' },
          { value: 'SSL', label: 'SSL' },
        ],
      },
      {
        key: 'saslMechanism',
        label: 'SASL Mechanism',
        type: 'select',
        options: [
          { value: 'PLAIN', label: 'PLAIN' },
          { value: 'SCRAM-SHA-256', label: 'SCRAM-SHA-256' },
          { value: 'SCRAM-SHA-512', label: 'SCRAM-SHA-512' },
        ],
        dependsOn: { field: 'securityProtocol', value: 'SASL_PLAINTEXT', condition: 'equals' },
      },
      { key: 'saslUsername', label: 'SASL Username', type: 'text' },
      { key: 'saslPassword', label: 'SASL Password', type: 'password' },
    ],
    tips: ['Use SASL_SSL for prod', 'Monitor lag'],
    tags: ['streaming', 'real-time', 'apache'],
  },

  // --- API & Files ---
  {
    id: 'api',
    submitType: 'api',
    label: 'REST API',
    category: 'API & Files',
    icon: 'ðŸ”Œ',
    description: 'HTTP REST API endpoint',
    popularity: 75,
    fields: [
      { key: 'baseUrl', label: 'Base URL', type: 'text', placeholder: 'https://api.example.com', required: true, validation: { pattern: VALIDATION_PATTERNS.url } },
      {
        key: 'authType',
        label: 'Authentication Type',
        type: 'select',
        options: [
          { value: 'none', label: 'None' },
          { value: 'api-key', label: 'API Key' },
          { value: 'bearer', label: 'Bearer Token' },
          { value: 'basic', label: 'Basic Auth' },
          { value: 'oauth2', label: 'OAuth 2.0' },
        ],
      },
      { key: 'apiKey', label: 'API Key', type: 'password', dependsOn: { field: 'authType', value: 'api-key', condition: 'equals' } },
      { key: 'apiKeyHeader', label: 'API Key Header', type: 'text', placeholder: 'X-API-Key', dependsOn: { field: 'authType', value: 'api-key', condition: 'equals' } },
      { key: 'bearerToken', label: 'Bearer Token', type: 'password', dependsOn: { field: 'authType', value: 'bearer', condition: 'equals' } },
      { key: 'username', label: 'Username', type: 'text', dependsOn: { field: 'authType', value: 'basic', condition: 'equals' } },
      { key: 'password', label: 'Password', type: 'password', dependsOn: { field: 'authType', value: 'basic', condition: 'equals' } },
      { key: 'timeout', label: 'Timeout (seconds)', type: 'number', placeholder: '30', validation: { min: 1, max: 300 } },
      { key: 'rateLimit', label: 'Rate Limit (req/min)', type: 'number', placeholder: '100' },
    ],
    tips: ['Put API keys in headers', 'Rate limit to avoid throttling'],
    tags: ['http', 'rest', 'api'],
  },
  {
    id: 'file',
    submitType: 'file',
    label: 'File System',
    category: 'API & Files',
    icon: 'ðŸ“',
    description: 'Local or network file system',
    popularity: 60,
    fields: [
      { key: 'path', label: 'File Path / Glob', type: 'text', placeholder: '/data/*.csv or C:\\data\\*.json', required: true, help: 'Supports glob patterns' },
      {
        key: 'format',
        label: 'File Format',
        type: 'select',
        options: [
          { value: 'csv', label: 'CSV' },
          { value: 'json', label: 'JSON' },
          { value: 'jsonl', label: 'JSON Lines' },
          { value: 'parquet', label: 'Parquet' },
          { value: 'xlsx', label: 'Excel (XLSX)' },
          { value: 'xml', label: 'XML' },
          { value: 'txt', label: 'Text' },
        ],
        required: true,
      },
      { key: 'encoding', label: 'Text Encoding', type: 'select', options: [{ value: 'utf-8', label: 'UTF-8' }, { value: 'utf-16', label: 'UTF-16' }, { value: 'latin1', label: 'Latin-1' }, { value: 'ascii', label: 'ASCII' }], dependsOn: { field: 'format', value: 'csv', condition: 'equals' } },
      { key: 'delimiter', label: 'Delimiter', type: 'text', placeholder: ',', dependsOn: { field: 'format', value: 'csv', condition: 'equals' } },
      { key: 'hasHeader', label: 'Has Header Row', type: 'checkbox', dependsOn: { field: 'format', value: 'csv', condition: 'equals' } },
      { key: 'recursive', label: 'Scan Subdirectories', type: 'checkbox' },
    ],
    tips: ['Check file permissions', 'Start with a small subset'],
    tags: ['filesystem', 'local', 'files'],
  },
  {
    id: 'elasticsearch',
    submitType: 'elasticsearch',
    label: 'Elasticsearch',
    category: 'Databases',
    icon: 'ðŸ”',
    description: 'Search and analytics engine',
    defaultPort: 9200,
    popularity: 70,
    fields: [
      { key: 'host', label: 'Host', type: 'text', placeholder: 'localhost', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '9200' },
      { key: 'username', label: 'Username', type: 'text' },
      { key: 'password', label: 'Password', type: 'password' },
      { key: 'ssl', label: 'Use HTTPS', type: 'checkbox' },
      { key: 'apiKey', label: 'API Key', type: 'password' },
      { key: 'cloudId', label: 'Elastic Cloud ID', type: 'text', placeholder: 'deployment:base64...' },
      { key: 'index', label: 'Default Index Pattern', type: 'text', placeholder: 'logs-*' },
    ],
    tips: ['Use API keys', 'Enable security features'],
    tags: ['search', 'analytics', 'elk'],
  },
  {
    id: 'redis',
    submitType: 'redis',
    label: 'Redis',
    category: 'Databases',
    icon: 'ðŸ“¦',
    description: 'In-memory data store',
    defaultPort: 6379,
    popularity: 85,
    fields: [
      { key: 'host', label: 'Host', type: 'text', placeholder: 'localhost', required: true },
      { key: 'port', label: 'Port', type: 'number', placeholder: '6379', required: true },
      { key: 'password', label: 'Password', type: 'password' },
      { key: 'database', label: 'Database Number', type: 'number', placeholder: '0' },
      { key: 'ssl', label: 'Use TLS', type: 'checkbox' },
      { key: 'keyPrefix', label: 'Key Prefix', type: 'text', placeholder: 'myapp:' },
    ],
    tips: ['Use AUTH in prod', 'Expiry for memory mgmt'],
    tags: ['cache', 'memory', 'key-value'],
  },
];

/* =========================
   Category / helpers
========================= */
export const CATEGORIES: ConnectorCategory[] = [
  'Databases',
  'Warehouses',
  'Storage',
  'Streaming',
  'API & Files',
];

export function getPopularConnectors(limit = 6): ConnectorMeta[] {
  return [...CONNECTORS]
    .sort((a, b) => (b.popularity || 0) - (a.popularity || 0))
    .slice(0, limit);
}

export function getNewConnectors(): ConnectorMeta[] {
  return CONNECTORS.filter((c) => c.isNew);
}

export function searchConnectors(query: string): ConnectorMeta[] {
  const q = query.toLowerCase().trim();
  return CONNECTORS.filter(
    (c) =>
      c.label.toLowerCase().includes(q) ||
      c.description?.toLowerCase().includes(q) ||
      c.tags?.some((t) => t.toLowerCase().includes(q)) ||
      String(c.id).toLowerCase().includes(q)
  );
}

export function validateField(
  field: FieldDef,
  value: any,
  config: ConnectionConfig
): string | null {
  if (field.required && (value === undefined || value === null || value === '')) {
    return `${field.label} is required`;
  }
  if (!value && !field.required) return null;

  if (field.validation?.pattern && !field.validation.pattern.test(String(value))) {
    return `${field.label} format is invalid`;
  }

  if (field.type === 'number') {
    const n = Number(value);
    if (field.validation?.min !== undefined && n < field.validation.min) {
      return `${field.label} must be at least ${field.validation.min}`;
    }
    if (field.validation?.max !== undefined && n > field.validation.max) {
      return `${field.label} must be at most ${field.validation.max}`;
    }
  }

  if (field.validation?.custom) {
    return field.validation.custom(value, config);
  }
  return null;
}

export function shouldShowField(field: FieldDef, config: ConnectionConfig): boolean {
  if (!field.dependsOn) return true;

  const { field: dep, value, condition = 'equals' } = field.dependsOn;
  const dv =
    dep.startsWith('custom.')
      ? (config.customOptions || {})[dep.slice('custom.'.length)]
      : (config as any)[dep];

  switch (condition) {
    case 'equals':
      return dv === value;
    case 'not-equals':
      return dv !== value;
    case 'truthy':
      return !!dv;
    case 'falsy':
      return !dv;
    default:
      return true;
  }
}

/* =========================
   Migration helpers
========================= */
type MigrationPath = {
  name: string;
  description: string;
  fieldMapping: Record<string, string>;
  transformations: Record<string, (v: any) => any>;
};

export const MIGRATION_PATHS: Record<string, MigrationPath> = {
  'mysql-to-postgresql': {
    name: 'MySQL to PostgreSQL',
    description: 'Copy common fields; toggle SSL on',
    fieldMapping: { host: 'host', port: 'port', database: 'database', username: 'username', password: 'password' },
    transformations: { port: (v: number) => (v === 3306 ? 5432 : v), ssl: () => true },
  },
};

export function getMigrationPath(fromId: ConnectorId, toId: ConnectorId) {
  return MIGRATION_PATHS[`${fromId}-to-${toId}`];
}



------------------------------------------------------------
FILE: frontend\src\components\features\data-sources\DataSourceCard.tsx
------------------------------------------------------------
// src/components/features/data-sources/DataSourceCard.tsx
import type { DataSource, DataSourceType } from '@/types/dataSources';

// Fixed status colors to match actual DataSourceStatus union
const statusColors: Record<DataSource['status'], string> = {
  active: 'bg-emerald-100 text-emerald-800',
  inactive: 'bg-gray-200 text-gray-700',
  pending: 'bg-amber-100 text-amber-800',
  error: 'bg-red-100 text-red-700',
  testing: 'bg-blue-100 text-blue-800',
};

// Helper function to safely get connection info
function getConnectionInfo(config: DataSource['connectionConfig'], type: DataSourceType) {
  // Type-safe property access based on connector type
  const info: { host?: string; database?: string; bucket?: string; baseUrl?: string } = {};

  // Database types that have host/database
  if (['postgresql', 'mysql', 'mssql', 'mongodb', 'redis', 'elasticsearch'].includes(type)) {
    info.host = (config as any).host;
    info.database = (config as any).database;
  }
  // Storage types that have bucket
  else if (['s3', 'azure-blob', 'gcs'].includes(type)) {
    info.bucket = (config as any).bucket || (config as any).containerName || (config as any).bucketName;
  }
  // API types that have baseUrl
  else if (type === 'api') {
    info.baseUrl = (config as any).baseUrl;
  }
  // Data warehouses
  else if (['snowflake', 'bigquery', 'redshift', 'databricks'].includes(type)) {
    info.host = (config as any).host;
    info.database = (config as any).database || (config as any).projectId;
  }

  return info;
}

// Helper function to format dates
function formatDate(dateString?: string): string {
  if (!dateString) return 'â€”';
  try {
    return new Date(dateString).toLocaleString();
  } catch {
    return 'â€”';
  }
}

// Helper function to format relative time
function formatRelativeTime(dateString?: string): string {
  if (!dateString) return 'Never';
  
  try {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) {
      return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    } else if (diffHours > 0) {
      return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    } else if (diffMinutes > 0) {
      return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;
    } else {
      return 'Just now';
    }
  } catch {
    return 'Unknown';
  }
}

// Get connector icon
function getConnectorIcon(type: DataSourceType): string {
  const icons: Record<DataSourceType, string> = {
    postgresql: 'ðŸ˜',
    mysql: 'ðŸ¬',
    mssql: 'ðŸ¢',
    mongodb: 'ðŸƒ',
    redis: 'ðŸ“¦',
    snowflake: 'â„ï¸',
    bigquery: 'ðŸ“Š',
    redshift: 'ðŸ”´',
    databricks: 'ðŸ§±',
    s3: 'â˜ï¸',
    'azure-blob': 'ðŸŸ¦',
    gcs: 'â˜ï¸',
    kafka: 'ðŸš€',
    api: 'ðŸ”Œ',
    file: 'ðŸ“',
    ftp: 'ðŸ“¡',
    elasticsearch: 'ðŸ”',
    oracle: 'ðŸ›ï¸', // If you decide to support Oracle in the future

  };
  return icons[type] || 'ðŸ’¾';
}

// Get display name for type
function getTypeDisplayName(type: DataSourceType): string {
  const displayNames: Record<DataSourceType, string> = {
    postgresql: 'PostgreSQL',
    mysql: 'MySQL',
    mssql: 'SQL Server',
    mongodb: 'MongoDB',
    redis: 'Redis',
    snowflake: 'Snowflake',
    bigquery: 'BigQuery',
    redshift: 'Amazon Redshift',
    databricks: 'Databricks',
    s3: 'Amazon S3',
    'azure-blob': 'Azure Blob Storage',
    gcs: 'Google Cloud Storage',
    kafka: 'Apache Kafka',
    api: 'REST API',
    file: 'File System',
    ftp: 'FTP/SFTP',
    elasticsearch: 'Elasticsearch',
    oracle: 'Oracle Database' // If you decide to support Oracle in the future
  };
  return displayNames[type] || type;
}

export default function DataSourceCard({
  ds, 
  onTest, 
  onSync, 
  onDelete,
}: { 
  ds: DataSource; 
  onTest(id: string): void; 
  onSync(id: string): void; 
  onDelete(id: string): void; 
}) {
  const connectionInfo = getConnectionInfo(ds.connectionConfig, ds.type);
  const hasError = ds.status === 'error' || ds.healthStatus?.status === 'down';
  const isLoading = ds.status === 'testing' || ds.syncStatus?.status === 'syncing';

  return (
    <div className="rounded-2xl border bg-white p-4 shadow-sm hover:shadow-md transition-shadow">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-lg">{getConnectorIcon(ds.type)}</span>
            <div className="text-sm text-gray-500">{getTypeDisplayName(ds.type)}</div>
          </div>
          <div className="mt-0.5 text-lg font-semibold truncate" title={ds.name}>
            {ds.name}
          </div>
          {ds.description && (
            <div className="text-sm text-gray-500 line-clamp-2" title={ds.description}>
              {ds.description}
            </div>
          )}
        </div>
        <div className="flex flex-col items-end gap-1">
          <span className={`rounded-full px-2 py-0.5 text-xs font-medium ${statusColors[ds.status]}`}>
            {ds.status === 'active' ? 'Active' : 
             ds.status === 'inactive' ? 'Inactive' : 
             ds.status === 'pending' ? 'Pending' : 
             ds.status === 'error' ? 'Error' : 
             'Testing'}
          </span>
          {isLoading && (
            <div className="flex items-center gap-1 text-xs text-blue-600">
              <div className="animate-spin w-3 h-3 border border-blue-600 border-t-transparent rounded-full"></div>
              {ds.status === 'testing' ? 'Testing' : 'Syncing'}
            </div>
          )}
        </div>
      </div>

      {/* Connection Details */}
      <div className="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-600">
        {connectionInfo.host && (
          <div>
            <span className="text-gray-500">Host:</span>{' '}
            <span className="font-medium">{connectionInfo.host}</span>
          </div>
        )}
        {connectionInfo.database && (
          <div>
            <span className="text-gray-500">Database:</span>{' '}
            <span className="font-medium">{connectionInfo.database}</span>
          </div>
        )}
        {connectionInfo.bucket && (
          <div>
            <span className="text-gray-500">Bucket:</span>{' '}
            <span className="font-medium">{connectionInfo.bucket}</span>
          </div>
        )}
        {connectionInfo.baseUrl && (
          <div className="col-span-2">
            <span className="text-gray-500">URL:</span>{' '}
            <span className="font-medium truncate">{connectionInfo.baseUrl}</span>
          </div>
        )}
        <div>
          <span className="text-gray-500">Last Sync:</span>{' '}
          <span className="font-medium">{formatRelativeTime(ds.lastSyncAt)}</span>
        </div>
        <div>
          <span className="text-gray-500">Last Test:</span>{' '}
          <span className="font-medium">{formatRelativeTime(ds.lastTestedAt)}</span>
        </div>
      </div>

      {/* Health Status */}
      {ds.healthStatus && ds.healthStatus.status !== 'healthy' && (
        <div className="mt-2 rounded-md bg-amber-50 border border-amber-200 p-2">
          <div className="flex items-center gap-1 text-xs text-amber-700">
            <span>âš ï¸</span>
            <span className="font-medium">Health: {ds.healthStatus.status}</span>
          </div>
          {ds.healthStatus.message && (
            <div className="text-xs text-amber-600 mt-1">{ds.healthStatus.message}</div>
          )}
        </div>
      )}

      {/* Error Display */}
      {hasError && ds.healthStatus?.message && (
        <div className="mt-2 rounded-md bg-red-50 border border-red-200 p-2">
          <div className="flex items-center gap-1 text-xs text-red-700">
            <span>âŒ</span>
            <span className="font-medium">Error</span>
          </div>
          <div className="text-xs text-red-600 mt-1">{ds.healthStatus.message}</div>
        </div>
      )}

      {/* Usage Stats */}
      {ds.usage && (ds.usage.queriesCount > 0 || ds.usage.lastUsed) && (
        <div className="mt-2 rounded-md bg-blue-50 border border-blue-200 p-2">
          <div className="grid grid-cols-2 gap-2 text-xs">
            {ds.usage.queriesCount > 0 && (
              <div>
                <span className="text-blue-600">Queries:</span>{' '}
                <span className="font-medium text-blue-800">{ds.usage.queriesCount}</span>
              </div>
            )}
            {ds.usage.lastUsed && (
              <div>
                <span className="text-blue-600">Last Used:</span>{' '}
                <span className="font-medium text-blue-800">{formatRelativeTime(ds.usage.lastUsed)}</span>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Tags */}
      {ds.tags && ds.tags.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {ds.tags.slice(0, 3).map((tag) => (
            <span
              key={tag}
              className="rounded-full bg-gray-100 px-2 py-0.5 text-xs text-gray-700"
            >
              {tag}
            </span>
          ))}
          {ds.tags.length > 3 && (
            <span className="rounded-full bg-gray-100 px-2 py-0.5 text-xs text-gray-500">
              +{ds.tags.length - 3} more
            </span>
          )}
        </div>
      )}

      {/* Actions */}
      <div className="mt-4 flex gap-2">
        <button 
          onClick={() => onTest(ds.id)} 
          disabled={isLoading}
          className="flex-1 rounded-lg border px-3 py-1.5 text-sm hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          title="Test connection"
        >
          {ds.status === 'testing' ? 'Testing...' : 'Test'}
        </button>
        <button 
          onClick={() => onSync(ds.id)} 
          disabled={isLoading}
          className="flex-1 rounded-lg border px-3 py-1.5 text-sm hover:bg-blue-50 hover:border-blue-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          title="Sync/discover assets"
        >
          {ds.syncStatus?.status === 'syncing' ? 'Syncing...' : 'Sync'}
        </button>
        <button 
          onClick={() => onDelete(ds.id)} 
          disabled={isLoading}
          className="rounded-lg border border-red-200 px-3 py-1.5 text-sm text-red-600 hover:bg-red-50 hover:border-red-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          title="Delete data source"
        >
          Delete
        </button>
      </div>

      {/* Metadata */}
      <div className="mt-2 pt-2 border-t border-gray-100">
        <div className="flex justify-between text-xs text-gray-500">
          <span>Created {formatRelativeTime(ds.createdAt)}</span>
          {ds.createdBy && <span>by {ds.createdBy}</span>}
        </div>
      </div>
    </div>
  );
}


------------------------------------------------------------
FILE: frontend\src\components\features\pipelines\DeploymentHistory.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\features\pipelines\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\components\features\pipelines\PipelineCard.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\features\pipelines\PipelineDetails.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\features\pipelines\PipelineList.tsx
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\components\features\requests\ApprovalWorkflow.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Check, Clock, X } from 'lucide-react'

export type StepState = 'pending' | 'approved' | 'rejected'

export interface WorkflowStep {
  id: string
  label: string
  approver: string
  state: StepState
  updatedAt?: string
}

export function ApprovalWorkflow({ steps = [] as WorkflowStep[] }: { steps?: WorkflowStep[] }) {
  if (!steps.length) {
    return (
      <Card>
        <CardHeader><CardTitle>Approval Workflow</CardTitle></CardHeader>
        <CardContent className="text-sm text-gray-600">No workflow configured.</CardContent>
      </Card>
    )
  }

  return (
    <Card>
      <CardHeader><CardTitle>Approval Workflow</CardTitle></CardHeader>
      <CardContent>
        <ol className="space-y-3">
          {steps.map((s, i) => (
            <li key={s.id} className="flex items-center justify-between rounded-lg border p-3">
              <div className="flex items-center gap-3">
                <span className="inline-flex h-7 w-7 items-center justify-center rounded-full bg-gray-100 text-xs font-semibold">
                  {i + 1}
                </span>
                <div>
                  <div className="text-sm font-medium text-gray-900">{s.label}</div>
                  <div className="text-xs text-gray-600">Approver: {s.approver}</div>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Badge tone={tone(s.state)} className="capitalize">{s.state}</Badge>
                <span className="text-xs text-gray-500">{s.updatedAt ? fmt(s.updatedAt) : ''}</span>
                {icon(s.state)}
              </div>
            </li>
          ))}
        </ol>
      </CardContent>
    </Card>
  )
}

function tone(s: StepState) {
  return s === 'approved' ? 'success' : s === 'rejected' ? 'danger' : 'info'
}
function icon(s: StepState) {
  const cls = 'h-4 w-4'
  if (s === 'approved') return <Check className={cls} />
  if (s === 'rejected') return <X className={cls} />
  return <Clock className={cls} />
}
function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}



------------------------------------------------------------
FILE: frontend\src\components\features\requests\index.ts
------------------------------------------------------------
// barrelexport { RequestList } from './RequestList'
export type { RequestItem, RequestStatus } from './RequestList'

export { RequestForm } from './RequestForm'
export type { RequestFormValues } from './RequestForm'

export { RequestDetails } from './RequestDetails'

export { ApprovalWorkflow } from './ApprovalWorkflow'
export type { StepState, WorkflowStep } from './ApprovalWorkflow'




------------------------------------------------------------
FILE: frontend\src\components\features\requests\RequestDetails.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import type { RequestItem } from './RequestList'

export function RequestDetails({
  request,
  onApprove,
  onReject,
  onComplete,
}: {
  request: RequestItem | null
  onApprove?: (id: string) => void
  onReject?: (id: string) => void
  onComplete?: (id: string) => void
}) {
  if (!request) return null

  const statusTone =
    request.status === 'approved'
      ? 'success'
      : request.status === 'rejected'
      ? 'danger'
      : request.status === 'in_review'
      ? 'info'
      : request.status === 'completed'
      ? 'neutral'
      : 'warning'

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>{request.title}</CardTitle>
          <Badge tone={statusTone}>{request.status}</Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-4 text-sm">
        <div><span className="text-gray-500">Requester: </span>{request.requester}</div>
        <div><span className="text-gray-500">Created: </span>{fmt(request.createdAt)}</div>
        {request.summary && <p className="text-gray-700">{request.summary}</p>}
        <div className="flex flex-wrap gap-2">
          <Button variant="outline" onClick={() => onApprove?.(request.id)}>Approve</Button>
          <Button variant="ghost" onClick={() => onReject?.(request.id)}>Reject</Button>
          <Button onClick={() => onComplete?.(request.id)}>Mark Complete</Button>
        </div>
      </CardContent>
    </Card>
  )
}

function fmt(iso: string) {
  try { return new Date(iso).toLocaleString() } catch { return iso }
}



------------------------------------------------------------
FILE: frontend\src\components\features\requests\RequestForm.tsx
------------------------------------------------------------
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Input } from '@components/ui/Input'
import { Select } from '@components/ui/Select'
import * as React from 'react'

export interface RequestFormValues {
  title: string
  description: string
  priority: 'low' | 'medium' | 'high'
  dataset?: string
}

export function RequestForm({
  value,
  onChange,
  onSubmit,
  busy,
}: {
  value?: Partial<RequestFormValues>
  onChange?: (v: Partial<RequestFormValues>) => void
  onSubmit?: (v: RequestFormValues) => Promise<void> | void
  busy?: boolean
}) {
  const [form, setForm] = React.useState<RequestFormValues>({
    title: value?.title ?? '',
    description: value?.description ?? '',
    priority: (value?.priority as RequestFormValues['priority']) ?? 'medium',
    dataset: value?.dataset ?? '',
  })

  function patch<K extends keyof RequestFormValues>(k: K, v: RequestFormValues[K]) {
    const next = { ...form, [k]: v }
    setForm(next)
    onChange?.(next)
  }

  async function submit(e: React.FormEvent) {
    e.preventDefault()
    await onSubmit?.(form)
  }

  return (
    <Card>
      <CardHeader><CardTitle>Create New Request</CardTitle></CardHeader>
      <CardContent>
        <form onSubmit={submit} className="space-y-4">
          <Input placeholder="Title" value={form.title} onChange={(e) => patch('title', e.target.value)} />
          <Input
            placeholder="Dataset / Asset (optional)"
            value={form.dataset ?? ''}
            onChange={(e) => patch('dataset', e.target.value)}
          />
          <textarea
            value={form.description}
            onChange={(e) => patch('description', e.target.value)}
            placeholder="Describe the business requirementâ€¦"
            className="w-full rounded-xl border border-gray-300 p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
            rows={4}
          />
          <div className="grid gap-3 sm:grid-cols-2">
            <Select
              label="Priority"
              value={form.priority}
              onChange={(e) => patch('priority', e.target.value as RequestFormValues['priority'])}
              options={[
                { label: 'Low', value: 'low' },
                { label: 'Medium', value: 'medium' },
                { label: 'High', value: 'high' },
              ]}
            />
            <div className="flex items-end justify-end">
              <Button type="submit" disabled={busy}>
                {busy ? 'Submittingâ€¦' : 'Create Request'}
              </Button>
            </div>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\features\requests\RequestList.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'

export type RequestStatus = 'open' | 'in_review' | 'approved' | 'rejected' | 'completed'

export interface RequestItem {
  id: string
  title: string
  requester: string
  createdAt: string  // ISO
  priority?: 'low' | 'medium' | 'high'
  status: RequestStatus
  summary?: string
}

export function RequestList({
  items = [],
  loading,
  onSelect,
  onNew,
}: {
  items?: RequestItem[]
  loading?: boolean
  onSelect?: (id: string) => void
  onNew?: () => void
}) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Requests</CardTitle>
          <Button onClick={onNew}>Create Request</Button>
        </div>
      </CardHeader>
      <CardContent>
        {loading ? (
          <ListSkeleton />
        ) : items.length === 0 ? (
          <div className="text-sm text-gray-600">No requests found.</div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead className="text-left text-gray-500">
                <tr>
                  <th className="py-2 pr-4">Title</th>
                  <th className="py-2 pr-4">Requester</th>
                  <th className="py-2 pr-4">Priority</th>
                  <th className="py-2 pr-4">Status</th>
                  <th className="py-2 pr-4">Created</th>
                  <th className="py-2 pr-0 text-right">Actions</th>
                </tr>
              </thead>
              <tbody>
                {items.map((r) => (
                  <tr key={r.id} className="border-t">
                    <td className="py-2 pr-4 font-medium text-gray-900">{r.title}</td>
                    <td className="py-2 pr-4">{r.requester}</td>
                    <td className="py-2 pr-4">
                      <Badge tone={r.priority === 'high' ? 'danger' : r.priority === 'medium' ? 'warning' : 'neutral'}>
                        {r.priority ?? 'low'}
                      </Badge>
                    </td>
                    <td className="py-2 pr-4">
                      <Badge tone={statusTone(r.status)}>{r.status}</Badge>
                    </td>
                    <td className="py-2 pr-4">{fmt(r.createdAt)}</td>
                    <td className="py-2 pr-0 text-right">
                      <Button variant="outline" size="sm" onClick={() => onSelect?.(r.id)}>
                        View
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

function statusTone(s: RequestStatus) {
  return s === 'approved'
    ? 'success'
    : s === 'rejected'
    ? 'danger'
    : s === 'in_review'
    ? 'info'
    : s === 'completed'
    ? 'neutral'
    : 'warning'
}

function fmt(iso: string) {
  try {
    return new Date(iso).toLocaleString()
  } catch {
    return iso
  }
}

function ListSkeleton() {
  return (
    <div className="space-y-2">
      {Array.from({ length: 6 }).map((_, i) => (
        <div key={i} className="h-12 w-full animate-pulse rounded bg-gray-200" />
      ))}
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\layout\Footer.tsx
------------------------------------------------------------
import * as React from 'react'

export const Footer: React.FC = () => (
  <footer className="border-t border-gray-200 bg-white">
    <div className="mx-auto max-w-7xl px-6 py-4 text-xs text-gray-500 flex items-center justify-between">
      <span>© {new Date().getFullYear()} CWIC Platform</span>
      <span>v1.0.0</span>
    </div>
  </footer>
)



------------------------------------------------------------
FILE: frontend\src\components\layout\Header.tsx
------------------------------------------------------------
import { Badge } from '@/components/ui/Badge'
import { Button } from '@/components/ui/Button'
import { useAuth } from '@/hooks/useAuth'
import { cn } from '@/utils'
import { Bell, LogOut, Search, Settings, UserRound } from 'lucide-react'
import * as React from 'react'
import { useLocation } from 'react-router-dom'

const TITLES: Record<string, string> = {
  '/dashboard': 'Dashboard',
  '/ai-assistant': 'AI Assistant',
  '/data-catalog': 'Data Catalog',
  '/data-quality': 'Data Quality',
  '/data-lineage': 'Data Lineage',
  '/pipelines': 'CI/CD Pipelines',
  '/requests': 'Workflow Requests',
  '/connections': 'Data Sources',
  '/governance': 'Governance',
  '/monitoring': 'Monitoring',
  '/settings': 'Settings',
}

export interface HeaderProps {
  notifications?: Array<{ id: string; title: string; message: string; time: string; type: 'success'|'warning'|'error'|'info'; unread?: boolean }>
}

export const Header: React.FC<HeaderProps> = ({ notifications = [] }) => {
  const { pathname } = useLocation()
  const { user, logout } = useAuth()
  const [showNotif, setShowNotif] = React.useState(false)
  const [showUser, setShowUser] = React.useState(false)
  const [q, setQ] = React.useState('')
  const unread = notifications.filter(n => n.unread).length

  return (
    <header className="bg-white border-b border-gray-200 z-10 sticky top-0">
      <div className="h-16 px-6 flex items-center justify-between gap-4">
        <div className="flex min-w-0 items-center gap-4">
          <h1 className="truncate text-xl font-semibold text-gray-900">{TITLES[pathname] ?? 'CWIC Platform'}</h1>
        </div>

        <div className="flex items-center gap-3">
          {/* Search */}
          <label className="relative hidden md:block">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              placeholder="Search assets, pipelines, requestsâ€¦"
              className="w-80 rounded-xl border border-gray-300 bg-gray-50 px-9 py-2 text-sm text-gray-900 focus:bg-white focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </label>

          {/* Notifications */}
          <div className="relative">
            <Button variant="ghost" size="icon" aria-label="Notifications" onClick={() => setShowNotif(s => !s)}>
              <Bell className="h-5 w-5" />
              {unread > 0 && (
                <Badge tone="danger" className="absolute -top-1 -right-1 h-4 w-4 p-0 flex items-center justify-center">
                  {unread}
                </Badge>
              )}
            </Button>
            {showNotif && (
              <div className="absolute right-0 mt-2 w-96 rounded-xl border border-gray-200 bg-white shadow-lg">
                <div className="flex items-center justify-between px-4 py-3 border-b">
                  <div className="font-semibold">Notifications</div>
                  <button className="text-sm text-blue-600 hover:underline">Mark all read</button>
                </div>
                <ul className="max-h-80 overflow-auto">
                  {notifications.slice(0, 8).map((n) => (
                    <li key={n.id} className={cn('px-4 py-3 border-b last:border-b-0', n.unread && 'bg-blue-50')}>
                      <div className="text-sm font-medium text-gray-900">{n.title}</div>
                      <div className="text-sm text-gray-700">{n.message}</div>
                      <div className="text-xs text-gray-500 mt-1">{n.time}</div>
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          {/* User */}
          <div className="relative">
            <Button variant="outline" onClick={() => setShowUser(s => !s)} leftIcon={<UserRound className="h-4 w-4" />}>
              {user?.name ?? 'User'}
            </Button>
            {showUser && (
              <div className="absolute right-0 mt-2 w-56 rounded-xl border border-gray-200 bg-white shadow-lg">
                <div className="px-4 py-3 border-b">
                  <div className="text-sm font-medium">{user?.name ?? 'User'}</div>
                  <div className="text-xs text-gray-500">{user?.email ?? ''}</div>
                </div>
                <button className="w-full flex items-center gap-2 px-4 py-2 text-sm hover:bg-gray-50">
                  <Settings className="h-4 w-4" /> Settings
                </button>
                <button onClick={logout} className="w-full flex items-center gap-2 px-4 py-2 text-sm text-red-600 hover:bg-red-50">
                  <LogOut className="h-4 w-4" /> Logout
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\layout\index.ts
------------------------------------------------------------
export { Footer } from './Footer'
export { Header } from './Header'
export { Layout } from './layout'
export { Navigation } from './Navigation'




------------------------------------------------------------
FILE: frontend\src\components\layout\layout.tsx
------------------------------------------------------------
import * as React from 'react'
import { Footer } from './Footer'
import { Header } from './Header'
import { Navigation } from './Navigation'

export const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [collapsed, setCollapsed] = React.useState(false)

  return (
    <div className="flex bg-gray-100">
      <Navigation collapsed={collapsed} onToggle={() => setCollapsed(c => !c)} />
      <div className="flex min-h-screen flex-1 flex-col">
        <Header />
        <main className="flex-1 p-6">{children}</main>
        <Footer />
      </div>
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\layout\Navigation.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import {
    ChevronRight,
    Settings as Cog,
    Database,
    FileText,
    GitBranch,
    Home,
    Layers,
    MessageSquare,
    Monitor,
    Shield,
    Users,
    Workflow,
    Zap
} from 'lucide-react'
import * as React from 'react'
import { useLocation, useNavigate } from 'react-router-dom'

type NavItem = { id: string; label: string; path: string; icon: React.ComponentType<any>; badge?: string }

const NAV: NavItem[] = [
  { id: 'dashboard',     label: 'Dashboard',         path: '/dashboard',     icon: Home },
  { id: 'ai',            label: 'AI Assistant',      path: '/ai-assistant',  icon: MessageSquare, badge: 'AI' },
  { id: 'catalog',       label: 'Data Catalog',      path: '/data-catalog',  icon: Database },
  { id: 'quality',       label: 'Data Quality',      path: '/data-quality',  icon: Shield },
  { id: 'lineage',       label: 'Data Lineage',      path: '/data-lineage',  icon: GitBranch },
  { id: 'pipelines',     label: 'CI/CD Pipelines',   path: '/pipelines',     icon: Workflow },
  { id: 'requests',      label: 'Workflow Requests', path: '/requests',      icon: FileText },
  { id: 'connections',   label: 'Data Sources',      path: '/connections',   icon: Layers },
  { id: 'governance',    label: 'Governance',        path: '/governance',    icon: Users },
  { id: 'monitoring',    label: 'Monitoring',        path: '/monitoring',    icon: Monitor },
  { id: 'settings',      label: 'Settings',          path: '/settings',      icon: Cog },
]

export interface NavigationProps {
  collapsed?: boolean
  onToggle?: () => void
}

export const Navigation: React.FC<NavigationProps> = ({ collapsed = false, onToggle }) => {
  const { pathname } = useLocation()
  const navigate = useNavigate()

  return (
    <aside
      className={cn(
        'bg-slate-900 text-white transition-all duration-300 sticky top-0 h-screen shrink-0',
        collapsed ? 'w-16' : 'w-64'
      )}
      aria-label="Primary"
    >
      {/* Brand */}
      <div className={cn('flex items-center gap-3 px-4 py-4 border-b border-white/5')}>
        <div className="bg-blue-600 p-2 rounded-xl shadow-sm">
          <Zap className="h-5 w-5 text-white" />
        </div>
        {!collapsed && (
          <div className="leading-tight">
            <div className="text-lg font-bold tracking-tight">CWIC</div>
            <div className="text-[11px] text-slate-400">Workflow Intelligence</div>
          </div>
        )}
      </div>

      {/* Nav items */}
      <nav className="px-2 py-3 space-y-1">
        {NAV.map(({ id, label, icon: Icon, path, badge }) => {
          const active = pathname === path
          return (
            <button
              key={id}
              onClick={() => navigate(path)}
              className={cn(
                'w-full flex items-center gap-3 rounded-xl px-3 py-2 text-left outline-none',
                active ? 'bg-blue-600 text-white shadow' : 'text-slate-300 hover:bg-slate-800 hover:text-white'
              )}
              title={collapsed ? label : undefined}
              aria-current={active ? 'page' : undefined}
            >
              <Icon className="h-5 w-5 shrink-0" />
              {!collapsed && (
                <>
                  <span className="truncate">{label}</span>
                  {badge && (
                    <span className="ml-auto text-[10px] leading-4 rounded-full px-2 py-0.5 bg-green-500/90">
                      {badge}
                    </span>
                  )}
                </>
              )}
            </button>
          )
        })}
      </nav>

      {/* Collapse */}
      <div className="absolute bottom-3 left-0 right-0 px-2">
        <button
          className="w-full flex items-center justify-center rounded-xl py-2 text-slate-300 hover:text-white hover:bg-slate-800"
          onClick={onToggle}
          aria-label={collapsed ? 'Expand sidebar' : 'Collapse sidebar'}
        >
          <ChevronRight className={cn('h-4 w-4 transition-transform', collapsed ? '' : 'rotate-180')} />
        </button>
      </div>
    </aside>
  )
}



------------------------------------------------------------
FILE: frontend\src\components\layout\shell.tsx
------------------------------------------------------------
import React from "react";

export function Sidebar() {
  return (
    <aside className="bg-slate-900 text-white w-64 min-h-screen p-4">
      <div className="flex items-center gap-2 mb-8">
        <div className="bg-blue-600 p-2 rounded-lg" />
        <div>
          <h1 className="text-xl font-bold">CWIC</h1>
          <p className="text-xs text-slate-400">Workflow Intelligence</p>
        </div>
      </div>
      <nav className="space-y-2">
        {["Dashboard","AI Assistant","Data Catalog","Data Quality","Pipelines","Requests","Connections","Settings"]
          .map((item) => (
          <button key={item}
            className="w-full text-left px-3 py-2 rounded-lg text-slate-300 hover:bg-slate-800">
            {item}
          </button>
        ))}
      </nav>
    </aside>
  );
}

export function Header() {
  return (
    <header className="bg-white border-b border-gray-200 px-6 py-4">
      <h2 className="text-2xl font-semibold">CWIC</h2>
    </header>
  );
}



------------------------------------------------------------
FILE: frontend\src\components\layout\Sidebar.tsx
------------------------------------------------------------
import { ReactNode } from "react";
export function Sidebar(){ return (
  <aside className="bg-slate-900 text-white w-64 min-h-screen p-4">
    <div className="font-bold text-xl mb-6">CWIC</div>
    <nav className="space-y-2">
      <a className="block hover:bg-slate-800 rounded px-3 py-2" href="/">Dashboard</a>
      <a className="block hover:bg-slate-800 rounded px-3 py-2" href="/ai">AI Assistant</a>
      <a className="block hover:bg-slate-800 rounded px-3 py-2" href="/pipelines">Pipelines</a>
    </nav>
  </aside>
)}


------------------------------------------------------------
FILE: frontend\src\components\ui\Badge.tsx
------------------------------------------------------------
import { cn } from '@utils'
import * as React from 'react'

type Tone = 'neutral' | 'info' | 'success' | 'warning' | 'danger'
type Variant = 'default' | 'secondary' | 'destructive' | 'outline'

export type BadgeProps = {
  children?: React.ReactNode
  className?: string
  /** Preferred API in this codebase */
  tone?: Tone
  /** Compatibility with shadcn/ui usage */
  variant?: Variant
}

function resolveTone({ tone, variant }: { tone?: Tone; variant?: Variant }): { tone: Tone; outline?: boolean } {
  if (tone) return { tone }
  if (!variant) return { tone: 'neutral' }
  if (variant === 'destructive') return { tone: 'danger' }
  if (variant === 'secondary') return { tone: 'info' }
  if (variant === 'default') return { tone: 'neutral' }
  if (variant === 'outline') return { tone: 'neutral', outline: true }
  return { tone: 'neutral' }
}

export const Badge: React.FC<BadgeProps> = ({ children, className, tone, variant }) => {
  const { tone: t, outline } = resolveTone({ tone, variant })

  const toneClasses =
    t === 'success'
      ? 'bg-green-100 text-green-800'
      : t === 'warning'
      ? 'bg-yellow-100 text-yellow-800'
      : t === 'danger'
      ? 'bg-red-100 text-red-800'
      : t === 'info'
      ? 'bg-blue-100 text-blue-800'
      : 'bg-gray-100 text-gray-800'

  const outlineClasses =
    outline ? 'bg-transparent border border-current text-gray-800' : toneClasses

  return (
    <span
      className={cn(
        'inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium',
        outlineClasses,
        className,
      )}
    >
      {children}
    </span>
  )
}

export default Badge



------------------------------------------------------------
FILE: frontend\src\components\ui\Button.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'

type Variant = 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger'
type Size = 'sm' | 'md' | 'lg' | 'icon'

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: Variant
  size?: Size
  isLoading?: boolean
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
}

const base =
  'inline-flex items-center justify-center rounded-2xl font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 disabled:opacity-60 disabled:pointer-events-none shadow-sm'

const variants: Record<Variant, string> = {
  primary: 'bg-blue-600 text-white hover:bg-blue-700',
  secondary: 'bg-gray-900 text-white hover:bg-black/90',
  outline:
    'border border-gray-300 bg-white text-gray-900 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-100 dark:hover:bg-gray-800',
  ghost: 'text-gray-800 hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-800/60',
  danger: 'bg-red-600 text-white hover:bg-red-700',
}

const sizes: Record<Size, string> = {
  sm: 'h-9 px-3 text-sm',
  md: 'h-10 px-4 text-sm',
  lg: 'h-11 px-5 text-base',
  icon: 'h-10 w-10',
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'primary', size = 'md', isLoading, leftIcon, rightIcon, children, ...props }, ref) => {
    const isIconOnly = size === 'icon'
    return (
      <button
        ref={ref}
        className={cn(base, variants[variant], sizes[size], className)}
        aria-busy={isLoading || undefined}
        {...props}
      >
        {!isIconOnly && leftIcon ? <span className="-ml-0.5 mr-2">{leftIcon}</span> : leftIcon}
        {isLoading ? <span className="animate-pulse">â€¦</span> : children}
        {!isIconOnly && rightIcon ? <span className="ml-2 -mr-0.5">{rightIcon}</span> : rightIcon}
      </button>
    )
  },
)
Button.displayName = 'Button'

export default Button



------------------------------------------------------------
FILE: frontend\src\components\ui\Card.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'

export interface CardProps extends React.HTMLAttributes<HTMLDivElement> {}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-2xl border border-gray-200 bg-white shadow-sm dark:border-gray-800 dark:bg-gray-900',
      className,
    )}
    {...props}
  />
))
Card.displayName = 'Card'

export const CardHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className={cn('p-6 pb-2', className)} {...props} />
)

export const CardTitle: React.FC<React.HTMLAttributes<HTMLHeadingElement>> = ({ className, ...props }) => (
  <h3 className={cn('text-lg font-semibold text-gray-900 dark:text-gray-100', className)} {...props} />
)

export const CardContent: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className={cn('p-6 pt-2', className)} {...props} />
)

export const CardFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className={cn('p-6 pt-0', className)} {...props} />
)

export default Card



------------------------------------------------------------
FILE: frontend\src\components\ui\index.ts
------------------------------------------------------------
export { Badge } from './Badge'
export { Button } from './Button'
export { Card, CardContent, CardFooter, CardHeader, CardTitle } from './Card'
export { Input } from './Input'
export { Modal } from './Modal'
export { Toaster, ToastProvider, useToast } from './Notification'
export { Select } from './Select'




------------------------------------------------------------
FILE: frontend\src\components\ui\Input.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  startIcon?: React.ReactNode
  endIcon?: React.ReactNode
  error?: string
}

export const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, startIcon, endIcon, error, ...props }, ref) => {
    return (
      <div className="relative">
        {startIcon ? <div className="absolute inset-y-0 left-0 flex items-center pl-3">{startIcon}</div> : null}
        <input
          ref={ref}
          className={cn(
            'block w-full rounded-2xl border bg-white px-4 py-2.5 text-sm text-gray-900 placeholder:text-gray-400 shadow-sm transition focus:outline-none focus:ring-2',
            error
              ? 'border-red-400 focus:ring-red-500'
              : 'border-gray-300 focus:border-blue-500 focus:ring-blue-500',
            startIcon && 'pl-10',
            endIcon && 'pr-10',
            className,
          )}
          aria-invalid={!!error || undefined}
          {...props}
        />
        {endIcon ? <div className="absolute inset-y-0 right-0 flex items-center pr-3">{endIcon}</div> : null}
        {error ? <p className="mt-1 text-xs text-red-600">{error}</p> : null}
      </div>
    )
  },
)
Input.displayName = 'Input'

export default Input



------------------------------------------------------------
FILE: frontend\src\components\ui\Modal.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'
import { createPortal } from 'react-dom'
import { Button } from './Button'

export interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title?: React.ReactNode
  footer?: React.ReactNode
  size?: 'sm' | 'md' | 'lg' | 'xl'
  children?: React.ReactNode
  closeOnBackdrop?: boolean
}

const sizes = {
  sm: 'max-w-md',
  md: 'max-w-lg',
  lg: 'max-w-2xl',
  xl: 'max-w-4xl',
}

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  footer,
  size = 'md',
  children,
  closeOnBackdrop = true,
}) => {
  const backdropRef = React.useRef<HTMLDivElement>(null)

  React.useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === 'Escape') onClose()
    }
    if (isOpen) document.addEventListener('keydown', onKey)
    return () => document.removeEventListener('keydown', onKey)
  }, [isOpen, onClose])

  if (!isOpen) return null

  return createPortal(
    <div
      ref={backdropRef}
      className="fixed inset-0 z-[1000] flex items-center justify-center bg-black/50 px-4"
      onMouseDown={(e) => {
        if (closeOnBackdrop && e.target === backdropRef.current) onClose()
      }}
      aria-modal="true"
      role="dialog"
    >
      <div
        className={cn(
          'w-full rounded-2xl bg-white shadow-xl outline-none ring-1 ring-black/5 dark:bg-gray-900',
          sizes[size],
        )}
      >
        {(title || onClose) && (
          <div className="flex items-center justify-between border-b border-gray-100 px-6 py-4">
            <div className="text-lg font-semibold text-gray-900">{title}</div>
            <Button variant="ghost" size="icon" aria-label="Close" onClick={onClose}>
              âœ•
            </Button>
          </div>
        )}
        <div className="px-6 py-5">{children}</div>
        {footer && <div className="border-t border-gray-100 px-6 py-4">{footer}</div>}
      </div>
    </div>,
    document.body,
  )
}



------------------------------------------------------------
FILE: frontend\src\components\ui\Notification.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'

type ToastType = 'info' | 'success' | 'warning' | 'error'

export interface Toast {
  id: string
  type: ToastType
  title?: string
  message: string
  duration?: number // ms
}

interface ToastContextValue {
  push: (t: Omit<Toast, 'id'>) => void
  remove: (id: string) => void
}

const ToastContext = React.createContext<ToastContextValue | undefined>(undefined)

export const useToast = () => {
  const ctx = React.useContext(ToastContext)
  if (!ctx) throw new Error('useToast must be used within ToastProvider')
  return ctx
}

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [toasts, setToasts] = React.useState<Toast[]>([])

  const remove = React.useCallback((id: string) => {
    setToasts((s) => s.filter((t) => t.id !== id))
  }, [])

  const push = React.useCallback(
    (t: Omit<Toast, 'id'>) => {
      const id = crypto.randomUUID()
      const toast: Toast = { id, duration: 4500, ...t }
      setToasts((s) => [...s, toast])
      if (toast.duration && toast.duration > 0) {
        window.setTimeout(() => remove(id), toast.duration)
      }
    },
    [remove],
  )

  return (
    <ToastContext.Provider value={{ push, remove }}>
      {children}
      <Toaster toasts={toasts} onDismiss={remove} />
    </ToastContext.Provider>
  )
}

export const Toaster: React.FC<{ toasts?: Toast[]; onDismiss?: (id: string) => void }> = ({
  toasts = [],
  onDismiss = () => {},
}) => {
  return (
    <div className="pointer-events-none fixed inset-0 z-[1100] flex flex-col items-end gap-2 p-4">
      {toasts.map((t) => (
        <div
          key={t.id}
          className={cn(
            'pointer-events-auto w-full max-w-sm rounded-xl border px-4 py-3 shadow-lg backdrop-blur-sm',
            t.type === 'success' && 'border-green-200 bg-green-50 text-green-900',
            t.type === 'info' && 'border-blue-200 bg-blue-50 text-blue-900',
            t.type === 'warning' && 'border-yellow-200 bg-yellow-50 text-yellow-900',
            t.type === 'error' && 'border-red-200 bg-red-50 text-red-900',
          )}
          role="status"
        >
          <div className="flex items-start gap-3">
            <div className="text-lg leading-none">{iconFor(t.type)}</div>
            <div className="flex-1">
              {t.title ? <div className="text-sm font-semibold">{t.title}</div> : null}
              <div className="text-sm">{t.message}</div>
            </div>
            <button
              className="ml-2 rounded-md p-1 text-xs opacity-70 hover:opacity-100"
              aria-label="Dismiss"
              onClick={() => onDismiss(t.id)}
            >
              âœ•
            </button>
          </div>
        </div>
      ))}
    </div>
  )
}

function iconFor(type: ToastType) {
  switch (type) {
    case 'success':
      return 'âœ“'
    case 'warning':
      return 'âš '
    case 'error':
      return 'â¨¯'
    default:
      return 'â„¹'
  }
}



------------------------------------------------------------
FILE: frontend\src\components\ui\Select.tsx
------------------------------------------------------------
import { cn } from '@/utils'
import * as React from 'react'

export interface SelectOption {
  label: string
  value: string | number
  disabled?: boolean
}

export interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {
  label?: string
  options: SelectOption[]
  error?: string
}

export const Select = React.forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, label, options, error, ...props }, ref) => {
    return (
      <label className="block">
        {label ? <span className="mb-1 block text-sm font-medium text-gray-700">{label}</span> : null}
        <select
          ref={ref}
          className={cn(
            'block w-full rounded-2xl border bg-white px-4 py-2.5 text-sm text-gray-900 shadow-sm focus:outline-none focus:ring-2',
            error ? 'border-red-400 focus:ring-red-500' : 'border-gray-300 focus:ring-blue-500',
            className,
          )}
          {...props}
        >
          {options.map((o) => (
            <option key={`${o.value}`} value={o.value} disabled={o.disabled}>
              {o.label}
            </option>
          ))}
        </select>
        {error ? <p className="mt-1 text-xs text-red-600">{error}</p> : null}
      </label>
    )
  },
)
Select.displayName = 'Select'

export default Select



------------------------------------------------------------
FILE: frontend\src\config\api.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\config\auth.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\config\database.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\config\environment.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\config\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\hooks\index.ts
------------------------------------------------------------
export { default as useAuth } from './useAuth';
export { default as useNotifications } from './useNotifications';
export { default as useDataSources } from './useDataSources';
export { default as useDataAssets } from './useDataAssets';
export { default as useQualityRules } from './useQualityRules';
export { default as usePipelines } from './usePipelines';
export { default as useRequests } from './useRequests';
export { default as useAIChat } from './useAIChat';
export { default as useLocalStorage } from './useLocalStorage';
export { default as useDebounce } from './useDebounce';



------------------------------------------------------------
FILE: frontend\src\hooks\useAIChat.ts
------------------------------------------------------------
import { useCallback, useEffect, useRef, useState } from 'react';
import { aiAssistantService } from '../services/api/aiAssistant';

// Type-only imports
import type { AIMessage } from '../components/features/ai-assistant/MessageBubble';
import type { AIResponse } from '../services/api/aiAssistant';

type ConnStatus = 'connected' | 'disconnected' | 'connecting';

interface UseAIChatReturn {
  messages: AIMessage[];
  loading: boolean;
  connected: boolean;
  error: string | null;
  sendMessage: (content: string) => Promise<void>;
  clearMessages: () => void;
  retryLastMessage: () => void;
  isTyping: boolean;
  connectionStatus: ConnStatus;
}

const uid = () =>
  (globalThis.crypto?.randomUUID?.() ?? '') ||
  `id_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

export const useAIChat = (): UseAIChatReturn => {
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [loading, setLoading] = useState(false);
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isTyping, setIsTyping] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnStatus>('disconnected');

  const abortControllerRef = useRef<AbortController | null>(null);
  const connectionCheckIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const mountedRef = useRef(true);

  // Track last user message content for reliable retry
  const lastUserMessageRef = useRef<string | null>(null);

  // ---- Connection checks
  const checkConnection = useCallback(async () => {
    try {
      // Only show â€œconnectingâ€ when we donâ€™t already know weâ€™re connected
      setConnectionStatus((prev) => (prev === 'connected' ? 'connected' : 'connecting'));
      const isConnected = await aiAssistantService.isConnected();
      if (!mountedRef.current) return;

      setConnected(isConnected);
      setConnectionStatus(isConnected ? 'connected' : 'disconnected');
    } catch (err) {
      if (!mountedRef.current) return;
      console.warn('Connection check failed:', err);
      setConnected(false);
      setConnectionStatus('disconnected');
    }
  }, []);

  useEffect(() => {
    mountedRef.current = true;

    // Initial check (donâ€™t await to avoid blocking render)
    void checkConnection();

    // Periodic checks
    connectionCheckIntervalRef.current = setInterval(checkConnection, 10_000);

    return () => {
      mountedRef.current = false;
      if (connectionCheckIntervalRef.current) clearInterval(connectionCheckIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
    };
  }, [checkConnection]);

  // ---- Send message
  const sendMessage = useCallback(async (content: string): Promise<void> => {
    const trimmedContent = content?.trim();
    if (!trimmedContent) return;

    // Cancel any ongoing request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    const userMessage: AIMessage = {
      id: `user_${uid()}`,
      type: 'user',
      content: trimmedContent,
      timestamp: new Date()
    };

    // Update last user content for retry
    lastUserMessageRef.current = trimmedContent;

    // Push user message immediately
    setMessages((prev) => [...prev, userMessage]);
    setLoading(true);
    setIsTyping(true);
    setError(null);

    try {
      abortControllerRef.current = new AbortController();
      const signal = abortControllerRef.current.signal;

      const startTime = performance.now();

      // Build options and pass signal if service supports it
      const opts: any = { requestId: userMessage.id };
      if (signal) opts.signal = signal;

      const response: AIResponse = await aiAssistantService.sendMessageWithFallback(
        trimmedContent,
        opts
      );

      const processingTime = Math.round(performance.now() - startTime);
      if (!mountedRef.current) return;

      if (response?.success && response.data) {
        const assistantMessage: AIMessage = {
          id: `assistant_${uid()}`,
          type: 'assistant',
          content: response.data.message,
          timestamp: new Date(),
          metadata: {
            processingTime,
            // default confidence if not provided
            confidence: response.meta?.confidence ?? 0.9,
            // prefer explicit sources from service, else a generic marker if results exist
            sources: response.data.sources ?? (response.data.results ? ['AI Analysis'] : undefined)
          }
        };
        setMessages((prev) => [...prev, assistantMessage]);
        setConnected(true);
        setConnectionStatus('connected');
      } else {
        const errMsg = response?.error?.message || 'Failed to get response from AI service';
        setError(errMsg);

        const errorAssistantMessage: AIMessage = {
          id: `error_${uid()}`,
          type: 'assistant',
          content: `Sorry, I encountered an error: ${errMsg}. Please try again.`,
          timestamp: new Date(),
          metadata: {
            processingTime,
            confidence: 0,
            sources: ['Error Handler']
          }
        };
        setMessages((prev) => [...prev, errorAssistantMessage]);
      }
    } catch (err: unknown) {
      if (!mountedRef.current) return;

      const e = err as Error;
      if (e.name !== 'AbortError') {
        const errMsg = e.message || 'An unexpected error occurred';
        setError(errMsg);

        console.error('AI Chat Error:', {
          message: errMsg,
          stack: e.stack,
          userMessage: lastUserMessageRef.current,
          timestamp: new Date().toISOString()
        });

        // Surface a readable assistant message on unexpected errors
        setMessages((prev) => [
          ...prev,
          {
            id: `error_${uid()}`,
            type: 'assistant',
            content: `âš ï¸ ${errMsg}`,
            timestamp: new Date(),
            metadata: { sources: ['Client Error'] }
          }
        ]);
      }
    } finally {
      if (!mountedRef.current) return;
      setLoading(false);
      setIsTyping(false);
      abortControllerRef.current = null;
    }
  }, []);

  // ---- Clear
  const clearMessages = useCallback((): void => {
    setMessages([]);
    setError(null);
    lastUserMessageRef.current = null;

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }

    setLoading(false);
    setIsTyping(false);
  }, []);

  // ---- Retry last user message
  const retryLastMessage = useCallback((): void => {
    const lastContent =
      lastUserMessageRef.current ||
      // fallback if ref is empty: find most recent user message from state
      (messages.length
        ? [...messages].reverse().find((m) => m.type === 'user')?.content ?? null
        : null);

    if (!lastContent) {
      console.warn('No user message found to retry');
      return;
    }

    // If the last bubble is an assistant error/partial, remove it before retry
    setMessages((prev) => {
      if (!prev.length) return prev;
      const last = prev[prev.length - 1];
      if (last.type === 'assistant') {
        return prev.slice(0, -1);
      }
      return prev;
    });

    void sendMessage(lastContent);
  }, [messages, sendMessage]);

  return {
    messages,
    loading,
    connected,
    error,
    sendMessage,
    clearMessages,
    retryLastMessage,
    isTyping,
    connectionStatus
  };
};

// Export the hook type
export type { UseAIChatReturn };




------------------------------------------------------------
FILE: frontend\src\hooks\useAuth.ts
------------------------------------------------------------
import * as React from 'react'

type User = {
  id: string
  name: string
  email: string
  roles?: string[]
}

type AuthState = {
  user: User | null
  token: string | null
  loading: boolean
}

type LoginInput =
  | { email: string; password: string }
  | { username: string; password: string }

export type AuthContextValue = {
  user: User | null
  token: string | null
  loading: boolean
  isAuthenticated: boolean
  login: (input: LoginInput) => Promise<void>
  logout: () => void
  setUser: (u: User | null) => void
  refreshUser: () => Promise<void>
}

const AuthContext = React.createContext<AuthContextValue | undefined>(undefined)

const LS_USER = 'auth.user'
const LS_TOKEN = 'auth.token'

async function api<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(path, {
    credentials: 'include',
    ...init,
    headers: {
      'Content-Type': 'application/json',
      ...(init?.headers || {}),
    },
  })
  if (!res.ok) {
    const text = await res.text().catch(() => '')
    throw new Error(text || `HTTP ${res.status}`)
  }
  return (await res.json()) as T
}

export function AuthProvider(props: { children?: React.ReactNode }): React.ReactElement {
  const [state, setState] = React.useState<AuthState>(() => {
    const token = localStorage.getItem(LS_TOKEN)
    const userRaw = localStorage.getItem(LS_USER)
    const user = userRaw ? (JSON.parse(userRaw) as User) : null
    return { user, token, loading: !!token && !user }
  })

  const persist = React.useCallback((user: User | null, token: string | null) => {
    if (user) localStorage.setItem(LS_USER, JSON.stringify(user))
    else localStorage.removeItem(LS_USER)

    if (token) localStorage.setItem(LS_TOKEN, token)
    else localStorage.removeItem(LS_TOKEN)
  }, [])

  const refreshUser = React.useCallback(async () => {
    if (!state.token) return
    try {
      setState((s) => ({ ...s, loading: true }))
      const me = await api<User>('/api/auth/me')
      setState((s) => ({ ...s, user: me, loading: false }))
      persist(me, state.token)
    } catch {
      setState({ user: null, token: null, loading: false })
      persist(null, null)
    }
  }, [state.token, persist])

  const login = React.useCallback(
    async (input: LoginInput) => {
      setState((s) => ({ ...s, loading: true }))
      const result = await api<{ token: string; user: User }>('/api/auth/login', {
        method: 'POST',
        body: JSON.stringify(input),
      })
      persist(result.user, result.token)
      setState({ user: result.user, token: result.token, loading: false })
    },
    [persist],
  )

  const logout = React.useCallback(() => {
    // Optionally inform backend: void api('/api/auth/logout', { method: 'POST' }).catch(() => {})
    persist(null, null)
    setState({ user: null, token: null, loading: false })
  }, [persist])

  const setUser = React.useCallback(
    (u: User | null) => {
      setState((s) => ({ ...s, user: u }))
      persist(u, state.token)
    },
    [persist, state.token],
  )

  React.useEffect(() => {
    if (state.token && !state.user) {
      void refreshUser()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const value: AuthContextValue = React.useMemo(
    () => ({
      user: state.user,
      token: state.token,
      loading: state.loading,
      isAuthenticated: !!state.token && !!state.user,
      login,
      logout,
      setUser,
      refreshUser,
    }),
    [state.user, state.token, state.loading, login, logout, setUser, refreshUser],
  )

  // No JSX: return createElement
  return React.createElement(AuthContext.Provider, { value }, props.children)
}

export function useAuth(): AuthContextValue {
  const ctx = React.useContext(AuthContext)
  if (!ctx) throw new Error('useAuth must be used within <AuthProvider>')
  return ctx
}



------------------------------------------------------------
FILE: frontend\src\hooks\useDataAssets.ts
------------------------------------------------------------
// src/hooks/useDataAssets.ts
import { dataAssetsApi } from '@/services/api/dataAssets';
import type {
  Asset,
  AssetFilters,
  AssetLineage,
  AssetProfile,
  AssetUsageStats,
  CreateAssetRequest,
  PaginatedAssets,
  UpdateAssetRequest
} from '@/types/dataAssets';
import { useCallback, useEffect, useMemo, useState } from 'react';

interface UseDataAssetsOptions {
  autoFetch?: boolean;
  defaultFilters?: AssetFilters;
}

export function useDataAssets(options: UseDataAssetsOptions = {}) {
  const { autoFetch = true, defaultFilters = {} } = options;

  // State
  const [assets, setAssets] = useState<Asset[]>([]);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20,
    total: 0,
    totalPages: 0
  });
  const [filters, setFilters] = useState<AssetFilters>(defaultFilters);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Asset details cache
  const [assetDetails, setAssetDetails] = useState<Map<string, Asset>>(new Map());
  const [assetProfiles, setAssetProfiles] = useState<Map<string, AssetProfile>>(new Map());
  const [assetLineage, setAssetLineage] = useState<Map<string, AssetLineage>>(new Map());
  const [assetUsage, setAssetUsage] = useState<Map<string, AssetUsageStats>>(new Map());

  // Operation states
  const [operationStates, setOperationStates] = useState({
    creating: false,
    updating: new Set<string>(),
    deleting: new Set<string>(),
    profiling: new Set<string>()
  });

  // Fetch assets
  const fetchAssets = useCallback(async (newFilters?: AssetFilters, silent: boolean = false) => {
    const currentFilters = newFilters || filters;
    
    if (!silent) {
      setIsLoading(true);
      setError(null);
    }

    try {
      const response: PaginatedAssets = await dataAssetsApi.list(currentFilters);
      
      setAssets(response.data);
      setPagination(response.pagination);
      
      if (newFilters) {
        setFilters(currentFilters);
      }
    } catch (err: any) {
      console.error('Failed to fetch assets:', err);
      setError(err.message || 'Failed to fetch assets');
      setAssets([]);
      setPagination({ page: 1, limit: 20, total: 0, totalPages: 0 });
    } finally {
      if (!silent) {
        setIsLoading(false);
      }
    }
  }, [filters]);

  // Auto-fetch on mount and filter changes
  useEffect(() => {
    if (autoFetch) {
      fetchAssets();
    }
  }, [fetchAssets, autoFetch]);

  // Refresh assets
  const refresh = useCallback(() => {
    fetchAssets(undefined, false);
  }, [fetchAssets]);

  // Update filters
  const updateFilters = useCallback((newFilters: Partial<AssetFilters>) => {
    const updatedFilters = { ...filters, ...newFilters, page: 1 }; // Reset to first page
    fetchAssets(updatedFilters);
  }, [filters, fetchAssets]);

  // Clear filters
  const clearFilters = useCallback(() => {
    const clearedFilters: AssetFilters = { page: 1, limit: filters.limit || 20 };
    fetchAssets(clearedFilters);
  }, [filters.limit, fetchAssets]);

  // Pagination
  const goToPage = useCallback((page: number) => {
    updateFilters({ page });
  }, [updateFilters]);

  const nextPage = useCallback(() => {
    if (pagination.page < pagination.totalPages) {
      goToPage(pagination.page + 1);
    }
  }, [pagination.page, pagination.totalPages, goToPage]);

  const prevPage = useCallback(() => {
    if (pagination.page > 1) {
      goToPage(pagination.page - 1);
    }
  }, [pagination.page, goToPage]);

  // Get single asset (with caching)
  const getAsset = useCallback(async (id: string, forceRefresh: boolean = false): Promise<Asset | null> => {
    if (!forceRefresh && assetDetails.has(id)) {
      return assetDetails.get(id) || null;
    }

    try {
      const asset = await dataAssetsApi.getById(id);
      setAssetDetails(prev => new Map(prev).set(id, asset));
      return asset;
    } catch (err: any) {
      console.error(`Failed to fetch asset ${id}:`, err);
      return null;
    }
  }, [assetDetails]);

  // Create asset
  const createAsset = useCallback(async (assetData: CreateAssetRequest): Promise<Asset> => {
    setOperationStates(prev => ({ ...prev, creating: true }));
    
    try {
      const newAsset = await dataAssetsApi.create(assetData);
      
      // Add to current list if it matches filters
      setAssets(prev => [newAsset, ...prev]);
      setPagination(prev => ({ ...prev, total: prev.total + 1 }));
      
      return newAsset;
    } catch (err: any) {
      console.error('Failed to create asset:', err);
      throw err;
    } finally {
      setOperationStates(prev => ({ ...prev, creating: false }));
    }
  }, []);

  // Update asset
  const updateAsset = useCallback(async (id: string, updates: UpdateAssetRequest): Promise<Asset> => {
    setOperationStates(prev => ({
      ...prev,
      updating: new Set(prev.updating).add(id)
    }));
    
    try {
      const updatedAsset = await dataAssetsApi.update(id, updates);
      
      // Update in current list
      setAssets(prev => prev.map(asset => 
        asset.id === id ? updatedAsset : asset
      ));
      
      // Update cache
      setAssetDetails(prev => new Map(prev).set(id, updatedAsset));
      
      return updatedAsset;
    } catch (err: any) {
      console.error(`Failed to update asset ${id}:`, err);
      throw err;
    } finally {
      setOperationStates(prev => {
        const newUpdating = new Set(prev.updating);
        newUpdating.delete(id);
        return { ...prev, updating: newUpdating };
      });
    }
  }, []);

  // Delete asset
  const deleteAsset = useCallback(async (id: string): Promise<void> => {
    setOperationStates(prev => ({
      ...prev,
      deleting: new Set(prev.deleting).add(id)
    }));
    
    try {
      await dataAssetsApi.delete(id);
      
      // Remove from current list
      setAssets(prev => prev.filter(asset => asset.id !== id));
      setPagination(prev => ({ ...prev, total: Math.max(0, prev.total - 1) }));
      
      // Clear from cache
      setAssetDetails(prev => {
        const newMap = new Map(prev);
        newMap.delete(id);
        return newMap;
      });
      
    } catch (err: any) {
      console.error(`Failed to delete asset ${id}:`, err);
      throw err;
    } finally {
      setOperationStates(prev => {
        const newDeleting = new Set(prev.deleting);
        newDeleting.delete(id);
        return { ...prev, deleting: newDeleting };
      });
    }
  }, []);

  // Get asset profile
  const getAssetProfile = useCallback(async (id: string, forceRefresh: boolean = false): Promise<AssetProfile | null> => {
    if (!forceRefresh && assetProfiles.has(id)) {
      return assetProfiles.get(id) || null;
    }

    try {
      const profile = await dataAssetsApi.getProfile(id);
      setAssetProfiles(prev => new Map(prev).set(id, profile));
      return profile;
    } catch (err: any) {
      console.error(`Failed to fetch profile for asset ${id}:`, err);
      return null;
    }
  }, [assetProfiles]);

  // Get asset lineage
  const getAssetLineage = useCallback(async (id: string, forceRefresh: boolean = false): Promise<AssetLineage | null> => {
    if (!forceRefresh && assetLineage.has(id)) {
      return assetLineage.get(id) || null;
    }

    try {
      const lineage = await dataAssetsApi.getLineage(id);
      setAssetLineage(prev => new Map(prev).set(id, lineage));
      return lineage;
    } catch (err: any) {
      console.error(`Failed to fetch lineage for asset ${id}:`, err);
      return null;
    }
  }, [assetLineage]);

  // Get asset usage stats
  const getAssetUsage = useCallback(async (id: string, period: string = '30d', forceRefresh: boolean = false): Promise<AssetUsageStats | null> => {
    const cacheKey = `${id}-${period}`;
    if (!forceRefresh && assetUsage.has(cacheKey)) {
      return assetUsage.get(cacheKey) || null;
    }

    try {
      const usage = await dataAssetsApi.getUsageStats(id, period);
      setAssetUsage(prev => new Map(prev).set(cacheKey, usage));
      return usage;
    } catch (err: any) {
      console.error(`Failed to fetch usage stats for asset ${id}:`, err);
      return null;
    }
  }, [assetUsage]);

  // Tag management
  const addTags = useCallback(async (id: string, tags: string[]): Promise<Asset> => {
    try {
      const updatedAsset = await dataAssetsApi.addTags(id, tags);
      
      // Update in current list
      setAssets(prev => prev.map(asset => 
        asset.id === id ? updatedAsset : asset
      ));
      
      // Update cache
      setAssetDetails(prev => new Map(prev).set(id, updatedAsset));
      
      return updatedAsset;
    } catch (err: any) {
      console.error(`Failed to add tags to asset ${id}:`, err);
      throw err;
    }
  }, []);

  const removeTags = useCallback(async (id: string, tags: string[]): Promise<Asset> => {
    try {
      const updatedAsset = await dataAssetsApi.removeTags(id, tags);
      
      // Update in current list
      setAssets(prev => prev.map(asset => 
        asset.id === id ? updatedAsset : asset
      ));
      
      // Update cache
      setAssetDetails(prev => new Map(prev).set(id, updatedAsset));
      
      return updatedAsset;
    } catch (err: any) {
      console.error(`Failed to remove tags from asset ${id}:`, err);
      throw err;
    }
  }, []);

  // Request access to asset
  const requestAccess = useCallback(async (id: string, reason?: string): Promise<{ requestId: string; status: string }> => {
    try {
      return await dataAssetsApi.requestAccess(id, reason);
    } catch (err: any) {
      console.error(`Failed to request access to asset ${id}:`, err);
      throw err;
    }
  }, []);

  // Trigger asset profiling
  const triggerProfiling = useCallback(async (id: string): Promise<{ jobId: string; status: string }> => {
    setOperationStates(prev => ({
      ...prev,
      profiling: new Set(prev.profiling).add(id)
    }));
    
    try {
      const result = await dataAssetsApi.triggerProfiling(id);
      
      // Optionally refresh the asset profile after a delay
      setTimeout(() => {
        getAssetProfile(id, true);
      }, 5000);
      
      return result;
    } catch (err: any) {
      console.error(`Failed to trigger profiling for asset ${id}:`, err);
      throw err;
    } finally {
      setTimeout(() => {
        setOperationStates(prev => {
          const newProfiling = new Set(prev.profiling);
          newProfiling.delete(id);
          return { ...prev, profiling: newProfiling };
        });
      }, 2000); // Keep loading state for a bit
    }
  }, [getAssetProfile]);

  // Computed values
  const isEmpty = useMemo(() => !isLoading && assets.length === 0, [isLoading, assets.length]);
  const hasFilters = useMemo(() => {
    return Boolean(
      filters.search ||
      filters.type ||
      filters.owner ||
      filters.dataSourceId ||
      (filters.tags && filters.tags.length > 0) ||
      filters.quality ||
      filters.classification
    );
  }, [filters]);

  const totalAssets = pagination.total;
  const hasMore = pagination.page < pagination.totalPages;
  const hasPrev = pagination.page > 1;

  // Summary statistics
  const summary = useMemo(() => {
    const stats = {
      total: totalAssets,
      byType: {} as Record<string, number>,
      byQuality: { high: 0, medium: 0, low: 0 },
      byClassification: { public: 0, internal: 0, confidential: 0, restricted: 0 }
    };

    assets.forEach(asset => {
      // Count by type
      stats.byType[asset.type] = (stats.byType[asset.type] || 0) + 1;
      
      // Count by quality
      if (asset.quality) {
        stats.byQuality[asset.quality]++;
      }
      
      // Count by classification
      if (asset.classification) {
        stats.byClassification[asset.classification]++;
      }
    });

    return stats;
  }, [assets, totalAssets]);

  // Operation state helpers
  const isCreating = operationStates.creating;
  const isUpdating = useCallback((id: string) => operationStates.updating.has(id), [operationStates.updating]);
  const isDeleting = useCallback((id: string) => operationStates.deleting.has(id), [operationStates.deleting]);
  const isProfiling = useCallback((id: string) => operationStates.profiling.has(id), [operationStates.profiling]);

  return {
    // Data
    assets,
    pagination,
    filters,
    summary,
    
    // State
    isLoading,
    error,
    isEmpty,
    hasFilters,
    hasMore,
    hasPrev,
    
    // Operations
    fetchAssets,
    refresh,
    updateFilters,
    clearFilters,
    
    // Pagination
    goToPage,
    nextPage,
    prevPage,
    
    // Asset CRUD
    getAsset,
    createAsset,
    updateAsset,
    deleteAsset,
    
    // Asset details
    getAssetProfile,
    getAssetLineage,
    getAssetUsage,
    
    // Tag management
    addTags,
    removeTags,
    
    // Access and governance
    requestAccess,
    triggerProfiling,
    
    // Operation states
    isCreating,
    isUpdating,
    isDeleting,
    isProfiling,
    
    // Cache
    assetDetails,
    assetProfiles,
    assetLineage,
    assetUsage,
  };
}


------------------------------------------------------------
FILE: frontend\src\hooks\useDataSources.ts
------------------------------------------------------------
// src/hooks/useDataSources.ts
import { useCallback, useEffect, useMemo, useState } from 'react';

import {
  createDataSource,
  deleteDataSource,
  listDataSources,
  syncDataSource,
  testDataSource,
} from '@/services/api/dataSources';

import type {
  ConnectionTestResult,
  CreateDataSourcePayload,
  DataSource,
  DataSourceStatus,
  DataSourceType,
  PaginatedDataSources,
  SyncResult,
} from '@/types/dataSources';

import { toUserMessage } from '@/services/httpError';

/* ------------------------------------------------------------------ */
/* Query params (match what your backend actually accepts)            */
/* ------------------------------------------------------------------ */
type SortKey = 'name' | 'type' | 'status' | 'createdAt' | 'updatedAt';

interface ListParams {
  page?: number;
  limit?: number;
  sortBy?: SortKey;
  sortOrder?: 'asc' | 'desc';
  status?: string;        // NOTE: send server values here
  type?: DataSourceType;
}

/* ------------------------------------------------------------------ */
/* Local summary model                                                */
/* ------------------------------------------------------------------ */
interface DataSourceSummary {
  total: number;
  healthy: number;
  warning: number;
  error: number;
}

/* Track per-item operations without mutating `status` to fake values */
interface OperationState {
  testing: Set<string>;
  syncing: Set<string>;
  deleting: Set<string>;
}

/* --------------------------- status mapping ------------------------ */
// UI -> API
function toServerStatus(s: DataSourceStatus | ''): string | undefined {
  if (!s) return undefined;
  if (s === 'active') return 'connected';
  if (s === 'inactive') return 'disconnected';
  // pending/testing/error exist on both sides; pass through
  return s;
}

// API -> UI
function toUiStatus(s: string | undefined): DataSourceStatus {
  switch (s) {
    case 'connected': return 'active';
    case 'disconnected': return 'inactive';
    case 'warning': return 'pending';
    case 'syncing': return 'testing';
    case 'pending':
    case 'testing':
    case 'error':
    case 'active':
    case 'inactive':
      return s as DataSourceStatus;
    default:
      // unknown -> treat as pending (neutral)
      return 'pending';
  }
}

function normalizeFromServer(ds: any): DataSource {
  return {
    ...ds,
    status: toUiStatus(ds?.status),
  } as DataSource;
}

export function useDataSources() {
  /* ------------------------------ data ----------------------------- */
  const [items, setItems] = useState<DataSource[]>([]);
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(20);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(0);

  /* Single-value filters (UI values) */
  const [status, setStatus] = useState<DataSourceStatus | ''>('');
  const [type, setType] = useState<DataSourceType | ''>('');

  /* ---------------------------- ui state --------------------------- */
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  /* per-card operation state */
  const [ops, setOps] = useState<OperationState>({
    testing: new Set(),
    syncing: new Set(),
    deleting: new Set(),
  });

  /* last known operation results */
  const [lastTests, setLastTests] = useState<Map<string, ConnectionTestResult>>(new Map());
  const [lastSyncs, setLastSyncs] = useState<Map<string, SyncResult>>(new Map());

  /* --------------------------- list params ------------------------- */
  const listParams = useMemo<ListParams>(() => {
    const p: ListParams = {
      page,
      limit,
      sortBy: 'updatedAt',
      sortOrder: 'desc',
    };
    // map UI -> API before sending
    const sv = toServerStatus(status);
    if (sv) p.status = sv;
    if (type) p.type = type;
    return p;
  }, [page, limit, status, type]);

  /* --------------------------- small helpers ----------------------- */
  const setOp = useCallback((kind: keyof OperationState, id: string, active: boolean) => {
    setOps(prev => {
      const next: OperationState = {
        testing: new Set(prev.testing),
        syncing: new Set(prev.syncing),
        deleting: new Set(prev.deleting),
      };
      const set = next[kind];
      if (active) set.add(id); else set.delete(id);
      return next;
    });
  }, []);

  const updateItem = useCallback((id: string, patch: Partial<DataSource>) => {
    setItems(prev => prev.map(ds => (ds.id === id ? { ...ds, ...patch } : ds)));
  }, []);

  /* ----------------------------- actions --------------------------- */
  const refresh = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const res: PaginatedDataSources = await listDataSources(listParams);
      // map API -> UI statuses on the way in
      const normalized = res.data.map(normalizeFromServer);
      setItems(normalized);
      setTotal(res.pagination.total);
      setTotalPages(res.pagination.totalPages);
    } catch (e: any) {
      setError(toUserMessage(e));
      setItems([]);
      setTotal(0);
      setTotalPages(0);
    } finally {
      setLoading(false);
    }
  }, [listParams]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  const create = useCallback(
    async (draft: CreateDataSourcePayload) => {
      const created = await createDataSource(draft);
      await refresh();
      return created;
    },
    [refresh],
  );

  const remove = useCallback(
    async (id: string) => {
      setOp('deleting', id, true);
      try {
        await deleteDataSource(id);
        setItems(prev => prev.filter(x => x.id !== id));
        setTotal(t => Math.max(0, t - 1));
        setLastTests(prev => {
          const m = new Map(prev);
          m.delete(id);
          return m;
        });
        setLastSyncs(prev => {
          const m = new Map(prev);
          m.delete(id);
          return m;
        });
      } catch (e: any) {
        await refresh();
        throw new Error(toUserMessage(e));
      } finally {
        setOp('deleting', id, false);
      }
    },
    [refresh, setOp],
  );

  const test = useCallback(
    async (id: string): Promise<ConnectionTestResult> => {
      setOp('testing', id, true);
      // optimistic cue
      updateItem(id, { status: 'testing' });

      try {
        const result = await testDataSource(id);
        setLastTests(prev => new Map(prev).set(id, result));

        const ok =
          (result as any)?.connectionStatus === 'connected' ||
          (result as any)?.success === true;

        updateItem(id, {
          status: ok ? 'active' : 'error',
          ...(result as any)?.testedAt
            ? ({ lastTestAt: (result as any).testedAt } as any)
            : ({ lastTestAt: new Date().toISOString() } as any),
        });

        return result;
      } catch (e: any) {
        const msg = toUserMessage(e);
        setLastTests(prev =>
          new Map(prev).set(id, {
            success: false,
            message: msg,
          } as unknown as ConnectionTestResult),
        );
        updateItem(id, {
          status: 'error',
          ...( { lastTestAt: new Date().toISOString() } as any),
        });
        throw new Error(msg);
      } finally {
        setOp('testing', id, false);
      }
    },
    [setOp, updateItem],
  );

  const sync = useCallback(
    async (id: string): Promise<SyncResult> => {
      setOp('syncing', id, true);
      try {
        const result = await syncDataSource(id);
        setLastSyncs(prev => new Map(prev).set(id, result));

        updateItem(id, {
          ...(result.completedAt
            ? ({ lastSyncAt: result.completedAt } as any)
            : ({ lastSyncAt: new Date().toISOString() } as any)),
        });

        return result;
      } catch (e: any) {
        const msg = toUserMessage(e);
        setLastSyncs(prev =>
          new Map(prev).set(id, {
            syncId: `error-${Date.now()}`,
            status: 'failed',
            tablesScanned: 0,
            newTables: 0,
            updatedTables: 0,
            errors: [msg],
            startedAt: new Date().toISOString(),
          }),
        );
        throw new Error(msg);
      } finally {
        setOp('syncing', id, false);
      }
    },
    [setOp, updateItem],
  );

  /* --------------------------- batch helpers ----------------------- */
  const testMultiple = useCallback(async (ids: string[]) => {
    await Promise.allSettled(ids.map(id => test(id)));
    return new Map(lastTests);
  }, [test, lastTests]);

  const syncMultiple = useCallback(async (ids: string[]) => {
    await Promise.allSettled(ids.map(id => sync(id)));
    return new Map(lastSyncs);
  }, [sync, lastSyncs]);

  /* ----------------------------- summary --------------------------- */
  const summary = useMemo<DataSourceSummary>(() => {
    const s: DataSourceSummary = { total, healthy: 0, warning: 0, error: 0 };
    for (const ds of items) {
      if (ds.status === 'active') s.healthy += 1;
      else if (ds.status === 'error') s.error += 1;
      else if (ds.status === 'pending' || ds.status === 'testing') s.warning += 1;
    }
    return s;
  }, [items, total]);

  /* ------------------------------ getters -------------------------- */
  const getDataSourceById = useCallback(
    (id: string) => items.find(d => d.id === id),
    [items],
  );

  const clearFilters = useCallback(() => {
    setStatus('');
    setType('');
    setPage(1);
  }, []);

  /* --------------------------- selectors --------------------------- */
  const isDataSourceTesting = useCallback((id: string) => ops.testing.has(id), [ops.testing]);
  const isDataSourceSyncing = useCallback((id: string) => ops.syncing.has(id), [ops.syncing]);
  const isDataSourceDeleting = useCallback((id: string) => ops.deleting.has(id), [ops.deleting]);

  const getLastTestResult = useCallback((id: string) => lastTests.get(id), [lastTests]);
  const getLastSyncResult = useCallback((id: string) => lastSyncs.get(id), [lastSyncs]);

  const clearTestResult = useCallback((id: string) => {
    setLastTests(prev => {
      const m = new Map(prev);
      m.delete(id);
      return m;
    });
  }, []);

  const clearSyncResult = useCallback((id: string) => {
    setLastSyncs(prev => {
      const m = new Map(prev);
      m.delete(id);
      return m;
    });
  }, []);

  /* ------------------------------ return --------------------------- */
  return {
    /* data */
    items,
    total,
    totalPages,

    /* pagination */
    page,
    setPage,
    limit,
    setLimit,

    /* filters */
    status,
    setStatus,
    type,
    setType,
    clearFilters,

    /* state */
    loading,
    error,
    summary,

    /* actions */
    refresh,
    create,
    remove,
    test,
    sync,

    /* batch */
    testMultiple,
    syncMultiple,

    /* selectors */
    getDataSourceById,
    isDataSourceTesting,
    isDataSourceSyncing,
    isDataSourceDeleting,
    getLastTestResult,
    getLastSyncResult,
    clearTestResult,
    clearSyncResult,

    /* computed */
    hasNextPage: page < totalPages,
    hasPrevPage: page > 1,
    isEmpty: !loading && items.length === 0,

    /* operation counts (for badges/spinners) */
    activeOperations: {
      testing: ops.testing.size,
      syncing: ops.syncing.size,
      deleting: ops.deleting.size,
    },
  };
}



------------------------------------------------------------
FILE: frontend\src\hooks\useDebounce.ts
------------------------------------------------------------
export function useDebounce(){ return null; }


------------------------------------------------------------
FILE: frontend\src\hooks\useLocalStorage.ts
------------------------------------------------------------
export function useLocalStorage(){ return null; }


------------------------------------------------------------
FILE: frontend\src\hooks\useNotifications.ts
------------------------------------------------------------
export function useNotifications(){ return null; }


------------------------------------------------------------
FILE: frontend\src\hooks\usePipelines.ts
------------------------------------------------------------
import type { RootState } from '@/store/store'
import { useSelector } from 'react-redux'

export function usePipelines() {
  const pipelines = useSelector((s: RootState) => s.pipelines?.pipelines ?? [])
  return { pipelines, isLoading: false, error: null as unknown }
}



------------------------------------------------------------
FILE: frontend\src\hooks\useQualityRules.ts
------------------------------------------------------------
export function useQualityRules(){ return null; }


------------------------------------------------------------
FILE: frontend\src\hooks\useRequests.ts
------------------------------------------------------------
import type { RootState } from '@/store/store'
import { useSelector } from 'react-redux'

export function useRequests() {
  const requests = useSelector((s: RootState) => s.requests?.requests ?? [])
  return { requests, isLoading: false, error: null as unknown }
}



------------------------------------------------------------
FILE: frontend\src\main.tsx
------------------------------------------------------------
// src/main.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import React from 'react'
import ReactDOM from 'react-dom/client'
import { Provider } from 'react-redux'

import ErrorBoundary from '@/components/common/ErrorBoundary'
import LoadingSpinner from '@/components/common/LoadingSpinner'
import { ToastProvider, Toaster } from '@/components/ui/Notification'
import { http } from '@/services/http'
import { AuthProvider } from '@hooks/useAuth'
import AppRouter from './routes/router'
import { store } from './store/store'

import '@/styles/globals.css'
import '@/styles/tailwind.css'

// ✅ DEV auth bootstrap: stash a token so Axios can send Authorization
if (import.meta.env.DEV) {
  const devJwt = import.meta.env.VITE_DEV_JWT as string | undefined
  const hasToken =
    !!localStorage.getItem('authToken') || !!sessionStorage.getItem('authToken')
  if (devJwt && !hasToken) {
    localStorage.setItem('authToken', devJwt)
    sessionStorage.setItem('authToken', devJwt)
  }
}

// Debug: confirm what baseURL the http client resolved to
console.log('[HTTP] baseURL =', http.defaults.baseURL)

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnWindowFocus: false,
      retry: 2,
    },
    mutations: { retry: 1 },
  },
})

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <Provider store={store}>
      <QueryClientProvider client={queryClient}>
        <ToastProvider>
          <Toaster />
          <ErrorBoundary>
            <React.Suspense
              fallback={
                <div className="min-h-screen flex items-center justify-center bg-gray-50">
                  <LoadingSpinner label="Loading CWIC…" />
                </div>
              }
            >
              <AuthProvider>
                <AppRouter />
              </AuthProvider>
            </React.Suspense>
          </ErrorBoundary>
          {import.meta.env.DEV && <ReactQueryDevtools initialIsOpen={false} />}
        </ToastProvider>
      </QueryClientProvider>
    </Provider>
  </React.StrictMode>,
)



------------------------------------------------------------
FILE: frontend\src\pages\AIAssistant.tsx
------------------------------------------------------------
import { ChatInterface } from '@/components/features/ai-assistant/ChatInterface'
import { Card } from '@/components/ui/Card'
import React from 'react'

export const AIAssistant: React.FC = () => {
  return (
    <div className="max-w-6xl mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-2">AI Assistant</h1>
        <p className="text-gray-600">
          Ask me about field availability, data quality, pipeline management, or request creation.
          I can help you navigate your data platform and automate workflows.
        </p>
      </div>
      
      <Card className="h-[700px]">
        <ChatInterface />
      </Card>
    </div>
  )
}


------------------------------------------------------------
FILE: frontend\src\pages\Connections.tsx
------------------------------------------------------------
// src/pages/Connections.tsx
import AddConnectionWizard from '@/components/features/data-sources/AddConnectionWizard';
import DataSourceCard from '@/components/features/data-sources/DataSourceCard';
import { useDataSources } from '@/hooks/useDataSources';
import type { DataSourceStatus, DataSourceType } from '@/types/dataSources';
import React from 'react';

export function Connections() {
  const {
    items, page, setPage, limit, setLimit, total,
    status, setStatus, type, setType,
    loading, error, refresh, summary,
    create, remove, test, sync,
  } = useDataSources();

  const pages = Math.max(1, Math.ceil(total / limit));
  const [open, setOpen] = React.useState(false);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold">Data Sources</h1>
          <p className="text-sm text-gray-500">Manage connections to databases, warehouses, storage, streams, and APIs.</p>
        </div>
        <button
          onClick={() => setOpen(true)}
          className="rounded-xl bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700"
        >
          + Add Connection
        </button>
      </div>

      {/* KPIs */}
      <div className="grid grid-cols-4 gap-4">
        <Stat label="Total Sources" value={summary.total} icon="ðŸ’½" />
        <Stat label="Healthy" value={summary.healthy} icon="âœ…" />
        <Stat label="Warning" value={summary.warning} icon="âš ï¸" />
        <Stat label="Error" value={summary.error} icon="â›”" />
      </div>

      {/* Filters */}
      <div className="flex flex-wrap items-end gap-3">
        <Select
          label="Status"
          value={status}
          onChange={v => setStatus(v as DataSourceStatus | '')}
          options={['', 'pending','connected','disconnected','error','warning','syncing','testing']}
        />
        <Select
          label="Type"
          value={type}
          onChange={v => setType(v as DataSourceType | '')}
          options={ALL_TYPES}
        />
        <Select
          label="Page size"
          value={String(limit)}
          onChange={v => setLimit(Number(v))}
          options={['10','20','50','100']}
        />
        <div className="ml-auto text-sm text-gray-500">Page {page} / {pages}</div>
      </div>

      {/* Content */}
      {loading ? (
        <Box>Loadingâ€¦</Box>
      ) : error ? (
        <Box className="border-red-200 bg-red-50 text-red-700">{error}</Box>
      ) : items.length === 0 ? (
        <Box>No data sources connected.</Box>
      ) : (
        <div className="grid grid-cols-1 gap-4 lg:grid-cols-2 xl:grid-cols-3">
          {items.map(ds => (
            <DataSourceCard
              key={ds.id}
              ds={ds}
              onTest={async id => {
                const r = await test(id);
                alert(r.success ? 'Connection OK' : `Failed: ${r.error ?? 'Unknown error'}`);
              }}
              onSync={async id => {
                const r = await sync(id);
                alert(`Sync ${r.status} (${r.syncId})`);
              }}
              onDelete={async id => {
                if (confirm('Delete this source?')) await remove(id);
              }}
            />
          ))}
        </div>
      )}

      {/* Pagination */}
      <div className="flex items-center justify-end gap-2">
        <button
          disabled={page <= 1}
          onClick={() => setPage(p => p - 1)}
          className="rounded-lg border px-3 py-1 text-sm disabled:opacity-50"
        >
          Prev
        </button>
        <button
          disabled={page >= pages}
          onClick={() => setPage(p => p + 1)}
          className="rounded-lg border px-3 py-1 text-sm disabled:opacity-50"
        >
          Next
        </button>
        <button onClick={() => refresh()} className="ml-2 rounded-lg border px-3 py-1 text-sm">
          Refresh
        </button>
      </div>

      {/* New Wizard (searchable gallery + dynamic fields) */}
      <AddConnectionWizard
        open={open}
        onClose={() => setOpen(false)}
        onCreate={create}
        onTestAfterCreate={async (id) => test(id)}
      />
    </div>
  );
}

/* ---------- helpers ---------- */
const ALL_TYPES: (DataSourceType | '')[] = [
  '',
  'postgresql','mysql','mssql','oracle','mongodb','redis',
  's3','azure-blob','gcs',
  'snowflake','bigquery','redshift','databricks',
  'api','file','kafka','elasticsearch'
];

function Stat({ label, value, icon }: { label: string; value: number; icon: string }) {
  return (
    <div className="rounded-2xl border bg-white p-4 shadow-sm">
      <div className="text-sm text-gray-500">{label}</div>
      <div className="mt-1 flex items-baseline gap-2">
        <div className="text-2xl font-semibold">{value}</div>
        <div className="text-xl">{icon}</div>
      </div>
    </div>
  );
}

function Box({ children, className = '' }: React.PropsWithChildren<{ className?: string }>) {
  return <div className={`rounded-xl border p-6 text-sm text-gray-600 ${className}`}>{children}</div>;
}

function Select({
  label, value, onChange, options,
}: {
  label: string;
  value: string | number;
  onChange(v: string): void;
  options: (string | number)[];
}) {
  return (
    <div>
      <label className="block text-xs font-semibold text-gray-600">{label}</label>
      <select
        className="mt-1 rounded-lg border p-2 text-sm"
        value={value}
        onChange={e => onChange(e.target.value)}
      >
        {options.map(o => (
          <option key={o} value={o}>
            {o === '' ? 'All' : o}
          </option>
        ))}
      </select>
    </div>
  );
}



------------------------------------------------------------
FILE: frontend\src\pages\Dashboard.tsx
------------------------------------------------------------
// src/pages/Dashboard.tsx
import * as React from 'react'
import { useNavigate } from 'react-router-dom'

import { DashboardOverview, KPICards, QuickActions, type Activity, type KPI } from '@components/features/dashboard'
import { Badge } from '@components/ui/Badge'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'

import { useAuth } from '@hooks/useAuth'
import { useDataAssets } from '@hooks/useDataAssets'
import { usePipelines } from '@hooks/usePipelines'
import { useRequests } from '@hooks/useRequests'



type Priority = 'high' | 'medium' | 'low'

export const Dashboard: React.FC = () => {
  const navigate = useNavigate()
  const { user } = useAuth()

  // Assuming your hooks expose these shapes; if not, tweak the names below:
  const { assets = [], isLoading: assetsLoading, error: assetsError } = useDataAssets() as {
    assets: Array<{ id: string }>
    isLoading?: boolean
    error?: unknown
  }

  const { pipelines = [], isLoading: pipesLoading, error: pipesError } = usePipelines() as {
    pipelines: Array<{ id: string; status: 'running' | 'failed' | 'succeeded' | 'paused' | 'idle' }>
    isLoading?: boolean
    error?: unknown
  }

  const { requests = [], isLoading: reqLoading, error: reqError } = useRequests() as {
    requests: Array<{ id: string; status: 'open' | 'in_progress' | 'completed' | string }>
    isLoading?: boolean
    error?: unknown
  }

  const loading = !!(assetsLoading || pipesLoading || reqLoading)
  const hasError = !!(assetsError || pipesError || reqError)

  // ---- KPIs (map to the component contract) ----
  const kpis: KPI[] = [
    {
      id: 'assets',
      label: 'Total Assets',
      value: assets.length,
      diff: 4.2,
      trend: 'up',
      icon: 'database',
    },
    {
      id: 'quality',
      label: 'Quality Score',
      value: '89.7%', // Replace with real score if available
      diff: 0.8,
      trend: 'up',
      icon: 'shield',
    },
    {
      id: 'pipelines',
      label: 'Active Pipelines',
      value: pipelines.filter((p) => p.status === 'running').length,
      diff: 1.1,
      trend: 'up',
      icon: 'activity',
    },
    {
      id: 'requests',
      label: 'Open Requests',
      value: requests.filter((r) => r.status !== 'completed').length,
      diff: 0.0,
      trend: 'flat',
      icon: 'users',
    },
  ]

  // ---- Example activity feed (replace with your real events when ready) ----
  const activities: Activity[] = [
    {
      id: '1',
      time: new Date().toISOString(),
      title: 'Scan completed',
      detail: 'Azure SQL â€¢ 32 tables profiled',
      type: 'success',
    },
    {
      id: '2',
      time: new Date().toISOString(),
      title: 'Policy updated',
      detail: 'PII tagging rule refined',
      type: 'info',
    },
  ]

  // ---- Sidebar "Upcoming Events" seed ----
  const events: Array<{ title: string; time: string; priority: Priority }> = [
    { title: 'Customer Pipeline Deploy', time: 'in 3h 45m', priority: 'high' },
    { title: 'Quality Check Retry', time: 'in 2h 15m', priority: 'medium' },
    { title: 'Data Backup Scheduled', time: 'Tomorrow 2:00 AM', priority: 'low' },
  ]

  function toneForPriority(p: Priority): 'danger' | 'warning' | 'neutral' {
    if (p === 'high') return 'danger'
    if (p === 'medium') return 'warning'
    return 'neutral'
  }

  return (
    <div className="space-y-6">
      {/* Welcome Banner */}
      <div className="rounded-lg bg-gradient-to-r from-blue-600 to-purple-600 p-6 text-white">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="mb-2 text-2xl font-bold">Welcome back, {user?.name ?? 'there'}! ðŸ‘‹</h1>
            <p className="text-blue-100">Hereâ€™s whatâ€™s happening with your data platform today.</p>
          </div>
          <div className="hidden md:block">
            <div className="rounded-lg bg-white/20 p-4 text-center backdrop-blur-sm">
              <div className="text-2xl font-bold">{new Date().toLocaleDateString()}</div>
              <div className="text-sm text-blue-100">Today</div>
            </div>
          </div>
        </div>
      </div>

      {/* KPI Cards */}
      <KPICards items={kpis} loading={loading} />

      {/* Error callout (non-blocking) */}
      {hasError && (
        <Card>
          <CardContent>
            <div className="text-sm text-red-700">
              Some data failed to load. You can continue using the dashboard; try refreshing in a moment.
            </div>
          </CardContent>
        </Card>
      )}

      {/* Main Content Grid */}
      <div className="grid grid-cols-1 gap-6 lg:grid-cols-3">
        {/* Overview + Activity */}
        <div className="space-y-6 lg:col-span-2">
          {/* The overview component composes KPIs + actions + activity, but we already render KPIs above.
              So here we can either omit it, or use it for Actions + Activity. We'll pass data to keep flexible. */}
          <DashboardOverview
            kpis={kpis}
            activities={activities}
            loadingKpis={loading}
            loadingActivity={false}
            onNewScan={() => navigate('/pipelines')}
            onRefresh={() => window.location.reload()}
            onImport={() => navigate('/connections')}
          />

          {/* Or, if you prefer a separate activity block below: */}
          {/* <ActivityFeed items={activities} loading={false} /> */}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          <QuickActions
            onNewScan={() => navigate('/pipelines')}
            onRefresh={() => window.location.reload()}
            onImport={() => navigate('/connections')}
          />

          {/* System Health */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">System Health</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {[
                { name: 'Data Sources', status: 'healthy' as const, value: '4/4 online' },
                { name: 'Pipelines', status: 'warning' as const, value: '2/3 running' },
                { name: 'AI Service', status: 'healthy' as const, value: '99.9% uptime' },
                { name: 'Data Quality', status: 'healthy' as const, value: '89.7% avg score' },
              ].map((h) => (
                <div key={h.name} className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <span
                      className={[
                        'inline-block h-3 w-3 rounded-full',
                        h.status === 'healthy' ? 'bg-green-500' : h.status === 'warning' ? 'bg-yellow-500' : 'bg-red-500',
                      ].join(' ')}
                      aria-hidden
                    />
                    <span className="text-sm font-medium">{h.name}</span>
                  </div>
                  <span className="text-sm text-gray-600">{h.value}</span>
                </div>
              ))}
            </CardContent>
          </Card>

          {/* Upcoming Events */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">Upcoming Events</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {events.map((e) => (
                <div key={e.title} className="flex items-center justify-between rounded-lg bg-gray-50 p-3">
                  <div>
                    <p className="text-sm font-medium">{e.title}</p>
                    <p className="text-xs text-gray-600">{e.time}</p>
                  </div>
                  <Badge tone={toneForPriority(e.priority)}>{e.priority}</Badge>
                </div>
              ))}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  )
}

export default Dashboard



------------------------------------------------------------
FILE: frontend\src\pages\DataCatalog.tsx
------------------------------------------------------------
// src/pages/DataCatalog.tsx - Updated with backend integration
import { AssetDetails } from '@/components/features/data-catalog/AssetDetails';
import { AssetGrid } from '@/components/features/data-catalog/AssetGrid';
import { SearchFilters } from '@/components/features/data-catalog/SearchFilters';
import { Button } from '@/components/ui/Button';
import { useDataAssets } from '@/hooks/useDataAssets';
import type { Asset } from '@/types/dataAssets';
import { Plus } from 'lucide-react';
import React, { useCallback, useMemo, useState } from 'react';

export const DataCatalog: React.FC = () => {
  // Use the enhanced hook with backend integration
  const {
    assets,
    pagination,
    summary,
    isLoading,
    error,
    isEmpty,
    hasFilters,
    updateFilters,
    clearFilters,
    refresh,
    requestAccess,
    // For the filters
    filters,
  } = useDataAssets({
    autoFetch: true,
    defaultFilters: {
      page: 1,
      limit: 20,
      sortBy: 'updatedAt',
      sortOrder: 'desc'
    }
  });

  // Local state for UI
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [showDetails, setShowDetails] = useState(false);
  const [showCreateModal, setShowCreateModal] = useState(false);

  // Get selected asset
  const selectedAsset = useMemo<Asset | null>(
    () => assets.find(a => a.id === selectedId) ?? null,
    [assets, selectedId]
  );

  // Handle asset selection
  const handleSelect = useCallback((id: string) => {
    setSelectedId(id);
    setShowDetails(true);
  }, []);

  // Handle access request
  const handleRequestAccess = useCallback(async (assetId: string, reason?: string) => {
    try {
      const result = await requestAccess(assetId, reason);
      console.log('Access request submitted:', result);
      // You could show a toast notification here
      alert(`Access request submitted with ID: ${result.requestId}`);
    } catch (error: any) {
      console.error('Failed to request access:', error);
      alert(`Failed to request access: ${error.message}`);
    }
  }, [requestAccess]);

  // Handle create asset
  const handleCreateAsset = useCallback(() => {
    setShowCreateModal(true);
    // You would implement the create modal/form here
  }, []);

  // Filter change handlers
  const handleSearchChange = useCallback((search: string) => {
    updateFilters({ search, page: 1 });
  }, [updateFilters]);

  const handleTypeChange = useCallback((type: string) => {
    updateFilters({ type: type || undefined, page: 1 });
  }, [updateFilters]);

  const handleOwnerChange = useCallback((owner: string) => {
    updateFilters({ owner: owner || undefined, page: 1 });
  }, [updateFilters]);

  const handleQualityChange = useCallback((quality: string) => {
    updateFilters({ quality: (quality as any) || undefined, page: 1 });
  }, [updateFilters]);

  const handleClassificationChange = useCallback((classification: string) => {
    updateFilters({ classification: (classification as any) || undefined, page: 1 });
  }, [updateFilters]);

  const handleDataSourceChange = useCallback((dataSourceId: string) => {
    updateFilters({ dataSourceId: dataSourceId || undefined, page: 1 });
  }, [updateFilters]);

  // Error state
  if (error && !isLoading && assets.length === 0) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Data Catalog</h1>
            <p className="mt-1 text-gray-600">
              Discover and manage all your data assets across your platform.
            </p>
          </div>
          <Button onClick={handleCreateAsset}>
            <Plus className="mr-2 h-4 w-4" />
            Register Asset
          </Button>
        </div>

        <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
          <div className="text-red-600 text-lg font-medium mb-2">
            Failed to load assets
          </div>
          <p className="text-red-700 mb-4">{error}</p>
          <button
            onClick={refresh}
            className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header with Stats */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Data Catalog</h1>
            <p className="mt-1 text-gray-600">
              Discover and manage all your data assets across your platform.
            </p>
          </div>
          <Button onClick={handleCreateAsset}>
            <Plus className="mr-2 h-4 w-4" />
            Register Asset
          </Button>
        </div>

        {/* Summary Stats */}
        {!isLoading && summary && (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="bg-white rounded-lg border p-4">
              <div className="text-2xl font-bold text-gray-900">{summary.total.toLocaleString()}</div>
              <div className="text-sm text-gray-600">Total Assets</div>
            </div>
            <div className="bg-white rounded-lg border p-4">
              <div className="text-2xl font-bold text-gray-900">{summary.byType.table || 0}</div>
              <div className="text-sm text-gray-600">Tables</div>
            </div>
            <div className="bg-white rounded-lg border p-4">
              <div className="text-2xl font-bold text-gray-900">{summary.byQuality.high}</div>
              <div className="text-sm text-gray-600">High Quality</div>
            </div>
            <div className="bg-white rounded-lg border p-4">
              <div className="text-2xl font-bold text-gray-900">
                {Object.keys(summary.byType).length}
              </div>
              <div className="text-sm text-gray-600">Asset Types</div>
            </div>
          </div>
        )}
      </div>

      {/* Enhanced Filters with Backend Integration */}
      <SearchFilters
        q={filters.search || ''}
        setQ={handleSearchChange}
        type={filters.type || ''}
        setType={handleTypeChange}
        owner={filters.owner || ''}
        setOwner={handleOwnerChange}
        quality={filters.quality || ''}
        setQuality={handleQualityChange}
        classification={filters.classification || ''}
        setClassification={handleClassificationChange}
        dataSourceId={filters.dataSourceId || ''}
        setDataSourceId={handleDataSourceChange}
        totalResults={pagination.total}
        isLoading={isLoading}
        hasFilters={hasFilters}
        onClearFilters={clearFilters}
        onRefresh={refresh}
      />

      {/* Asset Grid with Backend Data */}
      <AssetGrid
        items={assets}
        onSelect={handleSelect}
        loading={isLoading}
        pagination={pagination}
        onPageChange={(page) => updateFilters({ page })}
        error={error}
        isEmpty={isEmpty}
        hasFilters={hasFilters}
      />

      {/* Asset Details Modal */}
      <AssetDetails
        asset={selectedAsset}
        isOpen={showDetails}
        onClose={() => setShowDetails(false)}
        onRequestAccess={(assetId, reason) => handleRequestAccess(assetId, reason)}
      />
    </div>
  );
};

export default DataCatalog;


------------------------------------------------------------
FILE: frontend\src\pages\DataLineage.tsx
------------------------------------------------------------
import type { Asset, AssetLayer } from '@/types/dataAssets'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Select } from '@components/ui/Select'
import { useDataAssets } from '@hooks/useDataAssets'
import { ArrowRight, Database, GitBranch, Search } from 'lucide-react'
import * as React from 'react'

type ViewMode = 'flow' | 'impact' | 'dependencies'

export const DataLineage: React.FC = () => {
  const { assets: rawAssets } = useDataAssets()
  const assets: Asset[] = Array.isArray(rawAssets) ? rawAssets : []

  const [selectedAssetId, setSelectedAssetId] = React.useState<string>('')
  const [viewMode, setViewMode] = React.useState<ViewMode>('flow')

  const assetOptions = React.useMemo(
    () =>
      assets.map(a => ({
        value: String(a.id),
        label: a.name ?? '(unnamed asset)',
      })),
    [assets]
  )

  const selectedAsset: Asset | null = React.useMemo(
    () => assets.find(a => String(a.id) === selectedAssetId) ?? null,
    [assets, selectedAssetId]
  )

  function layerColors(layer?: AssetLayer) {
    if (layer === 'Gold') return { chip: 'bg-yellow-100 text-yellow-800', tag: 'bg-yellow-200 text-yellow-800', label: 'Gold Layer' }
    if (layer === 'Silver') return { chip: 'bg-gray-100 text-gray-800', tag: 'bg-gray-200 text-gray-800', label: 'Silver Layer' }
    return { chip: 'bg-orange-100 text-orange-800', tag: 'bg-orange-200 text-orange-800', label: 'Bronze Layer' } // default Bronze
  }

  function inferLayerFromStep(step: string): AssetLayer {
    return step.includes('Gold') ? 'Gold' : step.includes('Silver') ? 'Silver' : 'Bronze'
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Data Lineage</h1>
          <p className="mt-1 text-gray-600">Trace data flow and dependencies across your data platform.</p>
        </div>
        <div className="flex items-center gap-3">
          <Select
            options={[
              { value: 'flow', label: 'Flow View' },
              { value: 'impact', label: 'Impact Analysis' },
              { value: 'dependencies', label: 'Dependencies' },
            ]}
            value={viewMode}
            onChange={(e) => setViewMode(e.target.value as ViewMode)}
          />
          <Button variant="outline">
            <Search className="mr-2 h-4 w-4" />
            Search Lineage
          </Button>
        </div>
      </div>

      {/* Asset Selection */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Select Data Asset</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
            <Select
              label="Choose Asset"
              options={[{ value: '', label: 'Select an asset...' }, ...assetOptions]}
              value={selectedAssetId}
              onChange={(e) => setSelectedAssetId(e.target.value)}
            />
            {selectedAsset && (
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Layer:</span>
                  {(() => {
                    const { chip, label } = layerColors(selectedAsset.layer)
                    return <span className={`rounded-full px-2 py-1 text-xs ${chip}`}>{selectedAsset.layer ?? 'Bronze'}{selectedAsset.layer ? '' : ''}</span>
                  })()}
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Type:</span>
                  <span className="text-sm text-gray-600">{selectedAsset.type ?? 'â€”'}</span>
                </div>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Lineage Visualization */}
      {selectedAsset ? (
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Data Flow â€” {selectedAsset.name}</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-8">
              {(selectedAsset.lineage ?? []).map((step: string, index: number, arr: string[]) => {
                const layer = inferLayerFromStep(step)
                const { chip, tag, label } = layerColors(layer)
                return (
                  <div key={`${step}-${index}`} className="flex items-center justify-between">
                    <div className="flex items-center">
                      <div className={`rounded-lg p-3 ${chip.replace('text-', 'text-gray-700 ')}`}>
                        <Database className="h-6 w-6 text-gray-700" aria-hidden />
                      </div>
                      <div className="ml-4">
                        <p className="font-medium text-gray-900">{step}</p>
                        <p className={`mt-1 inline-block rounded px-2 py-1 text-xs ${tag}`}>{label}</p>
                      </div>
                    </div>

                    {index < arr.length - 1 && <ArrowRight className="mx-4 h-6 w-6 text-gray-400" aria-hidden />}
                  </div>
                )
              })}
            </div>

            {/* Dependencies and Dependents */}
            <div className="mt-8 grid grid-cols-1 gap-6 md:grid-cols-2">
              <div>
                <h4 className="mb-3 font-medium text-gray-900">Dependencies (Upstream)</h4>
                <div className="space-y-2">
                  {(selectedAsset.dependencies ?? []).map((dep: string, i: number) => (
                    <div key={`up-${i}-${dep}`} className="flex items-center gap-2 rounded bg-blue-50 p-2">
                      <GitBranch className="h-4 w-4 text-blue-600" aria-hidden />
                      <span className="text-sm">{dep}</span>
                    </div>
                  ))}
                  {(!selectedAsset.dependencies || selectedAsset.dependencies.length === 0) && (
                    <p className="text-sm text-gray-500">No upstream dependencies.</p>
                  )}
                </div>
              </div>

              <div>
                <h4 className="mb-3 font-medium text-gray-900">Dependents (Downstream)</h4>
                <div className="space-y-2">
                  {(selectedAsset.dependents ?? []).map((dep: string, i: number) => (
                    <div key={`down-${i}-${dep}`} className="flex items-center gap-2 rounded bg-green-50 p-2">
                      <GitBranch className="h-4 w-4 text-green-600" aria-hidden />
                      <span className="text-sm">{dep}</span>
                    </div>
                  ))}
                  {(!selectedAsset.dependents || selectedAsset.dependents.length === 0) && (
                    <p className="text-sm text-gray-500">No downstream dependents.</p>
                  )}
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardContent className="p-12 text-center">
            <GitBranch className="mx-auto mb-4 h-12 w-12 text-gray-400" aria-hidden />
            <h3 className="mb-2 text-lg font-medium text-gray-900">Select a Data Asset</h3>
            <p className="text-gray-600">Choose a data asset from the dropdown above to view its lineage and dependencies.</p>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

export default DataLineage



------------------------------------------------------------
FILE: frontend\src\pages\DataQuality.tsx
------------------------------------------------------------
// src/pages/DataQuality.tsx
import { Button } from '@components/ui/Button'
import { Card, CardContent } from '@components/ui/Card'
import { AlertTriangle, Plus, Shield, TrendingUp } from 'lucide-react'
import * as React from 'react'

import { QualityOverview } from '@components/features/data-quality/QualityOverview'
// Import the *exact* types the UI components expect
import type { QualityRule, RuleStatus } from '@components/features/data-quality/QualityRules'
import { QualityRules } from '@components/features/data-quality/QualityRules'
import { QualityTrends } from '@components/features/data-quality/QualityTrends'
import type { Violation as UIViolation } from '@components/features/data-quality/ViolationsList'
import { ViolationsList } from '@components/features/data-quality/ViolationsList'

import { useQualityRules } from '@hooks/useQualityRules'

// Raw shapes coming from your hook (adjust if you have canonical types)
type RawRule = {
  id: string
  name: string
  status?: 'active' | 'disabled' | 'draft'
  severity?: 'low' | 'medium' | 'high' | 'critical'
  passRate?: number
  dataset?: string
}
type RawViolation = {
  id: string
  ruleId: string
  assetId?: string
  message?: string
  severity?: 'low' | 'medium' | 'high' | 'critical'
  createdAt?: string
  // optionally these might exist already:
  ruleName?: string
  dataset?: string
  count?: number
  firstSeen?: string
  lastSeen?: string
}
type RawMetrics = {
  overallScore?: number
  passRate?: number
  failedCount?: number
  lastUpdated?: string
}

type TabId = 'overview' | 'rules' | 'violations' | 'trends'

export const DataQuality: React.FC = () => {
  const { rules: rr, violations: rv, metrics: rm, isLoading } =
    (useQualityRules() as
      | {
          rules?: RawRule[]
          violations?: RawViolation[]
          metrics?: RawMetrics | null
          isLoading?: boolean
        }
      | null
      | undefined) ?? {}

  const rawRules: RawRule[] = Array.isArray(rr) ? rr : []
  const rawViolations: RawViolation[] = Array.isArray(rv) ? rv : []
  const metrics: Required<Pick<RawMetrics, 'overallScore' | 'passRate'>> & Partial<RawMetrics> = {
    overallScore: Math.max(0, Math.min(100, Math.round(rm?.overallScore ?? 0))),
    passRate: Math.max(0, Math.min(100, Math.round(rm?.passRate ?? 0))),
    failedCount: rm?.failedCount,
    lastUpdated: rm?.lastUpdated,
  }

  const [activeTab, setActiveTab] = React.useState<TabId>('overview')

  // --------- Adapters to UI component types ---------------------------------

  // Map raw rule â†’ UI QualityRule
  const toRuleStatus = (s?: string): RuleStatus => (s === 'active' || s === 'disabled' ? s : 'disabled')
  const rulesUI: QualityRule[] = rawRules.map((r) => ({
    id: r.id,
    name: r.name,
    dataset: r.dataset ?? 'Unspecified',
    status: toRuleStatus(r.status),
    severity: (r.severity ?? 'medium') as QualityRule['severity'],
    passRate: r.passRate,
  }))

  // Map raw violation â†’ UI Violation
  const violationsUI: UIViolation[] = rawViolations.map((v) => ({
    id: v.id,
    ruleId: v.ruleId,
    ruleName: v.ruleName ?? `Rule ${v.ruleId}`,
    dataset: v.dataset ?? 'Unspecified',
    message: v.message ?? 'Violation detected',
    severity: (v.severity ?? 'medium') as UIViolation['severity'],
    count: typeof v.count === 'number' ? v.count : 1,
    firstSeen: v.firstSeen ?? v.createdAt ?? new Date().toISOString(),
    lastSeen: v.lastSeen ?? v.createdAt ?? new Date().toISOString(),
    assetId: v.assetId,
  }))

  const activeRules = rulesUI.filter((r) => r.status === 'active').length
  const totals = {
    rules: rulesUI.length,
    activeRules,
    violations: violationsUI.length,
  }

  // QualityOverview likely expects a compact props shape. If its type differs, this
  // adapter isolates the mismatch (kept loose on purpose).
  const overviewProps: any = {
    score: metrics.overallScore,
    passRate: metrics.passRate,
    totals,
    lastUpdated: metrics.lastUpdated ?? null,
  }

  // --------------------------------------------------------------------------

  function onAddRule() {
    // TODO: open rule creation flow
    console.log('Add Quality Rule')
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Data Quality</h1>
          <p className="mt-1 text-gray-600">Monitor and manage data quality across all your assets.</p>
        </div>
        <Button onClick={onAddRule}>
          <Plus className="mr-2 h-4 w-4" />
          Add Quality Rule
        </Button>
      </div>

      {/* KPI Cards */}
      <div className="grid grid-cols-1 gap-6 md:grid-cols-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Overall Score</p>
                <p className="text-3xl font-bold text-green-600">{isLoading ? 'â€”' : `${metrics.overallScore}%`}</p>
              </div>
              <Shield className="h-8 w-8 text-green-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Active Rules</p>
                <p className="text-3xl font-bold text-blue-600">{isLoading ? 'â€”' : activeRules}</p>
              </div>
              <Shield className="h-8 w-8 text-blue-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Total Violations</p>
                <p className="text-3xl font-bold text-red-600">{isLoading ? 'â€”' : violationsUI.length}</p>
              </div>
              <AlertTriangle className="h-8 w-8 text-red-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Pass Rate</p>
                <p className="text-3xl font-bold text-green-600">{isLoading ? 'â€”' : `${metrics.passRate}%`}</p>
              </div>
              <TrendingUp className="h-8 w-8 text-green-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8" aria-label="Data quality sections">
          {([
            { id: 'overview', label: 'Overview', icon: Shield },
            { id: 'rules', label: 'Quality Rules', icon: Shield },
            { id: 'violations', label: 'Violations', icon: AlertTriangle },
            { id: 'trends', label: 'Trends', icon: TrendingUp },
          ] as const).map((tab) => {
            const active = activeTab === tab.id
            const Icon = tab.icon
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                aria-current={active ? 'page' : undefined}
                className={[
                  'flex items-center gap-2 border-b-2 py-2 px-1 text-sm font-medium',
                  active ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700',
                ].join(' ')}
              >
                <Icon className="h-4 w-4" aria-hidden />
                {tab.label}
              </button>
            )
          })}
        </nav>
      </div>

      {/* Content */}
      <div className="mt-6">
        {activeTab === 'overview' && <QualityOverview {...overviewProps} />}

        {activeTab === 'rules' && <QualityRules rules={rulesUI} />}

        {activeTab === 'violations' && (
          // ViolationsList expects exact Violation[]
          <ViolationsList items={violationsUI} loading={!!isLoading} />
        )}

        {activeTab === 'trends' && <QualityTrends />}
      </div>
    </div>
  )
}

export default DataQuality



------------------------------------------------------------
FILE: frontend\src\pages\DataSources.tsx
------------------------------------------------------------
// src/pages/DataSources.tsx
import { useState } from 'react';
import AddConnectionWizard from '../components/features/data-sources/AddConnectionWizard';
import DataSourceCard from '../components/features/data-sources/DataSourceCard';
import { useDataSources } from '../hooks/useDataSources';
import type { DataSourceStatus, DataSourceType } from '../types/dataSources';

export default function DataSourcesPage() {
  const {
    items, page, setPage, limit, setLimit, total,
    status, setStatus, type, setType,
    loading, error, refresh, summary,
    create, remove, test, sync,
  } = useDataSources();

  const pages = Math.max(1, Math.ceil(total / limit));
  const [open, setOpen] = useState(false);

  // Handle test after creation
  const handleTestAfterCreate = async (id: string) => {
    try {
      const result = await test(id);
      return {
        success: result.success,
        message: result.message,
        error: result.error
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message || 'Test failed'
      };
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold">Data Sources</h1>
          <p className="text-sm text-gray-500">Manage connections to databases, storage, and APIs.</p>
        </div>
        <button 
          onClick={() => setOpen(true)} 
          className="rounded-xl bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700"
        >
          + Add Connection
        </button>
      </div>

      {/* Summary */}
      <div className="grid grid-cols-4 gap-4">
        <Stat label="Total Sources" value={summary.total} icon="ðŸ’½" />
        <Stat label="Healthy" value={summary.healthy} icon="âœ…" />
        <Stat label="Warning" value={summary.warning} icon="âš ï¸" />
        <Stat label="Error" value={summary.error} icon="â›”" />
      </div>

      {/* Filters */}
      <div className="flex flex-wrap items-end gap-3">
        <div>
          <label className="block text-xs font-semibold text-gray-600">Status</label>
          <select 
            className="mt-1 rounded-lg border p-2 text-sm" 
            value={status} 
            onChange={e => setStatus(e.target.value as DataSourceStatus | '')}
          >
            <option value="">All</option>
            {['active', 'inactive', 'pending', 'error', 'testing'].map(s => (
              <option key={s} value={s}>{s.charAt(0).toUpperCase() + s.slice(1)}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-xs font-semibold text-gray-600">Type</label>
          <select 
            className="mt-1 rounded-lg border p-2 text-sm" 
            value={type} 
            onChange={e => setType(e.target.value as DataSourceType | '')}
          >
            {ALL_TYPES.map(t => (
              <option key={t} value={t}>
                {t === '' ? 'All' : getTypeDisplayName(t as DataSourceType)}
              </option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-xs font-semibold text-gray-600">Page size</label>
          <select 
            className="mt-1 rounded-lg border p-2 text-sm" 
            value={limit} 
            onChange={e => setLimit(Number(e.target.value))}
          >
            {[10, 20, 50, 100].map(n => (
              <option key={n} value={n}>{n}</option>
            ))}
          </select>
        </div>
        <div className="ml-auto text-sm text-gray-500">
          Page {page} / {pages} ({total} total)
        </div>
      </div>

      {/* Grid/List */}
      {loading ? (
        <div className="rounded-xl border p-6 text-center">
          <div className="inline-flex items-center gap-2 text-sm text-gray-500">
            <div className="animate-spin w-4 h-4 border-2 border-gray-300 border-t-blue-600 rounded-full"></div>
            Loading data sources...
          </div>
        </div>
      ) : error ? (
        <div className="rounded-xl border border-red-200 bg-red-50 p-4">
          <div className="flex items-center gap-2 text-sm text-red-700">
            <span>âš ï¸</span>
            <span>{error}</span>
          </div>
          <button 
            onClick={refresh}
            className="mt-2 text-xs text-red-600 hover:text-red-800 underline"
          >
            Try again
          </button>
        </div>
      ) : items.length === 0 ? (
        <div className="rounded-xl border border-dashed border-gray-300 p-12 text-center">
          <div className="text-4xl mb-4">ðŸ”Œ</div>
          <h3 className="text-lg font-medium text-gray-900 mb-2">No data sources yet</h3>
          <p className="text-sm text-gray-500 mb-4">
            Connect to databases, APIs, and storage systems to get started.
          </p>
          <button 
            onClick={() => setOpen(true)}
            className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700"
          >
            Add Your First Connection
          </button>
        </div>
      ) : (
        <div className="grid grid-cols-1 gap-4 lg:grid-cols-2 xl:grid-cols-3">
          {items.map(ds => (
            <DataSourceCard
              key={ds.id}
              ds={ds}
              onTest={async (id) => {
                try {
                  const result = await test(id);
                  alert(result.success ? 'Connection successful!' : `Failed: ${result.error ?? 'Unknown error'}`);
                } catch (error: any) {
                  alert(`Test failed: ${error.message}`);
                }
              }}
              onSync={async (id) => {
                try {
                  const result = await sync(id);
                  alert(`Sync ${result.status} (ID: ${result.syncId})`);
                } catch (error: any) {
                  alert(`Sync failed: ${error.message}`);
                }
              }}
              onDelete={async (id) => {
                if (confirm('Are you sure you want to delete this data source? This action cannot be undone.')) {
                  try {
                    await remove(id);
                    alert('Data source deleted successfully');
                  } catch (error: any) {
                    alert(`Delete failed: ${error.message}`);
                  }
                }
              }}
            />
          ))}
        </div>
      )}

      {/* Pagination */}
      {items.length > 0 && (
        <div className="flex items-center justify-between">
          <div className="text-sm text-gray-500">
            Showing {((page - 1) * limit) + 1} to {Math.min(page * limit, total)} of {total} results
          </div>
          <div className="flex items-center gap-2">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => p - 1)} 
              className="rounded-lg border px-3 py-1 text-sm disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50"
            >
              Previous
            </button>
            <span className="px-3 py-1 text-sm">
              {page} of {pages}
            </span>
            <button 
              disabled={page >= pages} 
              onClick={() => setPage(p => p + 1)} 
              className="rounded-lg border px-3 py-1 text-sm disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50"
            >
              Next
            </button>
            <button 
              onClick={refresh} 
              className="ml-2 rounded-lg border px-3 py-1 text-sm hover:bg-gray-50"
            >
              Refresh
            </button>
          </div>
        </div>
      )}

      {/* Enhanced Add Connection Wizard */}
      <AddConnectionWizard
        open={open}
        onClose={() => setOpen(false)}
        onCreate={create}
        onTestAfterCreate={handleTestAfterCreate}
        existingConnections={items}
      />
    </div>
  );
}

// Updated ALL_TYPES to match your DataSourceType union (removed 'oracle')
const ALL_TYPES: (DataSourceType | '')[] = [
  '', 
  'postgresql', 'mysql', 'mssql', 'mongodb', 'redis',
  'snowflake', 'bigquery', 'redshift', 'databricks',
  's3', 'azure-blob', 'gcs',
  'kafka', 'api', 'file', 'ftp', 'elasticsearch'
];

// Helper function to get display names
function getTypeDisplayName(type: DataSourceType): string {
  const displayNames: Record<DataSourceType, string> = {
    postgresql: 'PostgreSQL',
    mysql: 'MySQL',
    mssql: 'SQL Server',
    mongodb: 'MongoDB',
    redis: 'Redis',
    snowflake: 'Snowflake',
    bigquery: 'BigQuery',
    redshift: 'Amazon Redshift',
    databricks: 'Databricks',
    s3: 'Amazon S3',
    'azure-blob': 'Azure Blob Storage',
    gcs: 'Google Cloud Storage',
    kafka: 'Apache Kafka',
    api: 'REST API',
    file: 'File System',
    ftp: 'FTP/SFTP',
    elasticsearch: 'Elasticsearch',
    oracle: 'Oracle Database' // If you decide to support Oracle in the future
  };
  return displayNames[type] || type;
}

function Stat({ label, value, icon }: { label: string; value: number; icon: string }) {
  return (
    <div className="rounded-2xl border bg-white p-4 shadow-sm hover:shadow-md transition-shadow">
      <div className="text-sm text-gray-500">{label}</div>
      <div className="mt-1 flex items-baseline gap-2">
        <div className="text-2xl font-semibold">{value}</div>
        <div className="text-xl">{icon}</div>
      </div>
    </div>
  );
}


------------------------------------------------------------
FILE: frontend\src\pages\Governance.tsx
------------------------------------------------------------
// src/pages/Governance.tsx
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { AlertTriangle, CheckCircle, Clock, FileText, Shield } from 'lucide-react'
import * as React from 'react'

type Tab = 'policies' | 'workflows' | 'compliance'
type PolicyStatus = 'active' | 'draft'
type Priority = 'low' | 'medium' | 'high'
type WorkflowStatus = 'pending' | 'approved' | 'in_review'

export const Governance: React.FC = () => {
  const [activeTab, setActiveTab] = React.useState<Tab>('policies')

  const policies = [
    { id: 1, name: 'GDPR Data Protection', category: 'Privacy',  status: 'active' as PolicyStatus, compliance: 98 },
    { id: 2, name: 'Data Retention Policy', category: 'Lifecycle', status: 'active' as PolicyStatus, compliance: 95 },
    { id: 3, name: 'PCI DSS Compliance',    category: 'Security', status: 'active' as PolicyStatus, compliance: 100 },
    { id: 4, name: 'Data Quality Standards',category: 'Quality',  status: 'draft'  as PolicyStatus, compliance: 0 },
  ]

  const workflows = [
    { id: 1, title: 'Data Access Request - Marketing', requester: 'John Smith',  status: 'pending'  as WorkflowStatus, priority: 'high'   as Priority },
    { id: 2, title: 'Schema Change Approval',          requester: 'Sarah Johnson', status: 'approved' as WorkflowStatus, priority: 'medium' as Priority },
    { id: 3, title: 'Data Classification Review',      requester: 'Mike Wilson', status: 'in_review' as WorkflowStatus, priority: 'low'    as Priority },
  ]

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Data Governance</h1>
          <p className="mt-1 text-gray-600">Manage data policies, compliance, and governance workflows.</p>
        </div>
        <Button onClick={() => console.log('create-policy')}>
          <FileText className="mr-2 h-4 w-4" />
          Create Policy
        </Button>
      </div>

      {/* Overview Cards */}
      <div className="grid grid-cols-1 gap-6 md:grid-cols-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Active Policies</p>
                <p className="text-3xl font-bold text-blue-600">24</p>
              </div>
              <FileText className="h-8 w-8 text-blue-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Compliance Rate</p>
                <p className="text-3xl font-bold text-green-600">97.2%</p>
              </div>
              <Shield className="h-8 w-8 text-green-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Pending Approvals</p>
                <p className="text-3xl font-bold text-yellow-600">8</p>
              </div>
              <Clock className="h-8 w-8 text-yellow-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Violations</p>
                <p className="text-3xl font-bold text-red-600">3</p>
              </div>
              <AlertTriangle className="h-8 w-8 text-red-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8" aria-label="Governance sections">
          <TabButton onClick={() => setActiveTab('policies')} active={activeTab === 'policies'}>
            Data Policies
          </TabButton>
          <TabButton onClick={() => setActiveTab('workflows')} active={activeTab === 'workflows'}>
            Approval Workflows
          </TabButton>
          <TabButton onClick={() => setActiveTab('compliance')} active={activeTab === 'compliance'}>
            Compliance Reports
          </TabButton>
        </nav>
      </div>

      {/* Content */}
      <div className="mt-6">
        {activeTab === 'policies' && (
          <Card>
            <CardHeader>
              <CardTitle>Data Policies</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead className="bg-gray-50 text-left text-xs font-medium uppercase text-gray-500">
                    <tr>
                      <th className="px-6 py-3">Policy Name</th>
                      <th className="px-6 py-3">Category</th>
                      <th className="px-6 py-3">Status</th>
                      <th className="px-6 py-3">Compliance</th>
                      <th className="px-6 py-3">Actions</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200">
                    {policies.map((p) => (
                      <tr key={p.id} className="hover:bg-gray-50">
                        <td className="whitespace-nowrap px-6 py-4 font-medium text-gray-900">{p.name}</td>
                        <td className="whitespace-nowrap px-6 py-4">{p.category}</td>
                        <td className="whitespace-nowrap px-6 py-4">
                          <Badge tone={p.status === 'active' ? 'success' : 'neutral'} className="capitalize">
                            {p.status}
                          </Badge>
                        </td>
                        <td className="whitespace-nowrap px-6 py-4">{p.compliance}%</td>
                        <td className="whitespace-nowrap px-6 py-4">
                          <Button variant="ghost" size="sm" onClick={() => console.log('view-policy', p.id)}>
                            View
                          </Button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </CardContent>
          </Card>
        )}

        {activeTab === 'workflows' && (
          <Card>
            <CardHeader>
              <CardTitle>Approval Workflows</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {workflows.map((wf) => (
                  <div key={wf.id} className="rounded-lg border border-gray-200 p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <h4 className="font-medium text-gray-900">{wf.title}</h4>
                        <p className="text-sm text-gray-600">Requested by: {wf.requester}</p>
                      </div>
                      <div className="flex items-center gap-2">
                        <Badge tone={priorityTone(wf.priority)} className="capitalize">{wf.priority}</Badge>
                        <Badge tone={statusTone(wf.status)} className="capitalize">{wf.status}</Badge>
                        <Button size="sm" onClick={() => console.log('review-workflow', wf.id)}>Review</Button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {activeTab === 'compliance' && (
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-3">
            <Card className="lg:col-span-2">
              <CardHeader>
                <CardTitle>Compliance Overview</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <ProgressRow label="GDPR Compliance" value={98} />
                  <ProgressRow label="Data Retention"  value={95} />
                  <ProgressRow label="Security Standards" value={100} />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Recent Violations</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  <ViolationRow icon={<AlertTriangle className="h-4 w-4 text-red-500" />}  title="Data Access Violation"    time="2 hours ago" />
                  <ViolationRow icon={<AlertTriangle className="h-4 w-4 text-yellow-500" />} title="Retention Policy Warning" time="1 day ago" />
                  <ViolationRow icon={<CheckCircle className="h-4 w-4 text-green-500" />}  title="Issue Resolved"           time="3 days ago" />
                </div>
              </CardContent>
            </Card>
          </div>
        )}
      </div>
    </div>
  )
}

function TabButton({ active, onClick, children }: { active: boolean; onClick: () => void; children: React.ReactNode }) {
  return (
    <button
      onClick={onClick}
      className={[
        'border-b-2 py-2 px-1 text-sm font-medium',
        active ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700',
      ].join(' ')}
      aria-current={active ? 'page' : undefined}
    >
      {children}
    </button>
  )
}

function priorityTone(p: Priority): 'danger' | 'warning' | 'neutral' {
  return p === 'high' ? 'danger' : p === 'medium' ? 'warning' : 'neutral'
}
function statusTone(s: WorkflowStatus): 'warning' | 'success' | 'info' {
  return s === 'approved' ? 'success' : s === 'pending' ? 'warning' : 'info'
}

function ProgressRow({ label, value }: { label: string; value: number }) {
  return (
    <div className="flex items-center justify-between">
      <span className="text-sm font-medium">{label}</span>
      <div className="flex items-center gap-2">
        <div className="h-2 w-32 rounded-full bg-gray-200">
          <div className="h-2 rounded-full bg-green-500" style={{ width: `${Math.max(0, Math.min(100, value))}%` }} />
        </div>
        <span className="text-sm font-medium">{value}%</span>
      </div>
    </div>
  )
}

function ViolationRow({ icon, title, time }: { icon: React.ReactNode; title: string; time: string }) {
  return (
    <div className="flex items-center gap-3">
      {icon}
      <div>
        <p className="text-sm font-medium">{title}</p>
        <p className="text-xs text-gray-600">{time}</p>
      </div>
    </div>
  )
}

export default Governance



------------------------------------------------------------
FILE: frontend\src\pages\index.ts
------------------------------------------------------------
export { AIAssistant } from './AIAssistant'
export { Connections } from './Connections'
export { Dashboard } from './Dashboard'
export { DataCatalog } from './DataCatalog'
export { DataLineage } from './DataLineage'
export { DataQuality } from './DataQuality'
export { Monitoring } from './Monitoring'
export { Pipelines } from './Pipelines'
export { Requests } from './Requests'
export { Settings } from './Settings'




------------------------------------------------------------
FILE: frontend\src\pages\Monitoring.tsx
------------------------------------------------------------
import { Button } from '@/components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card'
import { Activity, AlertTriangle, Database, Monitor, Server } from 'lucide-react'
import React, { useState } from 'react'

export const Monitoring: React.FC = () => {
  const [timeRange, setTimeRange] = useState('24h')

  const systemMetrics = { cpu: 45, memory: 67, disk: 23, network: 89 }

  const alerts = [
    { id: 1, title: 'High CPU Usage', severity: 'warning', time: '5 minutes ago', resolved: false },
    { id: 2, title: 'Database Connection Timeout', severity: 'critical', time: '1 hour ago', resolved: false },
    { id: 3, title: 'Pipeline Failure', severity: 'error', time: '2 hours ago', resolved: true },
  ]

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">System Monitoring</h1>
          <p className="text-gray-600 mt-1">
            Monitor system health, performance metrics, and alerts across your data platform.
          </p>
        </div>
        <div className="flex items-center gap-3">
          <select
            value={timeRange}
            onChange={(e) => setTimeRange(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
          >
            <option value="1h">Last Hour</option>
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="30d">Last 30 Days</option>
          </select>
          <Button variant="outline">
            <Activity className="h-4 w-4 mr-2" />
            Refresh
          </Button>
        </div>
      </div>

      {/* System Health Overview */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">CPU Usage</p>
                <p className="text-3xl font-bold text-blue-600">{systemMetrics.cpu}%</p>
              </div>
              <Server className="h-8 w-8 text-blue-600" />
            </div>
            <div className="mt-3 w-full bg-gray-200 rounded-full h-2">
              <div className="h-2 rounded-full bg-blue-600" style={{ width: `${systemMetrics.cpu}%` }} />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Memory</p>
                <p className="text-3xl font-bold text-yellow-600">{systemMetrics.memory}%</p>
              </div>
              <Database className="h-8 w-8 text-yellow-600" />
            </div>
            <div className="mt-3 w-full bg-gray-200 rounded-full h-2">
              <div className="h-2 rounded-full bg-yellow-600" style={{ width: `${systemMetrics.memory}%` }} />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Disk Usage</p>
                <p className="text-3xl font-bold text-green-600">{systemMetrics.disk}%</p>
              </div>
              <Server className="h-8 w-8 text-green-600" />
            </div>
            <div className="mt-3 w-full bg-gray-200 rounded-full h-2">
              <div className="h-2 rounded-full bg-green-600" style={{ width: `${systemMetrics.disk}%` }} />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Network</p>
                <p className="text-3xl font-bold text-purple-600">{systemMetrics.network}%</p>
              </div>
              <Monitor className="h-8 w-8 text-purple-600" />
            </div>
            <div className="mt-3 w-full bg-gray-200 rounded-full h-2">
              <div className="h-2 rounded-full bg-purple-600" style={{ width: `${systemMetrics.network}%` }} />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Recent Alerts */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Alerts</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {alerts.map(a => (
              <div key={a.id} className="flex items-center justify-between p-3 rounded-lg bg-gray-50">
                <div className="flex items-center gap-3">
                  <AlertTriangle className={`h-4 w-4 ${
                    a.severity === 'critical' ? 'text-red-600' :
                    a.severity === 'error' ? 'text-red-500' :
                    a.severity === 'warning' ? 'text-yellow-600' : 'text-gray-500'
                  }`} />
                  <div>
                    <p className="text-sm font-medium">{a.title}</p>
                    <p className="text-xs text-gray-600">{a.time}</p>
                  </div>
                </div>
                <span className={`text-xs px-2 py-1 rounded-full ${
                  a.resolved ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'
                }`}>
                  {a.resolved ? 'Resolved' : 'Open'}
                </span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}



------------------------------------------------------------
FILE: frontend\src\pages\Pipelines.tsx
------------------------------------------------------------
// src/pages/Pipelines.tsx
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Input } from '@components/ui/Input'
import { Modal } from '@components/ui/Modal'
import { useToast } from '@components/ui/Notification'
import { Select } from '@components/ui/Select'
import { useQuery } from '@tanstack/react-query'
import { cn } from '@utils'
import { ChevronRight, Clock, GitBranch, Pause, Play, RefreshCcw, Server, Shield } from 'lucide-react'
import * as React from 'react'

/** Types (keep local to avoid import coupling; match your backend shape) */
type PipelineStatus = 'idle' | 'running' | 'failed' | 'succeeded' | 'paused'
type Environment = 'dev' | 'test' | 'stage' | 'prod'

interface Pipeline {
  id: string
  name: string
  description?: string
  status: PipelineStatus
  environment: Environment
  lastRun?: string // ISO
  owner?: string
  repo?: string
  branch?: string
  tags?: string[]
}

interface Deployment {
  id: string
  pipelineId: string
  version: string
  startedAt: string
  finishedAt?: string
  status: PipelineStatus
  commit?: string
  triggeredBy?: string
}

/** API helpers */
async function getPipelines(params: { q?: string; env?: string; status?: string }) {
  const query = new URLSearchParams()
  if (params.q) query.set('q', params.q)
  if (params.env) query.set('environment', params.env)
  if (params.status) query.set('status', params.status)

  const res = await fetch(`/api/pipelines?${query.toString()}`)
  if (!res.ok) throw new Error(`Failed to fetch pipelines: ${res.status}`)
  const data = (await res.json()) as Pipeline[]
  return data
}

async function getDeployments(pipelineId: string) {
  const res = await fetch(`/api/pipelines/${pipelineId}/deployments`)
  if (!res.ok) throw new Error(`Failed to fetch deployments: ${res.status}`)
  const data = (await res.json()) as Deployment[]
  return data
}

/** Utils */
function statusTone(s: PipelineStatus) {
  switch (s) {
    case 'running':
      return { tone: 'info' as const, label: 'Running' }
    case 'failed':
      return { tone: 'danger' as const, label: 'Failed' }
    case 'succeeded':
      return { tone: 'success' as const, label: 'Succeeded' }
    case 'paused':
      return { tone: 'warning' as const, label: 'Paused' }
    default:
      return { tone: 'neutral' as const, label: 'Idle' }
  }
}
function envBadge(e: Environment) {
  switch (e) {
    case 'dev': return { className: 'bg-gray-100 text-gray-800', label: 'DEV' }
    case 'test': return { className: 'bg-blue-100 text-blue-800', label: 'TEST' }
    case 'stage': return { className: 'bg-purple-100 text-purple-800', label: 'STAGE' }
    case 'prod': return { className: 'bg-green-100 text-green-800', label: 'PROD' }
  }
}
function fmtTime(iso?: string) {
  if (!iso) return 'â€”'
  try {
    const d = new Date(iso)
    return d.toLocaleString()
  } catch {
    return iso
  }
}

/** Page */
export const Pipelines: React.FC = () => {
  const { push } = useToast()

  // Filters
  const [q, setQ] = React.useState('')
  const [env, setEnv] = React.useState<string>('')
  const [status, setStatus] = React.useState<string>('')

  // Selected pipeline
  const [selected, setSelected] = React.useState<Pipeline | null>(null)

  const { data, isLoading, isError, error, refetch, isFetching } = useQuery({
    queryKey: ['pipelines', { q, env, status }],
    queryFn: () => getPipelines({ q, env, status }),
    staleTime: 60_000,
    refetchOnWindowFocus: false,
  })

  const { data: deployments, isLoading: isDepsLoading, isError: isDepsError, error: depsError, refetch: refetchDeps } =
    useQuery({
      queryKey: ['deployments', selected?.id],
      queryFn: () => getDeployments(selected!.id),
      enabled: !!selected,
      staleTime: 30_000,
    })

  function handleStart(p: Pipeline) {
    // TODO: POST /api/pipelines/:id/start
    push({ type: 'info', message: `Starting pipeline "${p.name}"â€¦` })
  }
  function handlePause(p: Pipeline) {
    // TODO: POST /api/pipelines/:id/pause
    push({ type: 'warning', message: `Pausing pipeline "${p.name}"â€¦` })
  }
  function handleRerun(p: Pipeline) {
    // TODO: POST /api/pipelines/:id/rerun
    push({ type: 'success', message: `Re-running pipeline "${p.name}"â€¦` })
  }

  return (
    <div className="space-y-6">
      {/* Controls */}
      <Card>
        <CardHeader>
          <CardTitle>Pipelines</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 gap-3 sm:grid-cols-2 md:grid-cols-4">
            <Input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              placeholder="Search by name, owner, tagâ€¦"
              startIcon={<SearchIcon />}
            />
            <Select
              label="Environment"
              value={env}
              onChange={(e) => setEnv(e.target.value)}
              options={[
                { label: 'All environments', value: '' },
                { label: 'DEV', value: 'dev' },
                { label: 'TEST', value: 'test' },
                { label: 'STAGE', value: 'stage' },
                { label: 'PROD', value: 'prod' },
              ]}
            />
            <Select
              label="Status"
              value={status}
              onChange={(e) => setStatus(e.target.value)}
              options={[
                { label: 'All statuses', value: '' },
                { label: 'Idle', value: 'idle' },
                { label: 'Running', value: 'running' },
                { label: 'Succeeded', value: 'succeeded' },
                { label: 'Failed', value: 'failed' },
                { label: 'Paused', value: 'paused' },
              ]}
            />
            <div className="flex items-end gap-2">
              <Button variant="outline" onClick={() => { setQ(''); setEnv(''); setStatus('') }}>
                Reset
              </Button>
              <Button variant="secondary" onClick={() => refetch()} leftIcon={<RefreshCcw className="h-4 w-4" />}>
                Refresh
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Content */}
      {isLoading ? (
        <GridSkeleton />
      ) : isError ? (
        <Card>
          <CardContent>
            <div className="text-sm text-red-700">Failed to load pipelines: {(error as Error)?.message}</div>
          </CardContent>
        </Card>
      ) : !data || data.length === 0 ? (
        <Card>
          <CardContent>
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-medium text-gray-900">No pipelines found</div>
                <div className="text-sm text-gray-600">Adjust filters or create a pipeline.</div>
              </div>
              <Button leftIcon={<GitBranch className="h-4 w-4" />}>New Pipeline</Button>
            </div>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
          {data.map((p) => {
            const tone = statusTone(p.status)
            const envT = envBadge(p.environment)
            return (
              <Card key={p.id} className="hover:shadow-md transition">
                <CardContent className="p-5">
                  <div className="flex items-start justify-between gap-3">
                    <div>
                      <div className="flex items-center gap-2">
                        <span className="text-base font-semibold text-gray-900">{p.name}</span>
                        <span className={cn('rounded-full px-2 py-0.5 text-[11px] font-medium', envT.className)}>
                          {envT.label}
                        </span>
                      </div>
                      <div className="mt-1 text-sm text-gray-600 line-clamp-2">{p.description ?? 'â€”'}</div>
                      <div className="mt-2 flex flex-wrap items-center gap-2">
                        <Badge tone={tone.tone}>{tone.label}</Badge>
                        {p.branch && (
                          <span className="inline-flex items-center gap-1 text-xs text-gray-600">
                            <GitBranch className="h-3.5 w-3.5" /> {p.branch}
                          </span>
                        )}
                        {p.owner && (
                          <span className="inline-flex items-center gap-1 text-xs text-gray-600">
                            <Shield className="h-3.5 w-3.5" /> {p.owner}
                          </span>
                        )}
                        <span className="inline-flex items-center gap-1 text-xs text-gray-600">
                          <Clock className="h-3.5 w-3.5" /> Last run: {fmtTime(p.lastRun)}
                        </span>
                      </div>
                    </div>
                    <Button variant="ghost" size="icon" aria-label="Open details" onClick={() => setSelected(p)}>
                      <ChevronRight className="h-5 w-5" />
                    </Button>
                  </div>

                  <div className="mt-4 flex items-center gap-2">
                    {p.status !== 'running' ? (
                      <Button onClick={() => handleStart(p)} leftIcon={<Play className="h-4 w-4" />}>
                        Start
                      </Button>
                    ) : (
                      <Button variant="outline" onClick={() => handlePause(p)} leftIcon={<Pause className="h-4 w-4" />}>
                        Pause
                      </Button>
                    )}
                    <Button variant="outline" onClick={() => handleRerun(p)} leftIcon={<RefreshCcw className="h-4 w-4" />}>
                      Re-run
                    </Button>
                  </div>
                </CardContent>
              </Card>
            )
          })}
        </div>
      )}

      {/* Details Drawer */}
      <Modal
        isOpen={!!selected}
        onClose={() => setSelected(null)}
        title={
          selected ? (
            <div className="flex items-center gap-2">
              <Server className="h-5 w-5 text-blue-600" />
              <span className="font-semibold">{selected.name}</span>
              <span className="text-xs text-gray-500">({selected.environment.toUpperCase()})</span>
            </div>
          ) : null
        }
        size="lg"
      >
        {selected ? (
          <div className="space-y-5">
            <div className="text-sm text-gray-700">{selected.description ?? 'No description.'}</div>

            <div className="grid grid-cols-1 gap-3 sm:grid-cols-3">
              <Detail label="Status">
                <Badge tone={statusTone(selected.status).tone}>{statusTone(selected.status).label}</Badge>
              </Detail>
              <Detail label="Owner">{selected.owner ?? 'â€”'}</Detail>
              <Detail label="Repository">{selected.repo ?? 'â€”'}</Detail>
              <Detail label="Branch">{selected.branch ?? 'â€”'}</Detail>
              <Detail label="Last Run">{fmtTime(selected.lastRun)}</Detail>
              <Detail label="Tags">
                {selected.tags?.length ? selected.tags.map((t) => (
                  <span key={t} className="mr-1 inline-block rounded bg-gray-100 px-2 py-0.5 text-xs text-gray-700">{t}</span>
                )) : 'â€”'}
              </Detail>
            </div>

            <Card>
              <CardHeader>
                <CardTitle>Deployment History</CardTitle>
              </CardHeader>
              <CardContent>
                {isDepsLoading ? (
                  <div className="text-sm text-gray-600">Loading deploymentsâ€¦</div>
                ) : isDepsError ? (
                  <div className="text-sm text-red-700">Failed to load: {(depsError as Error)?.message}</div>
                ) : !deployments?.length ? (
                  <div className="text-sm text-gray-600">No deployments yet.</div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="min-w-full text-sm">
                      <thead>
                        <tr className="text-left text-gray-500">
                          <th className="py-2 pr-4">Version</th>
                          <th className="py-2 pr-4">Status</th>
                          <th className="py-2 pr-4">Started</th>
                          <th className="py-2 pr-4">Finished</th>
                          <th className="py-2 pr-4">Commit</th>
                          <th className="py-2 pr-4">Triggered By</th>
                        </tr>
                      </thead>
                      <tbody>
                        {deployments.map((d) => (
                          <tr key={d.id} className="border-t">
                            <td className="py-2 pr-4 font-medium">{d.version}</td>
                            <td className="py-2 pr-4">
                              <Badge tone={statusTone(d.status).tone}>{statusTone(d.status).label}</Badge>
                            </td>
                            <td className="py-2 pr-4">{fmtTime(d.startedAt)}</td>
                            <td className="py-2 pr-4">{fmtTime(d.finishedAt)}</td>
                            <td className="py-2 pr-4">{d.commit ?? 'â€”'}</td>
                            <td className="py-2 pr-4">{d.triggeredBy ?? 'â€”'}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </CardContent>
            </Card>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => refetchDeps()}>Refresh</Button>
              <Button onClick={() => setSelected(null)}>Close</Button>
            </div>
          </div>
        ) : null}
      </Modal>
    </div>
  )
}

/** Small pieces */
const Detail: React.FC<{ label: string; children?: React.ReactNode }> = ({ label, children }) => (
  <div>
    <div className="text-xs text-gray-500">{label}</div>
    <div className="text-sm text-gray-900">{children}</div>
  </div>
)

const GridSkeleton: React.FC = () => (
  <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
    {Array.from({ length: 6 }).map((_, i) => (
      <Card key={i}>
        <CardContent className="p-5">
          <div className="h-5 w-40 animate-pulse rounded bg-gray-200" />
          <div className="mt-2 h-4 w-full animate-pulse rounded bg-gray-200" />
          <div className="mt-1 h-4 w-3/4 animate-pulse rounded bg-gray-200" />
          <div className="mt-4 flex gap-2">
            <div className="h-9 w-24 animate-pulse rounded bg-gray-200" />
            <div className="h-9 w-24 animate-pulse rounded bg-gray-200" />
          </div>
        </CardContent>
      </Card>
    ))}
  </div>
)

const SearchIcon = () => (
  <svg viewBox="0 0 24 24" className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" strokeWidth="2">
    <circle cx="11" cy="11" r="7" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
  </svg>
)

export default Pipelines



------------------------------------------------------------
FILE: frontend\src\pages\Requests.tsx
------------------------------------------------------------
// src/pages/Requests.tsx
import { Button } from '@components/ui/Button'
import { Card, CardContent } from '@components/ui/Card'
import { Modal } from '@components/ui/Modal'
import * as React from 'react'

import type { RequestItem } from '@components/features/requests/RequestList'
import { RequestList } from '@components/features/requests/RequestList'

import type { RequestFormValues } from '@components/features/requests/RequestForm'
import { RequestForm } from '@components/features/requests/RequestForm'

import type { WorkflowStep } from '@components/features/requests/ApprovalWorkflow'
import { ApprovalWorkflow } from '@components/features/requests/ApprovalWorkflow'

import { RequestDetails } from '@components/features/requests/RequestDetails'
import { useRequests } from '@hooks/useRequests'

import { AlertTriangle, CheckCircle, Clock, FileText, Plus } from 'lucide-react'

// ---------------- Raw shapes (from your data layer; tolerant/normalized) ----------------
type RawRequestStatus = 'pending' | 'in_progress' | 'completed' | 'rejected'
type RawPriority = 'low' | 'medium' | 'high'
type RawStepStatus = 'waiting' | 'approved' | 'rejected' | 'running' | 'done'

type RawStep = {
  id: string | number
  name: string
  assignee?: string
  status: RawStepStatus
  startedAt?: string
  completedAt?: string
}

type RawRequest = {
  id: string | number
  title: string
  description?: string
  status: RawRequestStatus
  priority?: RawPriority
  requester?: string
  createdAt?: string
  updatedAt?: string
  steps?: RawStep[]
}

// ----------------------------------- Page -----------------------------------
export const Requests: React.FC = () => {
  // Read whatever the hook returns, but don't cast to a specific shape yet
  const hookResult = (useRequests() ?? {}) as {
    requests?: unknown
    isLoading?: boolean
    error?: unknown
  }

  // Defensive normalization from unknown[] â†’ RawRequest[]
  const rawArray: any[] = Array.isArray(hookResult.requests) ? (hookResult.requests as any[]) : []

  const toRawStatus = (s: any): RawRequestStatus =>
    s === 'pending' || s === 'in_progress' || s === 'completed' || s === 'rejected' ? s : 'pending'

  const toPriority = (p: any): RawPriority => (p === 'low' || p === 'high' ? p : 'medium')

  const toStepStatus = (s: any): RawStepStatus =>
    s === 'approved' || s === 'rejected' || s === 'running' || s === 'done' ? s : 'waiting'

  let uid = 0
  const normalize = (x: any, i: number): RawRequest => ({
    id: x?.id ?? x?.requestId ?? `${Date.now()}-${i}-${uid++}`,
    title: x?.title ?? x?.name ?? 'Untitled request',
    description: x?.description ?? x?.details ?? '',
    status: toRawStatus(x?.status),
    priority: toPriority(x?.priority),
    requester: x?.requester ?? x?.owner ?? x?.createdBy ?? 'unknown',
    createdAt: x?.createdAt ?? x?.created_at ?? x?.dateCreated ?? new Date().toISOString(),
    updatedAt: x?.updatedAt ?? x?.updated_at ?? x?.dateUpdated,
    steps: Array.isArray(x?.steps)
      ? x.steps.map((s: any, j: number): RawStep => ({
          id: s?.id ?? s?.stepId ?? `${Date.now()}-${i}-${j}`,
          name: s?.name ?? s?.label ?? `Step ${j + 1}`,
          assignee: s?.assignee ?? s?.approver ?? '',
          status: toStepStatus(s?.status),
          startedAt: s?.startedAt ?? s?.started_at,
          completedAt: s?.completedAt ?? s?.completed_at,
        }))
      : [],
  })

  const raw: RawRequest[] = rawArray.map(normalize)
  const isLoading = !!hookResult.isLoading

  // Keep raw statuses for KPIs/filters (avoids union clashes with UI types)
  const [activeTab, setActiveTab] = React.useState<'all' | RawRequestStatus>('all')

  // Adapt RawRequest â†’ RequestItem (UI type) right at the boundary
  const items: RequestItem[] = raw.map((r) => ({
    id: String(r.id),
    title: r.title,
    status: (r.status as unknown) as RequestItem['status'], // mapped literal
    priority: (r.priority as unknown) as RequestItem['priority'],
    requester: r.requester ?? 'unknown',
    createdAt: r.createdAt!,
    updatedAt: r.updatedAt,
  }))

  // Filter using RAW statuses
  const filteredIds = React.useMemo(() => {
    if (activeTab === 'all') return new Set(raw.map((r) => String(r.id)))
    return new Set(raw.filter((r) => r.status === activeTab).map((r) => String(r.id)))
  }, [raw, activeTab])

  const filteredItems = React.useMemo(
    () => items.filter((i) => filteredIds.has(i.id)),
    [items, filteredIds]
  )

  // Selection (keep both raw + UI versions available)
  const [selectedId, setSelectedId] = React.useState<string | null>(null)
  const selectedRaw: RawRequest | null = React.useMemo(
    () => raw.find((r) => String(r.id) === selectedId) ?? null,
    [raw, selectedId]
  )
  const selectedItem: RequestItem | null = React.useMemo(
    () => items.find((i) => i.id === selectedId) ?? null,
    [items, selectedId]
  )

  // ApprovalWorkflow expects WorkflowStep[] with { id, label, approver, state }
  const steps: WorkflowStep[] = React.useMemo(() => {
    const s = selectedRaw?.steps ?? []
    return s.map((st) => ({
      id: String(st.id),
      label: st.name, // rename
      approver: st.assignee ?? '', // rename
      state: (st.status as unknown) as WorkflowStep['state'], // cast at the edge
      // NOTE: do not include startedAt/completedAt if WorkflowStep doesn't declare them
    }))
  }, [selectedRaw])

  // Create form (controlled). Ensure fields exist in RequestFormValues.
  const [showCreate, setShowCreate] = React.useState(false)
  const [creating, setCreating] = React.useState(false)
  const [formValue, setFormValue] = React.useState<Partial<RequestFormValues>>({
    title: '',
    description: '',
    priority: 'medium',
  })

  async function handleSubmit(v: RequestFormValues) {
    setCreating(true)
    try {
      // TODO: call your API to create request
      console.log('create request', v)
      setShowCreate(false)
      // TODO: refresh list (via hook/React Query/RTK)
    } finally {
      setCreating(false)
    }
  }

  // KPIs use raw (safe literal comparisons)
  const stats = React.useMemo(() => {
    const total = raw.length
    const pending = raw.filter((r) => r.status === 'pending').length
    const inProgress = raw.filter((r) => r.status === 'in_progress').length
    const completed = raw.filter((r) => r.status === 'completed').length
    return { total, pending, inProgress, completed }
  }, [raw])

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Workflow Requests</h1>
          <p className="mt-1 text-gray-600">
            Create and track data-related requests, approvals, and workflow automation.
          </p>
        </div>
        <Button onClick={() => setShowCreate(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Create Request
        </Button>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 gap-6 md:grid-cols-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Pending</p>
                <p className="text-3xl font-bold text-yellow-600">{stats.pending}</p>
              </div>
              <Clock className="h-8 w-8 text-yellow-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">In Progress</p>
                <p className="text-3xl font-bold text-blue-600">{stats.inProgress}</p>
              </div>
              <AlertTriangle className="h-8 w-8 text-blue-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Completed</p>
                <p className="text-3xl font-bold text-green-600">{stats.completed}</p>
              </div>
              <CheckCircle className="h-8 w-8 text-green-600" aria-hidden />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-600">Total</p>
                <p className="text-3xl font-bold text-gray-900">{stats.total}</p>
              </div>
              <FileText className="h-8 w-8 text-gray-600" aria-hidden />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Filter Tabs (use raw status literals) */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8">
          {[
            { id: 'all', label: 'All Requests' },
            { id: 'pending', label: 'Pending' },
            { id: 'in_progress', label: 'In Progress' },
            { id: 'completed', label: 'Completed' },
          ].map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as typeof activeTab)}
              className={[
                'border-b-2 py-2 px-1 text-sm font-medium',
                activeTab === (tab.id as typeof activeTab)
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700',
              ].join(' ')}
            >
              {tab.label}
            </button>
          ))}
        </nav>
      </div>

      {/* Requests List (expects items/loading/onSelect/onNew) */}
      <RequestList
        items={filteredItems}
        loading={isLoading}
        onSelect={(id) => setSelectedId(id)}
        onNew={() => setShowCreate(true)}
      />

      {/* Create Request Modal (RequestForm is controlled) */}
      <Modal
        isOpen={showCreate}
        onClose={() => setShowCreate(false)}
        title="Create New Request"
        size="lg"
      >
        <RequestForm
          value={formValue}
          onChange={setFormValue}
          onSubmit={handleSubmit}
          busy={creating}
        />
      </Modal>

      {/* Request Details + Workflow */}
      <Modal
        isOpen={!!selectedItem}
        onClose={() => setSelectedId(null)}
        title={selectedItem ? `Request Details â€” ${selectedItem.title}` : 'Request Details'}
        size="xl"
      >
        {selectedItem && (
          <div className="space-y-6">
            {/* RequestDetails expects a RequestItem */}
            <RequestDetails request={selectedItem} />
            {/* ApprovalWorkflow expects { steps } with { id, label, approver, state } */}
            <ApprovalWorkflow steps={steps} />
          </div>
        )}
      </Modal>
    </div>
  )
}

export default Requests



------------------------------------------------------------
FILE: frontend\src\pages\Settings.tsx
------------------------------------------------------------
import { Badge } from '@components/ui/Badge'
import { Button } from '@components/ui/Button'
import { Card, CardContent, CardHeader, CardTitle } from '@components/ui/Card'
import { Input } from '@components/ui/Input'
import { Select } from '@components/ui/Select'
import * as React from 'react'

export const Settings: React.FC = () => {
  // example local state; wire to your services/store as needed
  const [profile, setProfile] = React.useState({ name: '', email: '' })
  const [theme, setTheme] = React.useState<'system' | 'light' | 'dark'>('system')
  const [notif, setNotif] = React.useState(true)

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader><CardTitle>Profile</CardTitle></CardHeader>
        <CardContent className="space-y-4">
          <Input
            placeholder="Name"
            value={profile.name}
            onChange={(e) => setProfile(p => ({ ...p, name: e.target.value }))}
          />
          <Input
            placeholder="Email"
            value={profile.email}
            onChange={(e) => setProfile(p => ({ ...p, email: e.target.value }))}
          />
          <div className="flex justify-end">
            <Button onClick={() => console.log('Save profile', profile)}>Save</Button>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader><CardTitle>Appearance</CardTitle></CardHeader>
        <CardContent className="grid gap-3 sm:grid-cols-2">
          <Select
            label="Theme"
            value={theme}
            onChange={(e) => setTheme(e.target.value as typeof theme)}
            options={[
              { label: 'System', value: 'system' },
              { label: 'Light', value: 'light' },
              { label: 'Dark', value: 'dark' },
            ]}
          />
          <div className="flex items-end">
            <Badge tone="neutral">Current: {theme}</Badge>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader><CardTitle>Notifications</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={notif}
              onChange={(e) => setNotif(e.target.checked)}
              className="h-4 w-4"
            />
            Enable email notifications
          </label>
          <div className="flex justify-end">
            <Button variant="secondary" onClick={() => console.log('Save notifications', notif)}>
              Save
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

export default Settings



------------------------------------------------------------
FILE: frontend\src\routes\router.tsx
------------------------------------------------------------
// src/router/router.tsx
import App from '@/App'; // or ../App
import { createBrowserRouter, RouterProvider } from 'react-router-dom'

const router = createBrowserRouter([{ path: '/*', element: <App /> }])

export default function AppRouter() {
  return <RouterProvider router={router} />
}



------------------------------------------------------------
FILE: frontend\src\services\api\aiAssistant.ts
------------------------------------------------------------
// src/services/api/aiAssistant.ts
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import axios from 'axios';

/* =========================
   Types
   ========================= */
export interface AIMessage {
  id: string;
  type: 'user' | 'assistant' | 'system' | 'error';
  content: string;
  timestamp: Date;
  metadata?: {
    processingTime?: number;
    confidence?: number;
    sources?: string[];
    tokenCount?: number;
    model?: string;
  };
}

export interface AIAction {
  type: 'view_details' | 'export_data' | 'schedule_analysis' | 'create_rule';
  label: string;
  description?: string;
  payload?: unknown;
}

export interface AIResponse {
  success: boolean;
  data?: {
    message: string;
    type: 'text' | 'data' | 'query' | 'analysis' | 'visualization';
    results?: unknown;
    suggestions?: string[];
    sources?: string[];
    actions?: AIAction[];
  };
  error?: {
    code: string;
    message: string;
    details?: unknown;
    retryable?: boolean;
  };
  meta?: {
    processingTime: number;
    model: string;
    tokens?: number;
    confidence?: number;
    requestId?: string;
    timestamp: string;
  };
}

export interface AIDiscoverySession {
  sessionId: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  progress: number;
  phase?: 'initialization' | 'scanning' | 'analysis' | 'classification' | 'reporting';
  results?: {
    tablesAnalyzed?: number;
    columnsFound?: number;
    sensitiveDataFound?: number;
    qualityIssues?: number;
    complianceFlags?: number;
    recommendations?: string[];
  };
  startedAt: Date;
  completedAt?: Date;
  estimatedCompletion?: Date;
  error?: string;
}

export interface AIServiceConfig {
  baseURL: string;
  timeout: number;
  maxRetries: number;
  retryDelay: number;
  enableMockMode: boolean;
  cacheDuration: number;
  enableLogging: boolean;
}

export interface RequestContext {
  requestId?: string;
  priority?: 'low' | 'normal' | 'high' | 'critical';
  timeout?: number;
  retryable?: boolean;
  cacheKey?: string;
}

interface ConnectionMetrics {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  lastError?: string;
  uptime: number;
}

/* =========================
   Errors
   ========================= */
class AIServiceError extends Error {
  public code: string;
  public retryable: boolean;
  public details?: unknown;

  constructor(code: string, message: string, retryable: boolean = false, details?: unknown) {
    super(message);
    this.name = 'AIServiceError';
    this.code = code;
    this.retryable = retryable;
    this.details = details;
  }
}

class NetworkError extends AIServiceError {
  constructor(message: string = 'Network connection failed') {
    super('NETWORK_ERROR', message, true);
  }
}

class TimeoutError extends AIServiceError {
  constructor(message: string = 'Request timed out') {
    super('TIMEOUT_ERROR', message, true);
  }
}

class AuthenticationError extends AIServiceError {
  constructor(message: string = 'Authentication failed') {
    super('AUTH_ERROR', message, false);
  }
}

/* =========================
   Configuration
   ========================= */
const DEFAULT_CONFIG: AIServiceConfig = {
  baseURL: '/api/ai',
  timeout: 30000,
  maxRetries: 3,
  retryDelay: 1000,
  enableMockMode: false,
  cacheDuration: 300000,
  enableLogging: false,
};

const HEALTH_PATH = '/health';
const CONNECTION_CHECK_INTERVAL = 30000;
const MAX_CACHE_SIZE = 100;

/* =========================
   Utilities
   ========================= */
const isProduction = import.meta.env.PROD;
const isDevelopment = import.meta.env.DEV;
const isBrowser = typeof window !== 'undefined';

function generateRequestId(): string {
  if (isBrowser && crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `req_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
}

function sanitizeHeaders(headers: any): any {
  if (!headers) return {};
  const sanitized = { ...headers };
  if (sanitized.Authorization) sanitized.Authorization = 'Bearer [REDACTED]';
  if (sanitized.authorization) sanitized.authorization = 'Bearer [REDACTED]';
  return sanitized;
}

function getAuthToken(): string | null {
  if (!isBrowser) return null;
  try {
    return localStorage.getItem('authToken') || 
           sessionStorage.getItem('authToken') || 
           localStorage.getItem('access_token') ||
           sessionStorage.getItem('access_token') ||
           null;
  } catch {
    return null;
  }
}

function getUserContext(): any {
  if (!isBrowser) return null;
  try {
    const userStr = localStorage.getItem('user') || sessionStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  } catch {
    return null;
  }
}

/* =========================
   Service
   ========================= */
class AIAssistantService {
  private readonly api: ReturnType<typeof axios.create>;
  private readonly config: AIServiceConfig;

  private connected = false;
  private connectionAttempts = 0;
  private lastConnectionCheck = 0;

  private metrics: ConnectionMetrics = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    averageResponseTime: 0,
    uptime: Date.now(),
  };

  private readonly responseCache = new Map<string, { response: AIResponse; timestamp: number }>();
  private readonly activeRequests = new Map<string, AbortController>();
  private readonly requestMeta = new WeakMap<AxiosRequestConfig, { requestId: string; startTime: number }>();

  private cleanupTimer?: ReturnType<typeof setInterval>;

  constructor(config?: Partial<AIServiceConfig>) {
    // Resolve base URL with production-safe defaults
    const baseURL = this.resolveBaseURL(config?.baseURL);
    
    this.config = {
      ...DEFAULT_CONFIG,
      baseURL,
      enableMockMode: this.shouldEnableMockMode(config?.enableMockMode),
      enableLogging: this.shouldEnableLogging(config?.enableLogging),
      ...config,
    };

    this.api = this.createAxiosInstance();
    
    // Initialize connection check and cleanup
    void this.checkConnection();
    this.startPeriodicCleanup();
  }

  private resolveBaseURL(configURL?: string): string {
    if (configURL) return configURL;

    // Check environment variables
    const envURL = import.meta.env?.VITE_AI_SERVICE_URL || 
                   import.meta.env?.VITE_AI_API_URL ||
                   import.meta.env?.VITE_API_BASE;

    if (envURL) {
      // Ensure it's a proper URL for production
      if (isProduction && !envURL.startsWith('http')) {
        console.warn('[AI Service] Production environment detected but relative URL provided. This may cause issues.');
      }
      return envURL;
    }

    // Development fallback
    return isDevelopment ? '/api/ai' : '/api/ai';
  }

  private shouldEnableMockMode(configValue?: boolean): boolean {
    if (configValue !== undefined) return configValue;
    
    // Only enable mock mode in development and when explicitly enabled
    return isDevelopment && import.meta.env?.VITE_ENABLE_MOCK_MODE !== 'false';
  }

  private shouldEnableLogging(configValue?: boolean): boolean {
    if (configValue !== undefined) return configValue;
    
    // Enable logging in development or when explicitly enabled
    return isDevelopment || import.meta.env?.VITE_DEBUG_AI_SERVICE === 'true';
  }

  private createAxiosInstance(): ReturnType<typeof axios.create> {
    const instance = axios.create({
      baseURL: this.config.baseURL,
      timeout: this.config.timeout,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Client-Version': import.meta.env?.VITE_APP_VERSION || '1.0.0',
        'X-Client-Type': 'web',
        'X-Platform': 'cwic-frontend',
      },
    });

    this.setupRequestInterceptor(instance);
    this.setupResponseInterceptor(instance);

    return instance;
  }

  private setupRequestInterceptor(instance: ReturnType<typeof axios.create>): void {
    instance.interceptors.request.use(
      (config) => {
        if (!config) {
          throw new AIServiceError('REQUEST_CONFIG_ERROR', 'Invalid request configuration');
        }

        // Generate request ID and store metadata
        const requestId = generateRequestId();
        const startTime = Date.now();
        
        config.headers = config.headers || {};
        config.headers['X-Request-ID'] = requestId;
        
        this.requestMeta.set(config, { requestId, startTime });

        // Add authentication if available (but not for gateway requests in dev)
        const isGatewayRequest = this.config.baseURL.startsWith('/api/');
        if (!isGatewayRequest || isProduction) {
          const token = getAuthToken();
          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
        }

        // Add user context
        const userContext = getUserContext();
        if (userContext) {
          config.headers['X-User-Context'] = JSON.stringify(userContext);
        }

        this.metrics.totalRequests++;

        if (this.config.enableLogging) {
          console.log(`[AI Service] ${config.method?.toUpperCase()} ${config.url}`, {
            requestId,
            headers: sanitizeHeaders(config.headers),
            baseURL: this.config.baseURL,
          });
        }

        return config;
      },
      (error: AxiosError) => {
        this.metrics.failedRequests++;
        console.error('[AI Service] Request interceptor error:', error.message);
        return Promise.reject(new AIServiceError('REQUEST_SETUP_ERROR', error.message, false, error));
      }
    );
  }

  private setupResponseInterceptor(instance: ReturnType<typeof axios.create>): void {
    instance.interceptors.response.use(
      (response: AxiosResponse) => {
        const meta = this.requestMeta.get(response.config);
        const processingTime = meta ? Date.now() - meta.startTime : 0;

        this.metrics.successfulRequests++;
        this.updateAverageResponseTime(processingTime);

        if (this.config.enableLogging) {
          console.log(`[AI Service] ${response.status} ${response.config.method?.toUpperCase()} ${response.config.url}`, {
            processingTime: `${processingTime}ms`,
            requestId: meta?.requestId,
          });
        }

        return response;
      },
      (error: AxiosError) => {
        const meta = error.config ? this.requestMeta.get(error.config) : undefined;
        const processingTime = meta ? Date.now() - meta.startTime : 0;

        this.metrics.failedRequests++;
        this.metrics.lastError = error.message;

        if (this.config.enableLogging) {
          console.error('[AI Service] Request failed:', {
            message: error.message,
            status: error.response?.status,
            processingTime: `${processingTime}ms`,
            requestId: meta?.requestId,
            url: error.config?.url,
          });
        }

        this.handleSpecificErrors(error);
        return Promise.reject(this.createEnhancedError(error));
      }
    );
  }

  private async checkConnection(): Promise<void> {
    const now = Date.now();
    if (now - this.lastConnectionCheck < CONNECTION_CHECK_INTERVAL) return;
    
    this.lastConnectionCheck = now;

    try {
      await this.requestWithRetry(
        () => this.api.get(HEALTH_PATH, { 
          timeout: 5000,
          headers: { 'X-Health-Check': 'true' }
        }),
        { skipRetry: true }
      );

      this.connected = true;
      this.connectionAttempts = 0;
      
      if (this.config.enableLogging) {
        console.log('[AI Service] Connection check successful');
      }
    } catch (error) {
      this.connected = false;
      this.connectionAttempts++;
      
      if (this.config.enableLogging) {
        console.warn(`[AI Service] Connection check failed (attempt ${this.connectionAttempts}):`, (error as Error).message);
      }
    }
  }

  private async requestWithRetry<T>(
    fn: () => Promise<T>, 
    options: { skipRetry?: boolean } = {}
  ): Promise<T> {
    if (options.skipRetry) return fn();

    const maxRetries = this.config.maxRetries;
    const baseDelay = this.config.retryDelay;

    let lastError: unknown;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (err) {
        const error = err as AxiosError;
        const status = error.response?.status;
        const code = (error as any).code;

        // Don't retry on certain errors
        const isAuthError = status === 401 || status === 403;
        const isValidationError = status === 422;
        const isClientError = status && status >= 400 && status < 500 && !isAuthError;
        
        if (attempt === maxRetries || isAuthError || isValidationError || isClientError) {
          lastError = error;
          break;
        }

        // Calculate exponential backoff with jitter
        const jitter = Math.floor(Math.random() * 250);
        const delay = baseDelay * Math.pow(2, attempt) + jitter;
        
        if (this.config.enableLogging) {
          console.warn(`[AI Service] Retrying request (${attempt + 1}/${maxRetries}) in ${delay}ms`);
        }
        
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw lastError;
  }

  private startPeriodicCleanup(): void {
    this.stopPeriodicCleanup();

    this.cleanupTimer = setInterval(() => {
      try {
        this.cleanupCache();
        this.cleanupActiveRequests();
      } catch (err) {
        if (this.config.enableLogging) {
          console.warn('[AI Service] Periodic cleanup error:', err);
        }
      }
    }, 300000); // 5 minutes

    if (isBrowser) {
      window.addEventListener('beforeunload', () => this.stopPeriodicCleanup(), { once: true });
    }
  }

  private stopPeriodicCleanup(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = undefined;
    }
  }

  private cleanupCache(): void {
    const now = Date.now();
    const expired: string[] = [];

    for (const [key, { timestamp }] of this.responseCache) {
      if (now - timestamp > this.config.cacheDuration) {
        expired.push(key);
      }
    }

    expired.forEach(key => this.responseCache.delete(key));

    // Remove excess entries
    if (this.responseCache.size > MAX_CACHE_SIZE) {
      const entries = [...this.responseCache.entries()]
        .sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      const excess = this.responseCache.size - MAX_CACHE_SIZE;
      for (let i = 0; i < excess; i++) {
        this.responseCache.delete(entries[i][0]);
      }
    }
  }

  private cleanupActiveRequests(): void {
    for (const [id, controller] of this.activeRequests) {
      if (controller.signal.aborted) {
        this.activeRequests.delete(id);
      }
    }
  }

  private handleSpecificErrors(error: AxiosError): void {
    const status = error.response?.status;
    const code = (error as any).code;

    if (status === 401) {
      this.handleUnauthorized();
    } else if (status === 429) {
      this.handleRateLimit(error);
    } else if (status === 503) {
      this.handleServiceUnavailable();
    } else if (code === 'ECONNABORTED') {
      this.handleTimeout();
    } else if (code === 'ERR_NETWORK' || code === 'NETWORK_ERROR') {
      this.handleNetworkError();
    }
  }

  private createEnhancedError(axiosError: AxiosError): AIServiceError {
    const status = axiosError.response?.status;
    const data = axiosError.response?.data as any;

    if (status === 401) {
      return new AuthenticationError(data?.message || 'Authentication required');
    }
    
    if ((axiosError as any).code === 'ECONNABORTED') {
      return new TimeoutError(data?.message || 'Request timed out');
    }
    
    if (!axiosError.response) {
      return new NetworkError('Unable to connect to AI service');
    }

    const message = data?.error?.message || data?.message || axiosError.message;
    const code = data?.error?.code || `HTTP_${status}`;
    const retryable = status ? status >= 500 || status === 429 : true;

    return new AIServiceError(code, message, retryable, {
      status,
      originalError: axiosError.message,
      response: isProduction ? undefined : data,
    });
  }

  private handleUnauthorized(): void {
    if (isBrowser) {
      try {
        localStorage.removeItem('authToken');
        sessionStorage.removeItem('authToken');
        localStorage.removeItem('access_token');
        sessionStorage.removeItem('access_token');
      } catch {
        // Ignore storage errors
      }

      // Emit custom event for app to handle
      window.dispatchEvent(new CustomEvent('ai-service-auth-required'));
    }
  }

  private handleRateLimit(error: AxiosError): void {
    const retryAfter = (error.response?.headers as any)?.['retry-after'];
    const delay = retryAfter ? parseInt(retryAfter, 10) * 1000 : 60000;
    
    if (this.config.enableLogging) {
      console.warn(`[AI Service] Rate limited. Retry after ${delay}ms`);
    }
    
    if (isBrowser) {
      window.dispatchEvent(
        new CustomEvent('ai-service-rate-limited', { detail: { retryAfter: delay } })
      );
    }
  }

  private handleServiceUnavailable(): void {
    this.connected = false;
    if (this.config.enableLogging) {
      console.warn('[AI Service] Service temporarily unavailable');
    }
  }

  private handleTimeout(): void {
    if (this.config.enableLogging) {
      console.warn('[AI Service] Request timed out');
    }
  }

  private handleNetworkError(): void {
    this.connected = false;
    if (this.config.enableLogging) {
      console.warn('[AI Service] Network error detected');
    }
  }

  private updateAverageResponseTime(newTime: number): void {
    const n = this.metrics.successfulRequests;
    if (n <= 1) {
      this.metrics.averageResponseTime = newTime;
    } else {
      this.metrics.averageResponseTime = 
        ((this.metrics.averageResponseTime * (n - 1)) + newTime) / n;
    }
  }

  private getCachedResponse(key: string): AIResponse | null {
    const entry = this.responseCache.get(key);
    if (entry && Date.now() - entry.timestamp < this.config.cacheDuration) {
      return entry.response;
    }
    this.responseCache.delete(key);
    return null;
  }

  private setCachedResponse(key: string, response: AIResponse): void {
    this.responseCache.set(key, { 
      response, 
      timestamp: Date.now() 
    });
  }

  /* =========================
   Public API
   ========================= */
  public isConnected(): boolean {
    return this.connected;
  }

  public getConnectionStatus(): 'connected' | 'disconnected' | 'connecting' {
    if (this.connectionAttempts > 0 && !this.connected) return 'connecting';
    return this.connected ? 'connected' : 'disconnected';
  }

  public getMetrics(): ConnectionMetrics {
    return {
      ...this.metrics,
      uptime: Date.now() - this.metrics.uptime
    };
  }

  public async sendMessage(message: string, context?: RequestContext): Promise<AIResponse> {
    if (!message?.trim()) {
      return {
        success: false,
        error: {
          code: 'INVALID_INPUT',
          message: 'Message cannot be empty',
          retryable: false
        }
      };
    }

    const requestId = context?.requestId || generateRequestId();

    // Check cache first
    if (context?.cacheKey) {
      const cached = this.getCachedResponse(context.cacheKey);
      if (cached) return cached;
    }

    // Use mock response if not connected and mock mode enabled
    if (!this.connected && this.config.enableMockMode) {
      if (this.config.enableLogging) {
        console.log('[AI Service] Using mock response (service unavailable)');
      }
      return this.getMockResponse(message);
    }

    // Check connection
    await this.checkConnection();

    try {
      const abortController = new AbortController();
      this.activeRequests.set(requestId, abortController);

      const startTime = performance.now?.() ?? Date.now();

      const response = await this.requestWithRetry(() =>
        this.api.post('/discovery/query', {
          query: message,
          context: {
            timestamp: new Date().toISOString(),
            clientType: 'web',
            userAgent: isBrowser ? navigator.userAgent : 'node',
            ...context,
          },
        }, {
          timeout: context?.timeout || this.config.timeout,
          signal: abortController.signal,
        })
      );

      const processingTime = Math.round((performance.now?.() ?? Date.now()) - startTime);

      const aiResponse: AIResponse = {
        success: true,
        data: this.normalizeResponseData(response.data?.data, message),
        meta: {
          processingTime,
          model: response.data?.meta?.model || 'unknown',
          requestId,
          timestamp: new Date().toISOString(),
          ...response.data?.meta,
        },
      };

      // Cache successful response
      if (context?.cacheKey) {
        this.setCachedResponse(context.cacheKey, aiResponse);
      }

      return aiResponse;

    } catch (error) {
      return this.handleRequestError(error, requestId);
    } finally {
      this.activeRequests.delete(requestId);
    }
  }

  private normalizeResponseData(rawData: any, originalQuery?: string): AIResponse['data'] {
    if (!rawData) {
      return {
        message: 'No response received from AI service.',
        type: 'text'
      };
    }

    // If already normalized
    if (rawData.type && rawData.message) {
      return rawData as AIResponse['data'];
    }

    // Handle different response types
    if (rawData.sql && rawData.explanation) {
      return {
        message: "Here's the generated SQL query:",
        type: 'query',
        results: {
          sql: rawData.sql,
          explanation: rawData.explanation,
          tables: rawData.tables,
          fields: rawData.fields,
          confidence: rawData.confidence,
          warnings: rawData.warnings,
        },
        actions: [{
          type: 'view_details',
          label: 'Copy SQL',
          payload: { sql: rawData.sql, query: originalQuery }
        }],
      };
    }

    if (rawData.analysis && rawData.qualityIssues) {
      return {
        message: "Data quality analysis complete:",
        type: 'analysis',
        results: rawData,
        actions: [{
          type: 'create_rule',
          label: 'Create Quality Rules',
          payload: { issues: rawData.qualityIssues }
        }],
      };
    }

    // Fallback for unknown formats
    if (typeof rawData === 'string') {
      return { message: rawData, type: 'text' };
    }

    return {
      message: 'Analysis complete.',
      type: 'data',
      results: rawData
    };
  }

  private handleRequestError(error: unknown, requestId?: string): AIResponse {
    const aiError = error instanceof AIServiceError
      ? error
      : (error as AxiosError)?.isAxiosError
        ? this.createEnhancedError(error as AxiosError)
        : new AIServiceError(
            'UNKNOWN_ERROR',
            (error as Error)?.message || 'An unexpected error occurred',
            false,
            isProduction ? undefined : error
          );

    return {
      success: false,
      error: {
        code: aiError.code,
        message: aiError.message,
        details: isProduction ? undefined : aiError.details,
        retryable: aiError.retryable,
      },
      meta: {
        processingTime: 0,
        model: 'error',
        requestId,
        timestamp: new Date().toISOString(),
      },
    };
  }

  private getMockResponse(query: string): AIResponse {
    const requestId = generateRequestId();
    const lowerQuery = query.toLowerCase();

    if (lowerQuery.includes('hello') || lowerQuery.includes('hi')) {
      return {
        success: true,
        data: {
          message: "Hello! I'm your AI assistant. I can help with data discovery, quality analysis, and more.",
          type: 'text',
          suggestions: [
            'Show me data sources',
            'Analyze data quality',
            'Find sensitive data',
          ]
        },
        meta: {
          processingTime: 100,
          model: 'mock',
          requestId,
          timestamp: new Date().toISOString(),
        }
      };
    }

    return {
      success: true,
      data: {
        message: `I understand you're asking about "${query}". This is a mock response since the AI service is not available.`,
        type: 'text',
        suggestions: ['Try again when service is available']
      },
      meta: {
        processingTime: 100,
        model: 'mock',
        requestId,
        timestamp: new Date().toISOString(),
      }
    };
  }

  public cancelRequest(requestId: string): boolean {
    const controller = this.activeRequests.get(requestId);
    if (controller && !controller.signal.aborted) {
      controller.abort();
      this.activeRequests.delete(requestId);
      return true;
    }
    return false;
  }

  public cancelAllRequests(): void {
    for (const controller of this.activeRequests.values()) {
      if (!controller.signal.aborted) {
        controller.abort();
      }
    }
    this.activeRequests.clear();
  }

  public destroy(): void {
    this.stopPeriodicCleanup();
    this.cancelAllRequests();
    this.responseCache.clear();
    this.connected = false;
  }
}

/* =========================
   Singleton Export
   ========================= */
export const aiAssistantService = new AIAssistantService();
export default aiAssistantService;

// Named exports for flexibility
export { AIAssistantService, AIServiceError, AuthenticationError, NetworkError, TimeoutError };



------------------------------------------------------------
FILE: frontend\src\services\api\auth.ts
------------------------------------------------------------

import api from "@services/http";
 // adjust ../ depth to reach /src/services/http
import { clearAccessToken, setAccessToken } from "./token";

export async function login(creds: { email: string; password: string }) {
  const { data } = await api.post("/auth/login", creds);
  const access = (data as any)?.accessToken;
  if (access) setAccessToken(access);           // if your backend returns it
  return data;
}

export function logout() {
  clearAccessToken();
  // optionally call /auth/logout server route if you have it
}



------------------------------------------------------------
FILE: frontend\src\services\api\client.ts
------------------------------------------------------------
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig } from "axios";
import { clearAccessToken, getAccessToken, setAccessToken } from "./token";

let isRefreshing = false;
let queue: { resolve: (v?: unknown) => void; reject: (e: any) => void; config: AxiosRequestConfig }[] = [];

function flushQueue(error: any) {
  queue.splice(0).forEach(({ resolve, reject, config }) =>
    error ? reject(error) : resolve(api(config))
  );
}

export const api: AxiosInstance = axios.create({
  baseURL: "/api",            // Vite proxy will send this to the gateway
  withCredentials: true,      // needed if refresh/login use HttpOnly cookies
  timeout: 30000,
});

api.interceptors.request.use((config) => {
  const t = getAccessToken();
  if (t) {
    config.headers = config.headers ?? {};
    (config.headers as any)["Authorization"] = `Bearer ${t}`;
  }
  return config;
});

api.interceptors.response.use(
  (r) => r,
  async (err: AxiosError) => {
    const original = err.config!;
    if (err.response?.status === 401 && !(original as any)._retry) {
      (original as any)._retry = true;

      if (isRefreshing) {
        return new Promise((resolve, reject) => queue.push({ resolve, reject, config: original }));
      }
      try {
        isRefreshing = true;
        const { data } = await axios.post("/auth/refresh", {}, { baseURL: "/api", withCredentials: true });
        const newAccess = (data as any)?.accessToken;
        if (!newAccess) throw new Error("No access token in refresh response");
        setAccessToken(newAccess);
        flushQueue(null);
        return api(original);
      } catch (e) {
        flushQueue(e);
        clearAccessToken();
        return Promise.reject(e);
      } finally {
        isRefreshing = false;
      }
    }
    return Promise.reject(err);
  }
);



------------------------------------------------------------
FILE: frontend\src\services\api\dataAssets.ts
------------------------------------------------------------
// src/services/api/dataAssets.ts
import type {
    Asset,
    AssetFilters,
    AssetLineage,
    AssetProfile,
    AssetSearchRequest,
    AssetUsageStats,
    CreateAssetRequest,
    PaginatedAssets,
    UpdateAssetRequest
} from '@/types/dataAssets';
import axios from 'axios';

// Create HTTP client with the same base URL resolution as your other services
function resolveBaseUrl() {
  const env = import.meta.env.VITE_API_BASE_URL || import.meta.env.VITE_API_URL;
  if (!env) return '/api';
  if (env.startsWith(':')) {
    return `${window.location.protocol}//${window.location.hostname}${env}`;
  }
  if (/^[\w.-]+:\d+$/.test(env)) {
    return `${window.location.protocol}//${env}`;
  }
  if (env.startsWith('http')) {
    try {
      const url = new URL(env);
      return url.pathname === '/' ? '/api' : url.pathname;
    } catch {
      return '/api';
    }
  }
  return env;
}

const http = axios.create({
  baseURL: resolveBaseUrl(),
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Assets API
export const dataAssetsApi = {
  // List and search assets
  async list(filters: AssetFilters = {}): Promise<PaginatedAssets> {
    try {
      const params = {
        page: filters.page || 1,
        limit: filters.limit || 20,
        ...(filters.search && { search: filters.search }),
        ...(filters.type && { type: filters.type }),
        ...(filters.owner && { owner: filters.owner }),
        ...(filters.dataSourceId && { dataSourceId: filters.dataSourceId }),
        ...(filters.tags && filters.tags.length > 0 && { tags: filters.tags.join(',') }),
        ...(filters.quality && { quality: filters.quality }),
        ...(filters.classification && { classification: filters.classification }),
        ...(filters.sortBy && { sortBy: filters.sortBy }),
        ...(filters.sortOrder && { sortOrder: filters.sortOrder }),
      };

      const { data } = await http.get<PaginatedAssets>('/assets', { params });
      return data;
    } catch (error: any) {
      console.error('Failed to list assets:', error);
      
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        console.warn('API not available, returning mock data');
        return getMockAssets(filters);
      }
      
      throw error;
    }
  },

  // Get single asset by ID
  async getById(id: string): Promise<Asset> {
    try {
      const { data } = await http.get<Asset>(`/assets/${id}`);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return getMockAsset(id);
      }
      throw error;
    }
  },

  // Search assets with advanced options
  async search(request: AssetSearchRequest): Promise<PaginatedAssets> {
    try {
      const { data } = await http.post<PaginatedAssets>('/assets/search', request);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return getMockAssets(request);
      }
      throw error;
    }
  },

  // Create new asset
  async create(asset: CreateAssetRequest): Promise<Asset> {
    try {
      const { data } = await http.post<Asset>('/assets', asset);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return {
          id: `mock-${Date.now()}`,
          ...asset,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          dataSourceName: 'Mock Data Source',
        } as Asset;
      }
      throw error;
    }
  },

  // Update asset
  async update(id: string, updates: UpdateAssetRequest): Promise<Asset> {
    try {
      const { data } = await http.put<Asset>(`/assets/${id}`, updates);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        const existing = getMockAsset(id);
        return { ...existing, ...updates, updatedAt: new Date().toISOString() };
      }
      throw error;
    }
  },

  // Delete asset
  async delete(id: string): Promise<void> {
    try {
      await http.delete(`/assets/${id}`);
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        console.warn('API not available, mock deleting asset');
        return;
      }
      throw error;
    }
  },

  // Get asset profile/statistics
  async getProfile(id: string): Promise<AssetProfile> {
    try {
      const { data } = await http.get<AssetProfile>(`/assets/${id}/profile`);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return getMockProfile(id);
      }
      throw error;
    }
  },

  // Get asset lineage
  async getLineage(id: string): Promise<AssetLineage> {
    try {
      const { data } = await http.get<AssetLineage>(`/assets/${id}/lineage`);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return getMockLineage(id);
      }
      throw error;
    }
  },

  // Get usage statistics
  async getUsageStats(id: string, period: string = '30d'): Promise<AssetUsageStats> {
    try {
      const { data } = await http.get<AssetUsageStats>(`/assets/${id}/usage`, {
        params: { period }
      });
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return getMockUsageStats(id, period);
      }
      throw error;
    }
  },

  // Add tags to asset
  async addTags(id: string, tags: string[]): Promise<Asset> {
    try {
      const { data } = await http.post<Asset>(`/assets/${id}/tags`, { tags });
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        const existing = getMockAsset(id);
        return {
          ...existing,
          tags: [...(existing.tags || []), ...tags],
          updatedAt: new Date().toISOString()
        };
      }
      throw error;
    }
  },

  // Remove tags from asset
  async removeTags(id: string, tags: string[]): Promise<Asset> {
    try {
      const { data } = await http.delete<Asset>(`/assets/${id}/tags`, { 
        data: { tags } 
      });
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        const existing = getMockAsset(id);
        return {
          ...existing,
          tags: existing.tags?.filter(tag => !tags.includes(tag)) || [],
          updatedAt: new Date().toISOString()
        };
      }
      throw error;
    }
  },

  // Request access to asset
  async requestAccess(id: string, reason?: string): Promise<{ requestId: string; status: string }> {
    try {
      const { data } = await http.post(`/assets/${id}/access-request`, { reason });
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return {
          requestId: `req-${Date.now()}`,
          status: 'pending'
        };
      }
      throw error;
    }
  },

  // Trigger asset profiling
  async triggerProfiling(id: string): Promise<{ jobId: string; status: string }> {
    try {
      const { data } = await http.post(`/assets/${id}/profile`);
      return data;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED' || error.message?.includes('socket hang up')) {
        return {
          jobId: `job-${Date.now()}`,
          status: 'started'
        };
      }
      throw error;
    }
  }
};

// Mock data functions (fallback when API is not available)
function getMockAssets(filters: AssetFilters): PaginatedAssets {
  const mockAssets: Asset[] = [
    {
      id: '1',
      name: 'customers',
      type: 'table',
      description: 'Customer information and profiles',
      dataSourceId: '1',
      dataSourceName: 'Production PostgreSQL',
      schema: 'public',
      owner: 'john.doe@company.com',
      tags: ['PII', 'customer', 'production'],
      rowCount: 125430,
      columnCount: 15,
      quality: 'high',
      classification: 'confidential',
      createdAt: '2024-01-15T10:30:00Z',
      updatedAt: '2024-01-20T14:22:00Z',
      lastAccessedAt: '2024-01-20T12:00:00Z',
    },
    {
      id: '2',
      name: 'orders',
      type: 'table',
      description: 'Order transactions and details',
      dataSourceId: '1',
      dataSourceName: 'Production PostgreSQL',
      schema: 'public',
      owner: 'jane.smith@company.com',
      tags: ['orders', 'transactions', 'revenue'],
      rowCount: 892341,
      columnCount: 22,
      quality: 'high',
      classification: 'internal',
      createdAt: '2024-01-10T09:15:00Z',
      updatedAt: '2024-01-20T15:10:00Z',
      lastAccessedAt: '2024-01-20T14:30:00Z',
    },
    {
      id: '3',
      name: 'user_analytics',
      type: 'view',
      description: 'Aggregated user behavior analytics',
      dataSourceId: '2',
      dataSourceName: 'Analytics Snowflake',
      schema: 'analytics',
      owner: 'data.team@company.com',
      tags: ['analytics', 'behavior', 'aggregated'],
      rowCount: 45123,
      columnCount: 8,
      quality: 'medium',
      classification: 'internal',
      createdAt: '2024-01-05T11:20:00Z',
      updatedAt: '2024-01-19T23:30:00Z',
      lastAccessedAt: '2024-01-19T20:15:00Z',
    }
  ];

  // Apply filters
  let filtered = mockAssets;
  
  if (filters.search) {
    const search = filters.search.toLowerCase();
    filtered = filtered.filter(asset => 
      asset.name.toLowerCase().includes(search) ||
      asset.description?.toLowerCase().includes(search) ||
      asset.tags?.some(tag => tag.toLowerCase().includes(search))
    );
  }
  
  if (filters.type) {
    filtered = filtered.filter(asset => asset.type === filters.type);
  }
  
  if (filters.owner) {
    filtered = filtered.filter(asset => 
      asset.owner?.toLowerCase().includes(filters.owner!.toLowerCase())
    );
  }

  // Pagination
  const page = filters.page || 1;
  const limit = filters.limit || 20;
  const start = (page - 1) * limit;
  const end = start + limit;
  const paginatedData = filtered.slice(start, end);

  return {
    data: paginatedData,
    pagination: {
      page,
      limit,
      total: filtered.length,
      totalPages: Math.ceil(filtered.length / limit)
    }
  };
}

function getMockAsset(id: string): Asset {
  return {
    id,
    name: `Mock Asset ${id}`,
    type: 'table',
    description: 'Mock asset for development',
    dataSourceId: '1',
    dataSourceName: 'Mock Data Source',
    schema: 'public',
    owner: 'mock.user@company.com',
    tags: ['mock', 'development'],
    rowCount: 10000,
    columnCount: 5,
    quality: 'medium',
    classification: 'internal',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

function getMockProfile(id: string): AssetProfile {
  return {
    assetId: id,
    profiledAt: new Date().toISOString(),
    rowCount: 10000,
    nullCount: { column1: 0, column2: 10, column3: 5 },
    distinctCount: { column1: 9950, column2: 100, column3: 50 },
    minValues: { column1: 1, column2: 'A', column3: 100 },
    maxValues: { column1: 10000, column2: 'Z', column3: 1000 },
    averages: { column1: 5000, column3: 500 }
  };
}

function getMockLineage(id: string): AssetLineage {
  return {
    assetId: id,
    upstream: [],
    downstream: []
  };
}

function getMockUsageStats(id: string, period: string): AssetUsageStats {
  return {
    assetId: id,
    period,
    queryCount: 150,
    uniqueUsers: 12,
    accessCount: 245,
    averageQueryTime: 1250,
    topUsers: [
      { userId: '1', userName: 'John Doe', queryCount: 45 },
      { userId: '2', userName: 'Jane Smith', queryCount: 32 }
    ]
  };
}

export default dataAssetsApi;


------------------------------------------------------------
FILE: frontend\src\services\api\dataSources.ts
------------------------------------------------------------
// src/services/api/dataSources.ts
import type {
  Asset,
  AssetFilters,
  ConnectionConfig,
  ConnectionTestResult,
  CreateDataSourcePayload,
  DataSource,
  DataSourceFilters,
  DataSourceMetrics,
  DataSourceType,
  PaginatedDataSources,
  SyncResult,
  UpdateDataSourcePayload,
} from '@/types/dataSources';
import http from "@services/http";

/* -------------------------------- Helpers -------------------------------- */

function normalizeTestResult(raw: any): ConnectionTestResult {
  if (!raw || typeof raw !== 'object') {
    return {
      success: true,
      message: 'Connection OK',
      testedAt: new Date().toISOString(),
    };
  }
  // keep server fields but ensure the basics are present
  return {
    success:
      raw.success ??
      (raw.connectionStatus ? raw.connectionStatus === 'connected' : undefined),
    message: raw.message,
    testedAt: raw.testedAt ?? raw.timestamp ?? new Date().toISOString(),
    responseTimeMs: raw.responseTimeMs ?? raw.latencyMs,
    ...raw,
  };
}

function normalizeSyncResult(raw: any, id: string): SyncResult {
  // Handle 202 with empty body, boolean, etc.
  if (!raw || typeof raw !== 'object') {
    return {
      syncId: `local_${Date.now()}_${id}`,
      status: 'started',
      startedAt: new Date().toISOString(),
      errors: [],
      message: 'Sync started',
    };
  }

  const syncId =
    raw.syncId || raw.id || raw.runId || `local_${Date.now()}_${id}`;

  let status: SyncResult['status'];
  if (raw.status === 'ok' || raw.ok === true) status = 'started';
  else status =
    (raw.status as SyncResult['status']) ??
    (raw.completedAt || raw.completed ? 'completed' : 'started');

  return {
    syncId,
    status,
    startedAt: raw.startedAt ?? raw.started ?? raw.timestamp,
    completedAt: raw.completedAt ?? raw.completed,
    tablesScanned: raw.tablesScanned ?? raw.scanned ?? raw.count ?? 0,
    newTables: raw.newTables ?? 0,
    updatedTables: raw.updatedTables ?? 0,
    errors: raw.errors ?? (raw.error ? [String(raw.error)] : []),
    message: raw.message,
    ...raw, // keep any extra fields the server includes
  };
}

/* ------------------------------ List params ------------------------------- */

export interface ListDataSourcesParams extends DataSourceFilters {
  page?: number;
  limit?: number;
  sortBy?: 'name' | 'type' | 'status' | 'createdAt' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

export interface ListAssetsParams extends AssetFilters {
  page?: number;
  limit?: number;
  dataSourceId?: string;
  sortBy?: 'name' | 'type' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}

/* ------------------------------ DataSources API --------------------------- */

export const dataSourcesApi = {
  async list(params: ListDataSourcesParams = {}) {
    const { data } = await http.get<PaginatedDataSources>('/data-sources', { params });
    return data;
  },

  async getById(id: string) {
    const { data } = await http.get<DataSource>(`/data-sources/${id}`);
    return data;
  },

  async create(payload: CreateDataSourcePayload) {
    const { data } = await http.post<DataSource>('/data-sources', payload);
    return data;
  },

  async update(id: string, payload: UpdateDataSourcePayload) {
    const { data } = await http.put<DataSource>(`/data-sources/${id}`, payload);
    return data;
  },

  async delete(id: string) {
    await http.delete(`/data-sources/${id}`);
  },

  // Test by id â€” always return a filled object
  async test(id: string) {
    const res = await http.post<ConnectionTestResult>(`/data-sources/${id}/test`);
    return normalizeTestResult(res.data);
  },

  // Test config before creating
  async testConfig(type: DataSourceType, config: ConnectionConfig) {
    const res = await http.post<ConnectionTestResult>('/data-sources/test', { type, config });
    return normalizeTestResult(res.data);
  },

  // Sync/discover â€” normalize even if backend returns empty body/202
  async sync(id: string) {
    const res = await http.post<SyncResult>(`/data-sources/${id}/sync`);
    return normalizeSyncResult(res.data, id);
  },

  // Sync status â€” normalize too
  async getSyncStatus(id: string) {
    const res = await http.get<SyncResult>(`/data-sources/${id}/sync/status`);
    return normalizeSyncResult(res.data, id);
  },

  async updateStatus(id: string, status: DataSource['status'], reason?: string) {
    const { data } = await http.patch<DataSource>(`/data-sources/${id}/status`, { status, reason });
    return data;
  },

  async getMetrics(id?: string) {
    const endpoint = id ? `/data-sources/${id}/metrics` : '/data-sources/metrics';
    const { data } = await http.get<DataSourceMetrics>(endpoint);
    return data;
  },

  async getHealth(id: string) {
    const { data } = await http.get<DataSource['healthStatus']>(`/data-sources/${id}/health`);
    return data;
  },

  async duplicate(id: string, newName: string) {
    const { data } = await http.post<DataSource>(`/data-sources/${id}/duplicate`, { name: newName });
    return data;
  },

  async exportConfig(id: string) {
    const { data } = await http.get(`/data-sources/${id}/export`);
    return data;
  },

  async importConfig(config: any) {
    const { data } = await http.post<DataSource>('/data-sources/import', config);
    return data;
  },

  async getTemplates(type?: DataSourceType) {
    const params = type ? { type } : {};
    const { data } = await http.get('/data-sources/templates', { params });
    return data;
  },

  async validateField(type: DataSourceType, field: string, value: any, config: ConnectionConfig) {
    const { data } = await http.post('/data-sources/validate-field', {
      type, field, value, config,
    });
    return data;
  },
};

/* --------------------------------- Assets --------------------------------- */

export const assetsApi = {
  async list(params: ListAssetsParams = {}) {
    const { data } = await http.get('/assets', { params });
    return data;
  },

  async getById(id: string) {
    const { data } = await http.get<Asset>(`/assets/${id}`);
    return data;
  },

  async getSchema(id: string) {
    const { data } = await http.get(`/assets/${id}/schema`);
    return data;
  },

  async getLineage(id: string) {
    const { data } = await http.get(`/assets/${id}/lineage`);
    return data;
  },

  async getProfile(id: string) {
    const { data } = await http.get(`/assets/${id}/profile`);
    return data;
  },

  async getStats(id: string, period: '7d' | '30d' | '90d' = '30d') {
    const { data } = await http.get(`/assets/${id}/stats`, { params: { period } });
    return data;
  },

  async update(id: string, payload: Partial<Asset>) {
    const { data } = await http.put<Asset>(`/assets/${id}`, payload);
    return data;
  },

  async addTags(id: string, tags: string[]) {
    const { data } = await http.post(`/assets/${id}/tags`, { tags });
    return data;
  },

  async removeTags(id: string, tags: string[]) {
    const { data } = await http.delete(`/assets/${id}/tags`, { data: { tags } });
    return data;
  },

  async search(query: string, filters?: AssetFilters) {
    const { data } = await http.get('/assets/search', { params: { q: query, ...filters } });
    return data;
  },

  async scan(id: string) {
    const { data } = await http.post(`/assets/${id}/scan`);
    return data;
  },

  async updateClassification(id: string, classification: string) {
    const { data } = await http.put(`/assets/${id}/classification`, { classification });
    return data;
  },
};

/* --------------------------------- Health --------------------------------- */

export const healthApi = {
  async getSystemHealth() {
    const { data } = await http.get('/health');
    return data;
  },

  async getDataSourcesHealth() {
    const { data } = await http.get('/health/data-sources');
    return data;
  },

  async testConnectionType(type: DataSourceType, config: ConnectionConfig) {
    const res = await http.post(`/health/${type}`, config);
    return normalizeTestResult(res.data);
  },
};

/* -------------------------------- Utilities ------------------------------- */

export const dataSourceUtils = {
  getTypeDisplayName(type: DataSourceType): string {
    const displayNames: Record<DataSourceType, string> = {
      postgresql: 'PostgreSQL',
      mysql: 'MySQL',
      mssql: 'SQL Server',
      mongodb: 'MongoDB',
      redis: 'Redis',
      snowflake: 'Snowflake',
      bigquery: 'BigQuery',
      redshift: 'Amazon Redshift',
      databricks: 'Databricks',
      s3: 'Amazon S3',
      'azure-blob': 'Azure Blob Storage',
      gcs: 'Google Cloud Storage',
      kafka: 'Apache Kafka',
      api: 'REST API',
      file: 'File System',
      ftp: 'FTP/SFTP',
      elasticsearch: 'Elasticsearch',
      oracle: 'Oracle Database',
    };
    return displayNames[type] || type;
  },

  getStatusColor(status: DataSource['status']): string {
    const colors = { active: 'green', inactive: 'gray', pending: 'yellow', error: 'red', testing: 'blue' };
    return colors[status] || 'gray';
  },

  getStatusText(status: DataSource['status']): string {
    const texts = { active: 'Active', inactive: 'Inactive', pending: 'Pending', error: 'Error', testing: 'Testing' };
    return texts[status] || status;
  },

  supportsFeature(type: DataSourceType, feature: 'sync' | 'assets' | 'streaming' | 'files'): boolean {
    const features: Record<DataSourceType, string[]> = {
      postgresql: ['sync', 'assets'],
      mysql: ['sync', 'assets'],
      mssql: ['sync', 'assets'],
      mongodb: ['sync', 'assets'],
      redis: ['sync'],
      snowflake: ['sync', 'assets'],
      bigquery: ['sync', 'assets'],
      redshift: ['sync', 'assets'],
      databricks: ['sync', 'assets'],
      s3: ['files'],
      'azure-blob': ['files'],
      gcs: ['files'],
      kafka: ['streaming'],
      api: [],
      file: ['files'],
      ftp: ['files'],
      elasticsearch: ['sync', 'assets'],
      oracle: ['sync', 'assets'],
    };
    return features[type]?.includes(feature) || false;
  },

  maskConfig(config: ConnectionConfig): ConnectionConfig {
    const masked = { ...config };
    const sensitive = ['password', 'apiKey', 'secretAccessKey', 'serviceAccountKey', 'accessToken'];
    for (const k of sensitive) if (k in masked && (masked as any)[k]) (masked as any)[k] = '***masked***';
    return masked;
  },

  formatLastSync(lastSync?: string): string {
    if (!lastSync) return 'Never';
    const date = new Date(lastSync);
    const diffMs = Date.now() - date.getTime();
    const hours = Math.floor(diffMs / (1000 * 60 * 60));
    const days = Math.floor(hours / 24);
    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    const minutes = Math.floor(diffMs / (1000 * 60));
    return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  },
};

/* ---------------------- Legacy named exports (compat) --------------------- */

export async function listDataSources(params: ListDataSourcesParams = {}) {
  return dataSourcesApi.list(params);
}
export async function createDataSource(payload: CreateDataSourcePayload) {
  return dataSourcesApi.create(payload);
}
export async function deleteDataSource(id: string) {
  return dataSourcesApi.delete(id);
}
export async function testDataSource(id: string) {
  return dataSourcesApi.test(id);
}
export async function syncDataSource(id: string) {
  return dataSourcesApi.sync(id);
}

export default {
  dataSources: dataSourcesApi,
  assets: assetsApi,
  health: healthApi,
  utils: dataSourceUtils,
};



------------------------------------------------------------
FILE: frontend\src\services\api\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\services\api\notifications.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\api\pipelines.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\api\qualityRules.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\api\Requests.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\api\token.ts
------------------------------------------------------------
const KEY = "access_token";

export function setAccessToken(t?: string | null) {
  if (t) localStorage.setItem(KEY, t);
  else localStorage.removeItem(KEY);
}
export function getAccessToken(): string | null {
  return localStorage.getItem(KEY);
}
export function clearAccessToken() {
  localStorage.removeItem(KEY);
}



------------------------------------------------------------
FILE: frontend\src\services\assets.ts
------------------------------------------------------------
import type { ApiListResponse, ApiResponse } from '../types/api';
import type { Asset, AssetStats } from '../types/asset';
import { http } from './http';

export interface ListAssetsQuery {
  page?: number;
  limit?: number;
  type?: string;
  dataSourceId?: string;
  classification?: 'public' | 'internal' | 'confidential' | 'restricted';
  search?: string;
}

export const AssetsAPI = {
  list: async (q: ListAssetsQuery) => {
    const resp = await http.get<ApiListResponse<Asset>>('/api/assets', { params: q });
    return resp.data;
  },

  search: async (q: { q: string; type?: string; limit?: number; page?: number }) => {
    const resp = await http.get<ApiListResponse<Asset>>('/api/assets/search', { params: q });
    return resp.data;
  },

  byId: async (id: string) => {
    const resp = await http.get<ApiResponse<Asset>>(`/api/assets/${id}`);
    return resp.data;
  },

  schema: async (id: string) => {
    const resp = await http.get<ApiResponse<any>>(`/api/assets/${id}/schema`);
    return resp.data;
  },

  lineage: async (id: string, direction: 'upstream' | 'downstream' | 'both' = 'both') => {
    const resp = await http.get<ApiResponse<any>>(`/api/assets/${id}/lineage`, { params: { direction } });
    return resp.data;
  },

  profile: async (id: string) => {
    const resp = await http.get<ApiResponse<any>>(`/api/assets/${id}/profile`);
    return resp.data;
  },

  stats: async (id: string, period: '1h' | '24h' | '7d' | '30d' | string = '30d') => {
    const resp = await http.get<ApiResponse<AssetStats>>(`/api/assets/${id}/stats`, { params: { period } });
    return resp.data;
  },

  create: async (payload: Partial<Asset>) => {
    const resp = await http.post<ApiResponse<Asset>>('/api/assets', payload);
    return resp.data;
  },

  update: async (id: string, payload: Partial<Asset>) => {
    const resp = await http.put<ApiResponse<Asset>>(`/api/assets/${id}`, payload);
    return resp.data;
  },

  updateClassification: async (id: string, classification: 'public' | 'internal' | 'confidential' | 'restricted', reason?: string) => {
    const resp = await http.put<ApiResponse<Asset>>(`/api/assets/${id}/classification`, { classification, reason });
    return resp.data;
  },

  delete: async (id: string) => {
    const resp = await http.delete<ApiResponse<{ id: string }>>(`/api/assets/${id}`);
    return resp.data;
  },

  addTags: async (id: string, tags: string[]) => {
    const resp = await http.post<ApiResponse<Asset>>(`/api/assets/${id}/tags`, { tags });
    return resp.data;
  },

  removeTags: async (id: string, tags: string[]) => {
    const resp = await http.delete<ApiResponse<Asset>>(`/api/assets/${id}/tags`, { data: { tags } });
    return resp.data;
  },

  scanOrSync: async (id: string, body?: { type?: 'full' | 'incremental' | 'schema_only' | 'profile_only'; force?: boolean }) => {
    const resp = await http.post<ApiResponse<any>>(`/api/assets/${id}/scan`, body ?? {});
    return resp.data;
  },
};



------------------------------------------------------------
FILE: frontend\src\services\auth.ts
------------------------------------------------------------
const KEY = 'auth_token';

export const setAuthToken = (token: string | null) => {
  if (!token) localStorage.removeItem(KEY);
  else localStorage.setItem(KEY, token);
};

export const getAuthToken = () => localStorage.getItem(KEY);



------------------------------------------------------------
FILE: frontend\src\services\database\azureSql.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\database\dataLake.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\database\fabric.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\database\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\services\database\synapse.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\http.ts
------------------------------------------------------------
// frontend/src/services/http.ts
import axios, {
  AxiosError,
  AxiosHeaders,
  AxiosInstance,
  AxiosRequestConfig,
  InternalAxiosRequestConfig,
} from "axios";
import { toUserMessage } from "./httpError";

/* â”€â”€ Base URL & Utils â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function computeBaseURL(): string {
  // Preferred: explicit base from env (no trailing slash; ensure /api suffix)
  const fromEnv = (import.meta.env.VITE_API_URL ?? "").trim().replace(/\/+$/, "");
  if (fromEnv) return fromEnv.endsWith("/api") ? fromEnv : `${fromEnv}/api`;

  // Fallback: same origin (e.g., behind a reverse proxy)
  if (typeof window !== "undefined" && window.location?.origin) {
    const origin = window.location.origin.replace(/\/+$/, "");
    return `${origin}/api`;
  }

  // Last resort: localhost gateway
  return "http://localhost:8000/api";
}

function uuid(): string {
  try {
    // @ts-ignore optional in older libdom
    return crypto?.randomUUID?.() || `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  } catch {
    return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }
}

/* â”€â”€ Token store (legacy key compatible) + events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const TOKEN_KEYS = ["authToken", "access_token"] as const;
type TokenKey = (typeof TOKEN_KEYS)[number];

function readStoredToken():
  | { key: TokenKey; storage: Storage; value: string }
  | null {
  for (const key of TOKEN_KEYS) {
    const vLocal = localStorage.getItem(key);
    if (vLocal) return { key, storage: localStorage, value: vLocal };
    const vSession = sessionStorage.getItem(key);
    if (vSession) return { key, storage: sessionStorage, value: vSession };
  }
  return null;
}

function writeStoredToken(token: string | null) {
  const existing = readStoredToken();
  const targetKey: TokenKey = existing?.key ?? "authToken";
  const targetStore = existing?.storage ?? localStorage;
  if (token) targetStore.setItem(targetKey, token);
  else {
    for (const k of TOKEN_KEYS) {
      localStorage.removeItem(k);
      sessionStorage.removeItem(k);
    }
  }
}

const tokenListeners = new Set<(t: string | null) => void>();
const unauthorizedListeners = new Set<() => void>();

export function getAuthToken(): string | null {
  return (
    localStorage.getItem("authToken") ??
    sessionStorage.getItem("authToken") ??
    localStorage.getItem("access_token") ??
    sessionStorage.getItem("access_token") ??
    null
  );
}

export function setAuthToken(t: string | null) {
  writeStoredToken(t);
  for (const cb of tokenListeners) cb(t);
}

export function clearAuthToken() {
  setAuthToken(null);
}

export function onAuthTokenChange(cb: (t: string | null) => void) {
  tokenListeners.add(cb);
  return () => tokenListeners.delete(cb);
}

export function onUnauthorized(cb: () => void) {
  unauthorizedListeners.add(cb);
  return () => unauthorizedListeners.delete(cb);
}

function notifyUnauthorized() {
  for (const cb of unauthorizedListeners) cb();
}

/* â”€â”€ Axios instance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const http: AxiosInstance = axios.create({
  baseURL: computeBaseURL(),
  timeout: 30_000,
  withCredentials: false, // regular calls; refresh uses cookies explicitly
  // validateStatus: (s) => s >= 200 && s < 300, // default
});

// Debug logging for development
const isDebugMode =
  import.meta.env.VITE_DEBUG_HTTP === "true" ||
  import.meta.env.MODE === "development";

if (isDebugMode) {
  console.log("[HTTP] Base URL:", computeBaseURL());
  console.log("[HTTP] Environment:", import.meta.env.MODE);
  console.log("[HTTP] VITE_API_URL:", import.meta.env.VITE_API_URL);
}

/* â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function headersToObject(h: any) {
  if (!h) return {};
  try {
    if (typeof h.toJSON === "function") return h.toJSON();
    if (typeof h.forEach === "function") {
      const o: Record<string, any> = {};
      h.forEach((v: any, k: string) => {
        o[k] = v;
      });
      return o;
    }
    return { ...h };
  } catch {
    return {};
  }
}

function isIdempotent(config?: AxiosRequestConfig) {
  const m = ((config?.method as string) || "get").toUpperCase();
  return m === "GET" || m === "HEAD" || m === "OPTIONS";
}

function shouldRetryStatus(status?: number) {
  // Transient-ish statuses
  return (
    status === 408 || // Request Timeout
    status === 425 || // Too Early (rare)
    status === 429 || // Rate limited
    status === 502 ||
    status === 503 ||
    status === 504
  );
}

function parseRetryAfterSeconds(h?: string | number): number | null {
  if (!h && h !== 0) return null;
  if (typeof h === "number") return h;
  const s = Number(h);
  if (!Number.isNaN(s)) return s;
  // HTTP-date not handled; keep simple
  return null;
}

function backoffDelay(attempt: number, baseMs = 250, maxMs = 5_000) {
  const jitter = Math.random() * 200;
  return Math.min(baseMs * 2 ** (attempt - 1) + jitter, maxMs);
}

/* â”€â”€ Refresh-on-401 (single-flight) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let isRefreshing = false;
let refreshQueue: {
  resolve: (v?: unknown) => void;
  reject: (e: any) => void;
  config: AxiosRequestConfig;
}[] = [];
let refreshAttempts = 0;
const MAX_REFRESH_ATTEMPTS = 3;

function flushRefreshQueue(error: any) {
  refreshQueue
    .splice(0)
    .forEach(({ resolve, reject, config }) =>
      error ? reject(error) : resolve(http(config))
    );
}

// bare axios for refresh to avoid interceptor recursion
const naked = axios.create();
async function refreshAccessToken() {
  // Gateway expects cookie on /api/auth/refresh â†’ baseURL computed above
  return naked.post(
    "/auth/refresh",
    {},
    { baseURL: computeBaseURL(), withCredentials: true, timeout: 10_000 }
  );
}

/* â”€â”€ Interceptors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
http.interceptors.request.use((config: InternalAxiosRequestConfig) => {
  const reqHeaders = AxiosHeaders.from((config.headers as any) ?? {});

  // Defaults (only set if absent)
  if (!reqHeaders.get("Accept")) reqHeaders.set("Accept", "application/json");
  if (!reqHeaders.get("Content-Type"))
    reqHeaders.set("Content-Type", "application/json");

  // Request ID for tracing
  if (!reqHeaders.get("X-Request-Id")) reqHeaders.set("X-Request-Id", uuid());

  // Client meta (match your gateway's allowed headers)
  if (import.meta.env.MODE)
    reqHeaders.set("X-Client-Env", String(import.meta.env.MODE));
  if (import.meta.env.VITE_APP_VERSION)
    reqHeaders.set("X-Client-Version", String(import.meta.env.VITE_APP_VERSION));
  reqHeaders.set("X-Client-Type", "web");
  reqHeaders.set("X-Platform", "cwic-frontend");

  // Auth
  const t = getAuthToken();
  if (t) reqHeaders.set("Authorization", `Bearer ${t}`);

  // Write back to config
  config.headers = reqHeaders;

  // track retries for backoff on this request
  (config as any).__retryCount ??= 0;

  if (isDebugMode) {
    let printableHeaders: any = {};
    try {
      printableHeaders = (reqHeaders as any).toJSON
        ? (reqHeaders as any).toJSON()
        : reqHeaders;
    } catch {
      printableHeaders = {};
    }

    console.log(`[HTTP] ${config.method?.toUpperCase()} ${config.url}`, {
      baseURL: config.baseURL,
      headers: printableHeaders,
      params: config.params,
    });
  }

  return config;
});

http.interceptors.response.use(
  (res) => {
    if (isDebugMode) {
      console.log(`[HTTP] ${res.status} ${res.config.url}`, res.data);
    }
    return res;
  },
  async (err: AxiosError) => {
    const cfg = err.config as
      | (AxiosRequestConfig & { _retry?: boolean; __retryCount?: number })
      | undefined;

    const status = err.response?.status;

    // Quick detection for CORS / network layer problems
    if (err.message?.includes("CORS") || err.code === "ERR_NETWORK") {
      console.error("[HTTP] CORS/Network Error:", {
        message: err.message,
        code: err.code,
        url: cfg?.url,
        method: cfg?.method,
        baseURL: cfg?.baseURL || computeBaseURL(),
        headers: headersToObject(cfg?.headers),
      });
    }

    // 401/419 â†’ refresh token flow (single-flight)
    if ((status === 401 || status === 419) && cfg && !cfg._retry) {
      cfg._retry = true;

      if (isRefreshing) {
        return new Promise((resolve, reject) =>
          refreshQueue.push({ resolve, reject, config: cfg })
        );
      }

      try {
        isRefreshing = true;
        if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
          throw new Error("Max refresh attempts exceeded");
        }
        refreshAttempts++;

        const { data } = await refreshAccessToken();
        const newAccess: string | undefined = (data as any)?.accessToken;
        if (!newAccess) throw new Error("No access token in refresh response");

        setAuthToken(newAccess);
        flushRefreshQueue(null);

        // Retry original with fresh token
        const retryHeaders = AxiosHeaders.from((cfg.headers as any) ?? {});
        retryHeaders.set("Authorization", `Bearer ${newAccess}`);
        cfg.headers = retryHeaders;

        return http(cfg);
      } catch (refreshErr) {
        flushRefreshQueue(refreshErr);
        clearAuthToken();
        notifyUnauthorized();
      } finally {
        isRefreshing = false;
      }
    }

    // Idempotent retry with exponential backoff on transient errors
    const isNetwork = !err.response; // e.g., timeouts/connection resets
    if (cfg && cfg.url && (isNetwork || shouldRetryStatus(status)) && isIdempotent(cfg)) {
      const retryAfter =
        parseRetryAfterSeconds(err.response?.headers?.["retry-after"] as any) ??
        0;
      const current = Number((cfg as any).__retryCount ?? 0);

      if (current < 3) {
        (cfg as any).__retryCount = current + 1;
        const delay = Math.max(retryAfter * 1000, backoffDelay(current + 1));
        await new Promise((r) => setTimeout(r, delay));
        return http(cfg);
      }
    }

    // Normalize/log and propagate
    const msg = toUserMessage(err);
    if (err?.response) {
      console.warn(
        `[HTTP ${err.response.status}] ${cfg?.method?.toUpperCase()} ${cfg?.url} :: ${msg}`,
        err.response.data
      );
    } else {
      console.warn("[HTTP] Network/Proxy error ::", msg, {
        code: err.code,
        message: err.message,
        config: {
          url: cfg?.url,
          method: cfg?.method,
          baseURL: cfg?.baseURL,
        },
      });
    }

    return Promise.reject(new Error(msg));
  }
);

/* â”€â”€ Exports (default + legacy shims) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export default http;
// Legacy shims so old imports keep working:
export { http }; // allows: import { http } from "@services/http"
export const api = http; // allows: import { api } from "@services/http"
// Small token facade for callers that need it:
export const token = { get: getAuthToken, set: setAuthToken, clear: clearAuthToken };



------------------------------------------------------------
FILE: frontend\src\services\httpError.ts
------------------------------------------------------------
// Extract a human message from Axios/Fetch/backend errors
export function toUserMessage(err: any): string {
  // Axios shape
  if (err?.response) {
    const d = err.response.data;
    return (
      d?.error?.message ||     // { error: { message: "..."} }
      d?.message ||            // { message: "..." }
      err.message ||           // Axios error message
      'Request failed'
    );
  }
  // Fetch/unknown
  return err?.message || 'Network error';
}

export function statusCode(err: any): number | undefined {
  return err?.response?.status;
}



------------------------------------------------------------
FILE: frontend\src\services\integrations\azureDevOps.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\integrations\git.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\integrations\index.ts
------------------------------------------------------------
// barrel


------------------------------------------------------------
FILE: frontend\src\services\integrations\jira.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\integrations\serviceNow.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\services\sources.ts
------------------------------------------------------------
import { default as api, default as http } from "@services/http";
import type { ApiListResponse, ApiResponse } from '../types/api';
import type { DataSource } from '../types/source';


export interface ListSourcesQuery {
  page?: number;
  limit?: number;
  type?: string;
  environment?: 'development' | 'staging' | 'production';
  status?: 'active' | 'inactive' | 'error' | 'pending';
}

export const SourcesAPI = {
  list: async (q: ListSourcesQuery) => {
    const resp = await http.get<ApiListResponse<DataSource>>('/api/sources', { params: q });
    return resp.data;
  },

  types: async () => {
    const resp = await http.get<ApiResponse<{ types: string[] }>>('/api/sources/types');
    return resp.data;
  },

  templates: async (type?: string) => {
    const resp = await http.get<ApiResponse<any>>('/api/sources/templates', { params: { type } });
    return resp.data;
  },

  health: async () => {
    const resp = await http.get<ApiResponse<any>>('/api/sources/health');
    return resp.data;
  },

  byId: async (id: string) => {
    const resp = await http.get<ApiResponse<DataSource>>(`/api/sources/${id}`);
    return resp.data;
  },

  assets: async (id: string, q?: { type?: string; limit?: number }) => {
    const resp = await http.get<ApiResponse<any>>(`/api/sources/${id}/assets`, { params: q });
    return resp.data;
  },

  metrics: async (id: string, period?: '1h' | '24h' | '7d' | '30d') => {
    const resp = await http.get<ApiResponse<any>>(`/api/sources/${id}/metrics`, { params: { period } });
    return resp.data;
  },

  schema: async (id: string) => {
    const resp = await http.get<ApiResponse<any>>(`/api/sources/${id}/schema`);
    return resp.data;
  },

  create: async (payload: Partial<DataSource>) => {
    const resp = await http.post<ApiResponse<DataSource>>('/api/sources', payload);
    return resp.data;
  },

  test: async (payload: any) => {
    const resp = await http.post<ApiResponse<any>>('/api/sources/test', payload);
    return resp.data;
  },

  discover: async (id: string, body?: { type?: 'full' | 'incremental' | 'schema_only'; options?: Record<string, any> }) => {
    const resp = await http.post<ApiResponse<any>>(`/api/sources/${id}/discover`, body ?? {});
    return resp.data;
  },

  update: async (id: string, payload: Partial<DataSource>) => {
    const resp = await http.put<ApiResponse<DataSource>>(`/api/sources/${id}`, payload);
    return resp.data;
  },

  updateStatus: async (id: string, status: 'active' | 'inactive' | 'error' | 'pending', reason?: string) => {
    const resp = await http.put<ApiResponse<DataSource>>(`/api/sources/${id}/status`, { status, reason });
    return resp.data;
  },

  delete: async (id: string, opts?: { force?: boolean; deleteAssets?: boolean }) => {
    const resp = await http.delete<ApiResponse<{ id: string }>>(`/api/sources/${id}`, { data: opts ?? {} });
    return resp.data;
  },
};

export interface CreateDataSourceBody {
  name: string;
  type: string;
  config: Record<string, any>;
}

export async function listDataSources() {
  const { data } = await api.get("/data-sources");
  return data;
}

export async function createDataSource(body: CreateDataSourceBody) {
  const { data } = await api.post("/data-sources", body);
  return data;
}

export async function testConnection(id: string) {
  const { data } = await api.post(`/data-sources/${id}/test`);
  return data;
} 


------------------------------------------------------------
FILE: frontend\src\services\tokenManager.ts
------------------------------------------------------------
// src/services/auth/tokenManager.ts
type Decoded = { exp?: number; [k: string]: unknown };

// minimal base64url decode (no external dep)
function decodeJwt(token: string): Decoded | null {
  try {
    const [, payload] = token.split('.');
    const json = atob(payload.replace(/-/g, '+').replace(/_/g, '/'));
    return JSON.parse(json);
  } catch { return null; }
}

export class TokenManager {
  private accessToken: string | null = null;
  private accessExp = 0; // epoch seconds
  private refreshPromise: Promise<string | null> | null = null;
  private readonly earlyRefreshSec = 60; // refresh 60s before expiry
  private readonly storageKey = 'auth.access';

  constructor(private readonly refreshEndpoint = '/api/auth/refresh') {
    // optional: restore across reloads
    const saved = localStorage.getItem(this.storageKey);
    if (saved) this.setAccessToken(saved);
  }

  get token(): string | null { return this.accessToken; }

  setAccessToken(token: string | null) {
    this.accessToken = token;
    if (!token) {
      this.accessExp = 0;
      localStorage.removeItem(this.storageKey);
      return;
    }
    const dec = decodeJwt(token);
    this.accessExp = typeof dec?.exp === 'number' ? dec.exp : 0;
    localStorage.setItem(this.storageKey, token);
  }

  // true if token expires within earlyRefreshSec
  private isStale(): boolean {
    if (!this.accessToken || !this.accessExp) return true;
    const now = Math.floor(Date.now() / 1000);
    return now >= (this.accessExp - this.earlyRefreshSec);
  }

  /** Ensures we have a fresh access token; returns null if refresh failed */
  async ensureFresh(): Promise<string | null> {
    if (!this.isStale()) return this.accessToken;

    if (!this.refreshPromise) {
      this.refreshPromise = this.doRefresh().finally(() => { this.refreshPromise = null; });
    }
    return this.refreshPromise;
  }

  private async doRefresh(): Promise<string | null> {
    try {
      // If you use cookie-based refresh, withCredentials must be true.
      const res = await fetch(this.refreshEndpoint, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
      });
      if (!res.ok) throw new Error(`Refresh failed: ${res.status}`);

      // Expect JSON: { accessToken: string }
      const data = await res.json();
      if (typeof data?.accessToken !== 'string') throw new Error('Malformed refresh payload');
      this.setAccessToken(data.accessToken);
      return data.accessToken;
    } catch (e) {
      this.setAccessToken(null);
      return null;
    }
  }
}

export const tokenManager = new TokenManager('/api/auth/refresh');



------------------------------------------------------------
FILE: frontend\src\store\index.ts
------------------------------------------------------------
export * from './store';


------------------------------------------------------------
FILE: frontend\src\store\middleware\authMiddleware.ts
------------------------------------------------------------
export const authMiddleware=()=>(next:any)=>(action:any)=>next(action);


------------------------------------------------------------
FILE: frontend\src\store\middleware\index.ts
------------------------------------------------------------
export * from './authMiddleware'; export * from './loggingMiddleware';


------------------------------------------------------------
FILE: frontend\src\store\middleware\loggingMiddleware.ts
------------------------------------------------------------
export const loggingMiddleware=()=>(next:any)=>(action:any)=>next(action);


------------------------------------------------------------
FILE: frontend\src\store\slices\authSlice.ts
------------------------------------------------------------
import { createSlice } from '@reduxjs/toolkit'
const authSlice = createSlice({ name: 'auth', initialState: { user: null, token: null }, reducers: {} })
export default authSlice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\dataAssetsSlice.ts
------------------------------------------------------------
import type { Asset } from '@/types/dataAssets'
import type { PayloadAction } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'

type DataAssetsState = {
  assets: Asset[]
}
const initialState: DataAssetsState = { assets: [] }

const dataAssetsSlice = createSlice({
  name: 'dataAssets',
  initialState,
  reducers: {
    setAssets(state, action: PayloadAction<Asset[]>) {
      state.assets = action.payload
    },
  },
})

export const { setAssets } = dataAssetsSlice.actions
export default dataAssetsSlice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\dataSourcesSlice.ts
------------------------------------------------------------
import { createSlice } from '@reduxjs/toolkit'
const slice = createSlice({ name: 'dataSources', initialState: { sources: [] as any[] }, reducers: {} })
export default slice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\notificationsSlice.ts
------------------------------------------------------------
import { createSlice } from '@reduxjs/toolkit'
const slice = createSlice({ name: 'notifications', initialState: { items: [] as any[] }, reducers: {} })
export default slice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\pipelinesSlice.ts
------------------------------------------------------------
import type { PayloadAction } from '@reduxjs/toolkit';
import { createSlice } from '@reduxjs/toolkit';

type Pipeline = { id: string; status: 'running' | 'failed' | 'succeeded' | 'paused' | 'idle' }
type PipelinesState = { pipelines: Pipeline[] }
const initialState: PipelinesState = { pipelines: [] }

const pipelinesSlice = createSlice({
  name: 'pipelines',
  initialState,
  reducers: {
    setPipelines(state, action: PayloadAction<Pipeline[]>) {
      state.pipelines = action.payload
    },
  },
})

export const { setPipelines } = pipelinesSlice.actions
export default pipelinesSlice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\qualitySlice.ts
------------------------------------------------------------
import { createSlice } from '@reduxjs/toolkit'
const slice = createSlice({ name: 'quality', initialState: { avg: 0 }, reducers: {} })
export default slice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\requestsSlice.ts
------------------------------------------------------------
import type { PayloadAction } from '@reduxjs/toolkit';
import { createSlice } from '@reduxjs/toolkit';

type Request = { id: string; status: 'open' | 'in_progress' | 'completed' | string }
type RequestsState = { requests: Request[] }
const initialState: RequestsState = { requests: [] }

const requestsSlice = createSlice({
  name: 'requests',
  initialState,
  reducers: {
    setRequests(state, action: PayloadAction<Request[]>) {
      state.requests = action.payload
    },
  },
})

export const { setRequests } = requestsSlice.actions
export default requestsSlice.reducer



------------------------------------------------------------
FILE: frontend\src\store\slices\uiSlice.ts
------------------------------------------------------------
import { createSlice } from '@reduxjs/toolkit'
const slice = createSlice({ name: 'ui', initialState: { sidebarOpen: true }, reducers: {} })
export default slice.reducer



------------------------------------------------------------
FILE: frontend\src\store\store.ts
------------------------------------------------------------
import { configureStore } from '@reduxjs/toolkit'

import auth from './slices/authSlice'
import dataAssets from './slices/dataAssetsSlice'
import dataSources from './slices/dataSourcesSlice'
import notifications from './slices/notificationsSlice'
import pipelines from './slices/pipelinesSlice'
import quality from './slices/qualitySlice'
import requests from './slices/requestsSlice'
import ui from './slices/uiSlice'

export const store = configureStore({
  reducer: {
    auth,
    dataSources,
    dataAssets,
    quality,
    pipelines,
    requests,
    notifications,
    ui,
  },
  middleware: (gDM) => gDM({ serializableCheck: false, immutableCheck: true }),
  devTools: import.meta.env.DEV,
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch



------------------------------------------------------------
FILE: frontend\src\types\api.ts
------------------------------------------------------------
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  meta?: Record<string, any>;
}

export interface ApiListResponse<T> {
  success: boolean;
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  meta?: Record<string, any>;
}

export interface ApiError {
  status: number;       // HTTP status
  code: string;         // e.g. NOT_FOUND, VALIDATION_ERROR, RATE_LIMIT_EXCEEDED
  message: string;
  requestId?: string;
  retryAfter?: string;
  details?: unknown;
}



------------------------------------------------------------
FILE: frontend\src\types\asset.ts
------------------------------------------------------------
export type AssetType =
  | 'table' | 'view' | 'file' | 'api_endpoint' | 'stream' | 'model'
  | 'procedure' | 'function' | 'schema';

export type AssetStatus = 'active' | 'inactive' | 'deprecated';

export interface Column {
  name: string;
  type?: string;
  dataType?: string;
  nullable: boolean;
  primaryKey?: boolean;
  isPrimaryKey?: boolean;
  foreignKey?: { table: string; column: string };
  description?: string;
  tags?: string[];
}

export interface Asset {
  id: string;
  name: string;
  type: AssetType;
  dataSourceId: string;
  schemaName?: string;
  tableName?: string;
  description?: string;
  columns?: Column[];
  tags?: string[];
  status: AssetStatus;
  createdAt: string | Date;
  updatedAt: string | Date;
  metadata?: Record<string, any>;
}

export interface AssetStats {
  accessCount: number;
  lastAccessed: string | Date | null;
  avgQueryTime: number;
  dataVolume: { current: number; trend: 'increasing' | 'decreasing' | 'stable'; changePercent: number };
  qualityScore: number;
  usageMetrics: { date: string; count: number }[];
}



------------------------------------------------------------
FILE: frontend\src\types\auth.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\common.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\dataAssets.ts
------------------------------------------------------------
// src/types/dataAssets.ts
export type AssetLayer = 'Gold' | 'Silver' | 'Bronze'

export type Asset = {
  id: string
  name: string
  description?: string
  type?: string
  owner?: string
  tags?: string[]
  updatedAt?: string
  qualityScore?: number

  // NEW: lineage/graph metadata (all optional)
  layer?: AssetLayer
  lineage?: string[]          // e.g., ["Bronze: raw_orders", "Silver: orders_clean", "Gold: orders_mart"]
  dependencies?: string[]     // upstream names
  dependents?: string[]       // downstream names
}



------------------------------------------------------------
FILE: frontend\src\types\dataSources.ts
------------------------------------------------------------
// src/types/dataSources.ts - Copy this entire file to replace your existing one

// Base data source types that match your backend
export type DataSourceType = 
  | 'postgresql' 
  | 'mysql' 
  | 'mssql' 
  | 'mongodb' 
  | 'redis'
  | 'snowflake'
  | 'bigquery'
  | 'redshift'
  | 'databricks'
  | 's3'
  | 'azure-blob'
  | 'gcs'
  | 'kafka'
  | 'api'
  | 'file'
  | 'ftp'
  | 'elasticsearch'
  | 'oracle' ;// If you decide to support Oracle in the future;

// Data source status
export type DataSourceStatus = 'active' | 'inactive' | 'pending' | 'error' | 'testing';

// Base connection configuration
export interface BaseConnectionConfig {
  host?: string;
  port?: number;
  database?: string;
  username?: string;
  password?: string;
  ssl?: boolean;
  timeout?: number;
  customOptions?: Record<string, any>;
}

// Specific connection configs
export interface PostgreSQLConfig extends BaseConnectionConfig {
  sslmode?: 'disable' | 'require' | 'verify-ca' | 'verify-full';
  schema?: string;
  connectTimeout?: number;
}

export interface MySQLConfig extends BaseConnectionConfig {
  charset?: string;
  timezone?: string;
}

export interface SQLServerConfig extends BaseConnectionConfig {
  encrypt?: boolean;
  trustServerCertificate?: boolean;
  server?: string;
}

export interface MongoDBConfig {
  connectionString?: string;
  host?: string;
  port?: number;
  database?: string;
  username?: string;
  password?: string;
  authSource?: string;
  replicaSet?: string;
  ssl?: boolean;
  customOptions?: Record<string, any>;
}

export interface RedisConfig {
  host: string;
  port: number;
  password?: string;
  database?: number;
  ssl?: boolean;
  keyPrefix?: string;
  customOptions?: Record<string, any>;
}

export interface SnowflakeConfig {
  host: string;
  database: string;
  warehouse: string;
  schema?: string;
  username: string;
  password: string;
  role?: string;
  customOptions?: Record<string, any>;
}

export interface BigQueryConfig {
  serviceAccountKey: string;
  projectId: string;
  location?: string;
  customOptions?: Record<string, any>;
}

export interface S3Config {
  accessKeyId: string;
  secretAccessKey: string;
  bucket: string;
  region: string;
  prefix?: string;
  customOptions?: Record<string, any>;
}

export interface AzureBlobConfig {
  accountName: string;
  accountKey: string;
  containerName: string;
  prefix?: string;
  endpoint?: string;
  customOptions?: Record<string, any>;
}

export interface GCSConfig {
  serviceAccountKey: string;
  bucketName: string;
  prefix?: string;
  projectId?: string;
  customOptions?: Record<string, any>;
}

export interface KafkaConfig {
  brokers: string[] | string;
  consumerGroup?: string;
  securityProtocol?: 'PLAINTEXT' | 'SASL_PLAINTEXT' | 'SASL_SSL' | 'SSL';
  saslMechanism?: 'PLAIN' | 'SCRAM-SHA-256' | 'SCRAM-SHA-512';
  saslUsername?: string;
  saslPassword?: string;
  topics?: string[];
  customOptions?: Record<string, any>;
}

export interface APIConfig {
  baseUrl: string;
  authType?: 'none' | 'api-key' | 'bearer' | 'basic' | 'oauth2';
  apiKey?: string;
  apiKeyHeader?: string;
  bearerToken?: string;
  username?: string;
  password?: string;
  timeout?: number;
  rateLimit?: number;
  customOptions?: Record<string, any>;
}

export interface FileConfig {
  path: string;
  format: 'csv' | 'json' | 'jsonl' | 'parquet' | 'xlsx' | 'xml' | 'txt';
  encoding?: 'utf-8' | 'utf-16' | 'latin1' | 'ascii';
  delimiter?: string;
  hasHeader?: boolean;
  recursive?: boolean;
  customOptions?: Record<string, any>;
}

export interface FTPConfig {
  host: string;
  port?: number;
  username: string;
  password: string;
  protocol: 'ftp' | 'sftp' | 'ftps';
  path?: string;
  passive?: boolean;
  customOptions?: Record<string, any>;
}

export interface ElasticsearchConfig extends BaseConnectionConfig {
  apiKey?: string;
  cloudId?: string;
  index?: string;
}

export interface DatabricksConfig {
  host: string;
  httpPath: string;
  accessToken: string;
  catalog?: string;
  schema?: string;
  customOptions?: Record<string, any>;
}

export interface RedshiftConfig extends BaseConnectionConfig {
  schema?: string;
}

// Union type for all connection configurations
export type ConnectionConfig = 
  | PostgreSQLConfig
  | MySQLConfig
  | SQLServerConfig
  | MongoDBConfig
  | RedisConfig
  | SnowflakeConfig
  | BigQueryConfig
  | S3Config
  | AzureBlobConfig
  | GCSConfig
  | KafkaConfig
  | APIConfig
  | FileConfig
  | FTPConfig
  | ElasticsearchConfig
  | DatabricksConfig
  | RedshiftConfig
  | BaseConnectionConfig;

// Type guards for connection configs
export function isS3Config(config: ConnectionConfig): config is S3Config {
  return 'accessKeyId' in config && 'secretAccessKey' in config && 'bucket' in config;
}

export function isAPIConfig(config: ConnectionConfig): config is APIConfig {
  return 'baseUrl' in config;
}

export function isSnowflakeConfig(config: ConnectionConfig): config is SnowflakeConfig {
  return 'warehouse' in config;
}

export function isBigQueryConfig(config: ConnectionConfig): config is BigQueryConfig {
  return 'serviceAccountKey' in config && 'projectId' in config;
}

export function isMongoDBConfig(config: ConnectionConfig): config is MongoDBConfig {
  return 'connectionString' in config || ('host' in config && 'database' in config);
}

export function isKafkaConfig(config: ConnectionConfig): config is KafkaConfig {
  return 'brokers' in config;
}

export function isDatabricksConfig(config: ConnectionConfig): config is DatabricksConfig {
  return 'httpPath' in config && 'accessToken' in config;
}

// Main DataSource interface
export interface DataSource {
  id: string;
  name: string;
  description?: string;
  type: DataSourceType;
  status: DataSourceStatus;
  connectionConfig: ConnectionConfig;
  tags: string[];
  metadata: Record<string, any>;
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  lastTestedAt?: string;
  lastSyncAt?: string;
  healthStatus?: {
    status: 'healthy' | 'degraded' | 'down' | 'unknown';
    lastChecked: string;
    responseTime?: number;
    message?: string;
  };
  syncStatus?: {
    status: 'idle' | 'syncing' | 'completed' | 'failed';
    lastSync?: string;
    nextSync?: string;
    tablesCount?: number;
    errors?: string[];
  };
  usage?: {
    queriesCount: number;
    lastUsed?: string;
    avgResponseTime?: number;
  };
}

// Paginated response for data sources
export interface PaginatedDataSources {
  data: DataSource[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  filters?: {
    status?: string;
    type?: string;
    tags?: string[];
  };
}

// Data source creation payload
export interface CreateDataSourcePayload {
  name: string;
  description?: string;
  type: DataSourceType;
  connectionConfig: ConnectionConfig;
  tags?: string[];
  metadata?: Record<string, any>;
}

// Data source update payload
export interface UpdateDataSourcePayload {
  name?: string;
  description?: string;
  connectionConfig?: Partial<ConnectionConfig>;
  tags?: string[];
  metadata?: Record<string, any>;
  status?: DataSourceStatus;
}

// Connection test result
export interface ConnectionTestResult {
  success?: boolean;
  message?: string;
  connectionStatus?: 'connected' | 'failed' | 'unknown';
  testedAt?: string;
  responseTimeMs?: number;
  // allow server-specific extras
  [k: string]: any;
}

// Sync operation result
export interface SyncResult {
  syncId: string;                               // always filled by our normalizer
  status: 'queued' | 'started' | 'running' | 'completed' | 'failed';
  startedAt?: string;
  completedAt?: string;
  tablesScanned?: number;
  newTables?: number;
  updatedTables?: number;
  errors?: string[];
  message?: string;
  // allow extras
  [k: string]: any;
}

// Data source metrics
export interface DataSourceMetrics {
  totalConnections: number;
  activeConnections: number;
  connectionsByType: Record<DataSourceType, number>;
  connectionsByStatus: Record<DataSourceStatus, number>;
  healthyConnections: number;
  recentActivity: {
    date: string;
    connections: number;
    queries: number;
  }[];
  topConnections: {
    id: string;
    name: string;
    type: DataSourceType;
    queryCount: number;
  }[];
}

// Asset types (keep original names to avoid conflicts)
export interface Asset {
  id: string;
  name: string;
  type: 'table' | 'view' | 'procedure' | 'function' | 'schema';
  dataSourceId: string;
  schemaName?: string;
  tableName?: string;
  description?: string;
  columns: Column[];
  tags: string[];
  status: 'active' | 'inactive' | 'deprecated';
  metadata: Record<string, any>;
  createdAt: string;
  updatedAt: string;
}

export interface Column {
  name: string;
  type: string;
  nullable: boolean;
  defaultValue?: any;
  description?: string;
  isPrimaryKey?: boolean;
  isForeignKey?: boolean;
  metadata?: Record<string, any>;
}

// Data lineage
export interface AssetLineage {
  upstream: Asset[];
  downstream: Asset[];
  relationships: {
    id: string;
    upstreamAssetId: string;
    downstreamAssetId: string;
    type: string;
    description?: string;
  }[];
}

// Data quality
export interface DataQualityRule {
  id: string;
  assetId: string;
  name: string;
  type: 'not_null' | 'unique' | 'range' | 'pattern' | 'custom';
  configuration: Record<string, any>;
  status: 'active' | 'inactive';
  lastRunAt?: string;
  lastResult?: {
    passed: boolean;
    score: number;
    message?: string;
    details?: Record<string, any>;
  };
}

// Search and filtering
export interface DataSourceFilters {
  search?: string;
  types?: DataSourceType[];
  statuses?: DataSourceStatus[];
  tags?: string[];
  createdBy?: string;
  dateRange?: {
    start: string;
    end: string;
  };
}

export interface AssetFilters {
  search?: string;
  types?: Asset['type'][];
  dataSourceIds?: string[];
  tags?: string[];
  schemas?: string[];
}

// Event types for real-time updates
export interface DataSourceEvent {
  type: 'created' | 'updated' | 'deleted' | 'tested' | 'synced';
  dataSourceId: string;
  timestamp: string;
  data?: Partial<DataSource>;
  user?: string;
}

// Webhook configuration
export interface WebhookConfig {
  id: string;
  url: string;
  events: DataSourceEvent['type'][];
  secret?: string;
  active: boolean;
  createdAt: string;
  lastTriggered?: string;
}


------------------------------------------------------------
FILE: frontend\src\types\index.ts
------------------------------------------------------------
export type { Asset } from './dataAssets';




------------------------------------------------------------
FILE: frontend\src\types\notifications.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\pipelines.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\qualityRules.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\Requests.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\types\source.ts
------------------------------------------------------------
export type DataSourceType =
  | 'postgresql' | 'mysql' | 'mssql' | 'oracle' | 'mongodb' | 'redis'
  | 's3' | 'azure-blob' | 'gcs' | 'snowflake' | 'bigquery' | 'redshift'
  | 'databricks' | 'api' | 'file' | 'kafka' | 'elasticsearch';

export type DataSourceStatus =
  | 'pending' | 'connected' | 'disconnected' | 'error' | 'warning' | 'syncing' | 'testing';

export interface ConnectionConfig {
  host?: string;
  port?: number;
  database?: string;
  username?: string;
  password?: string;
  schema?: string;
  ssl?: boolean;
  connectionString?: string;

  bucket?: string;
  region?: string;
  accessKeyId?: string;
  secretAccessKey?: string;
  serviceAccountKey?: string;

  baseUrl?: string;
  apiKey?: string;
  headers?: Record<string, string>;
  authentication?: { type: 'basic' | 'bearer' | 'oauth2' | 'api-key'; credentials: Record<string, string> };

  path?: string;
  format?: 'csv' | 'json' | 'parquet' | 'avro' | 'xml';

  brokers?: string[];
  topics?: string[];
  consumerGroup?: string;

  timeout?: number;
  maxConnections?: number;
  retryAttempts?: number;
  customOptions?: Record<string, any>;
}

export interface DataSource {
  id: string;
  name: string;
  description?: string;
  type: DataSourceType;
  status: DataSourceStatus;
  connectionConfig: ConnectionConfig;
  tags: string[];
  metadata: Record<string, any>;
  createdAt: string | Date;
  updatedAt: string | Date;
  createdBy: string;
  updatedBy?: string;
  deletedAt?: string | Date;
  lastTestAt?: string | Date;
  lastSyncAt?: string | Date;
  lastError?: string;
  responseTime?: number;
  availability?: number;
}



------------------------------------------------------------
FILE: frontend\src\utils\apiUtils.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\constants.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\dateUtils.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\formatters.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\helpers.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\index.ts
------------------------------------------------------------
// Lightweight className combiner
export function cn(...classes: Array<string | undefined | null | false>) {
  return classes.filter(Boolean).join(' ')
}



------------------------------------------------------------
FILE: frontend\src\utils\stringUtils.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\utils\validators.ts
------------------------------------------------------------
# Empty file


------------------------------------------------------------
FILE: frontend\src\vite-env.d.ts
------------------------------------------------------------
/// <reference types="vite/client" />

declare module '*.svg' {
  import * as React from 'react';
  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>
  const src: string
  export default src
}
declare module '*.png' { const src: string; export default src }
declare module '*.jpg' { const src: string; export default src }
declare module '*.jpeg' { const src: string; export default src }
declare module '*.gif' { const src: string; export default src }
declare module '*.webp' { const src: string; export default src }
declare module '*.ico' { const src: string; export default src }



====================================================================================================
  CODE EXTRACTION SUMMARY
====================================================================================================

INCLUDED FILE TYPES:
  - *.ts
  - *.tsx
  - *.js
  - *.jsx

EXCLUDED SYSTEM FILES:
  - package.json
  - package-lock.json
  - yarn.lock
  - tsconfig.json
  - vite.config.*
  - vitest.config.*
  - tailwind.config.*
  - postcss.config.*
  - eslint.config.*
  - .eslintrc.*
  - prettier.config.*
  - .prettierrc*
  - jest.config.*
  - babel.config.*
  - webpack.config.*
  - rollup.config.*
  - Dockerfile*
  - docker-compose.*
  - .env*
  - .gitignore
  - .gitattributes
  - README.md
  - CHANGELOG.md
  - LICENSE
  - *.lock
  - *.log

EXCLUDED DIRECTORIES:
  - node_modules
  - .git
  - dist
  - build
  - .next
  - coverage
  - .nyc_output
  - logs
  - tmp
  - temp
  - .vscode
  - .idea
  - public
  - assets
  - static
