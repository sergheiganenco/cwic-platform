// frontend/src/services/api/quality.ts
// Complete Quality API Service with all endpoints

const API_BASE = '/api';

export interface AssetProfile {
  assetId: number;
  assetName: string;
  dataSourceId: string;
  rowCount: number;
  columnCount: number;
  sizeBytes?: number;
  qualityScore: number;
  dimensionScores: {
    completeness: number;
    accuracy: number;
    consistency: number;
    validity: number;
    freshness: number;
    uniqueness: number;
  };
  profiledAt: string;
  columns: ColumnProfile[];
}

export interface ColumnProfile {
  name: string;
  dataType: string;
  nullable: boolean;
  nullCount: number;
  nullRate: number;
  distinctCount: number;
  uniqueRate: number;
  min?: any;
  max?: any;
  avg?: number;
  stdDev?: number;
  topValues: Array<{ value: any; count: number; percentage: number }>;
  anomalies: string[];
  suggestedRules: RuleSuggestion[];
}

export interface RuleSuggestion {
  name: string;
  description: string;
  dimension: string;
  severity: string;
  ruleType: string;
  config: any;
  columnName?: string;
  autoGenerated: boolean;
}

export interface QualityRule {
  id: string;
  name: string;
  description?: string;
  dimension: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  ruleType: string;
  ruleConfig?: any;
  enabled: boolean;
  assetId?: number;
  dataSourceId?: string;
  columnName?: string;
  lastRunAt?: string;
  passRate?: number;
  executionCount?: number;
  avgExecutionTimeMs?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface QualityIssue {
  id: string;
  ruleId: string;
  ruleName: string;
  title: string;
  description?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  dimension: string;
  status: 'open' | 'acknowledged' | 'in_progress' | 'resolved' | 'false_positive' | 'wont_fix';
  assetId?: number;
  assetName?: string;
  tableName?: string;
  schemaName?: string;
  dataSourceName?: string;
  affectedRows: number;
  affectedColumns?: string[];
  sampleData?: any[];
  rootCause?: string;
  remediationPlan?: string;
  firstSeenAt: string;
  lastSeenAt: string;
  occurrenceCount: number;
  assignedTo?: string;
  resolvedAt?: string;
}

export interface ScanResult {
  dataSourceId: string;
  totalRules: number;
  executedRules: number;
  passed: number;
  failed: number;
  errors: number;
  duration: number;
  results: RuleExecutionResult[];
}

export interface RuleExecutionResult {
  id: string;
  ruleId: string;
  status: 'passed' | 'failed' | 'warning' | 'error' | 'timeout';
  metricValue?: number;
  thresholdValue?: number;
  rowsChecked?: number;
  rowsFailed?: number;
  executionTimeMs: number;
  errorMessage?: string;
  sampleFailures?: any[];
}

export interface QualityTrend {
  timestamp: string;
  overallScore: number;
  dimensionScores: {
    completeness: number;
    accuracy: number;
    consistency: number;
    validity: number;
    freshness: number;
    uniqueness: number;
  };
  issueCount: number;
  passRate: number;
}

export interface RuleTemplate {
  id: string;
  name: string;
  description: string;
  dimension: 'completeness' | 'accuracy' | 'consistency' | 'validity' | 'freshness' | 'uniqueness';
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  sqlTemplate: string;
  parameters: {
    name: string;
    description: string;
    type: 'table' | 'column' | 'threshold' | 'pattern' | 'number' | 'string';
    required: boolean;
    defaultValue?: any;
  }[];
  examples: string[];
  bestPractices: string;
}

class QualityAPI {
  private getAuthHeaders(): HeadersInit {
    const token = localStorage.getItem('token');
    return {
      'Content-Type': 'application/json',
      ...(token && { 'Authorization': `Bearer ${token}` }),
    };
  }

  // ============================================================================
  // PROFILING ENDPOINTS
  // ============================================================================

  async profileAsset(assetId: number): Promise<AssetProfile> {
    try {
      const response = await fetch(`${API_BASE}/quality/profile/asset/${assetId}`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to profile asset: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Profile asset error:', error);
      // Return mock data for demo
      return this.getMockAssetProfile(assetId);
    }
  }

  async profileDataSource(dataSourceId: string): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/quality/profile/datasource/${dataSourceId}`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to profile data source: ${response.statusText}`);
      }

      const result = await response.json();

      // Return the full response data which includes profileCount, successfulProfiles, etc.
      return result.data || { profiles: [], profileCount: 0, successfulProfiles: 0, failedProfiles: 0, averageQualityScore: 0 };
    } catch (error) {
      console.error('Profile data source error:', error);
      // Return mock data for demo
      return {
        profiles: this.getMockDataSourceProfiles(dataSourceId),
        profileCount: 5,
        successfulProfiles: 5,
        failedProfiles: 0,
        averageQualityScore: 80
      };
    }
  }

  async getProfileSuggestions(assetId: number): Promise<RuleSuggestion[]> {
    try {
      const response = await fetch(`${API_BASE}/quality/profile/asset/${assetId}/suggestions`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get suggestions: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.suggestions || [];
    } catch (error) {
      console.error('Get suggestions error:', error);
      return this.getMockSuggestions(assetId);
    }
  }

  // ============================================================================
  // RULES ENDPOINTS
  // ============================================================================

  async getRules(filters?: {
    dataSourceId?: string;
    assetId?: number;
    enabled?: boolean;
    severity?: string;
  }): Promise<QualityRule[]> {
    try {
      const params = new URLSearchParams();
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      if (filters?.assetId) params.append('assetId', filters.assetId.toString());
      if (filters?.enabled !== undefined) params.append('enabled', filters.enabled.toString());
      if (filters?.severity) params.append('severity', filters.severity);

      const response = await fetch(`${API_BASE}/quality/rules?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get rules: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.rules || [];
    } catch (error) {
      console.error('Get rules error:', error);
      return this.getMockRules();
    }
  }

  async createRule(rule: Partial<QualityRule>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(rule),
      });

      if (!response.ok) {
        throw new Error(`Failed to create rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Create rule error:', error);
      // Return mock created rule
      return {
        ...rule,
        id: Math.random().toString(36).substring(7),
        createdAt: new Date().toISOString(),
        enabled: true,
      } as QualityRule;
    }
  }

  async updateRule(ruleId: string, updates: Partial<QualityRule>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}`, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(updates),
      });

      if (!response.ok) {
        throw new Error(`Failed to update rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Update rule error:', error);
      return { id: ruleId, ...updates } as QualityRule;
    }
  }

  async deleteRule(ruleId: string): Promise<void> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}`, {
        method: 'DELETE',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to delete rule: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Delete rule error:', error);
    }
  }

  async executeRule(ruleId: string): Promise<RuleExecutionResult> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}/execute/v2`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to execute rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Execute rule error:', error);
      return this.getMockExecutionResult(ruleId);
    }
  }

  // ============================================================================
  // SCANNING ENDPOINTS
  // ============================================================================

  async scanDataSource(dataSourceId: string, ruleIds?: string[]): Promise<ScanResult> {
    try {
      const response = await fetch(`${API_BASE}/quality/scan/${dataSourceId}`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ ruleIds }),
      });

      if (!response.ok) {
        throw new Error(`Failed to scan data source: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Scan data source error:', error);
      return this.getMockScanResult(dataSourceId);
    }
  }

  // ============================================================================
  // ISSUES ENDPOINTS
  // ============================================================================

  async getIssues(filters?: {
    status?: string;
    severity?: string;
    dataSourceId?: string;
    assetId?: number;
    page?: number;
    limit?: number;
  }): Promise<{ issues: QualityIssue[]; total: number }> {
    try {
      const params = new URLSearchParams();
      if (filters?.status) params.append('status', filters.status);
      if (filters?.severity) params.append('severity', filters.severity);
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      if (filters?.assetId) params.append('assetId', filters.assetId.toString());
      params.append('page', (filters?.page || 1).toString());
      params.append('limit', (filters?.limit || 50).toString());

      const response = await fetch(`${API_BASE}/quality/issues?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get issues: ${response.statusText}`);
      }

      const data = await response.json();
      return {
        issues: data.data.issues || [],
        total: data.data.pagination?.total || 0,
      };
    } catch (error) {
      console.error('Get issues error:', error);
      return this.getMockIssues();
    }
  }

  async updateIssueStatus(issueId: string, status: string, notes?: string): Promise<void> {
    try {
      const response = await fetch(`${API_BASE}/quality/issues/${issueId}/status`, {
        method: 'PATCH',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ status, notes }),
      });

      if (!response.ok) {
        throw new Error(`Failed to update issue: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Update issue error:', error);
    }
  }

  // ============================================================================
  // TRENDS ENDPOINTS
  // ============================================================================

  async getQualityTrends(
    dataSourceId?: string,
    timeframe: '24h' | '7d' | '30d' | '90d' = '7d'
  ): Promise<QualityTrend[]> {
    try {
      const params = new URLSearchParams();
      if (dataSourceId) params.append('dataSourceId', dataSourceId);
      params.append('timeframe', timeframe);

      const response = await fetch(`${API_BASE}/quality/trends?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get trends: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data || [];
    } catch (error) {
      console.error('Get trends error:', error);
      return this.getMockTrends();
    }
  }

  // ============================================================================
  // AI ENDPOINTS
  // ============================================================================

  async generateRuleFromText(prompt: string, context?: {
    dataSourceId?: string;
    assetId?: number;
  }): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/ai/generate-rule`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ prompt, context }),
      });

      if (!response.ok) {
        throw new Error(`Failed to generate rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Generate rule error:', error);
      // Generate mock rule from prompt
      return this.generateMockRuleFromPrompt(prompt);
    }
  }

  // ============================================================================
  // TEMPLATE ENDPOINTS
  // ============================================================================

  async getRuleTemplates(filters?: {
    dimension?: string;
    category?: string;
    search?: string;
  }): Promise<RuleTemplate[]> {
    try {
      const params = new URLSearchParams();
      if (filters?.dimension) params.append('dimension', filters.dimension);
      if (filters?.category) params.append('category', filters.category);
      if (filters?.search) params.append('search', filters.search);

      const response = await fetch(`${API_BASE}/quality/rule-templates?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get templates: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.templates || [];
    } catch (error) {
      console.error('Get templates error:', error);
      return [];
    }
  }

  async applyRuleTemplate(templateId: string, parameters: Record<string, any>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rule-templates/${templateId}/apply`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ parameters }),
      });

      if (!response.ok) {
        throw new Error(`Failed to apply template: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.rule;
    } catch (error) {
      console.error('Apply template error:', error);
      throw error;
    }
  }

  // ============================================================================
  // MOCK DATA GENERATORS
  // ============================================================================

  private getMockAssetProfile(assetId: number): AssetProfile {
    return {
      assetId,
      assetName: `table_${assetId}`,
      dataSourceId: 'mock-datasource',
      rowCount: Math.floor(Math.random() * 100000),
      columnCount: Math.floor(Math.random() * 20) + 5,
      qualityScore: Math.floor(Math.random() * 40) + 60,
      dimensionScores: {
        completeness: Math.floor(Math.random() * 30) + 70,
        accuracy: Math.floor(Math.random() * 30) + 70,
        consistency: Math.floor(Math.random() * 30) + 70,
        validity: Math.floor(Math.random() * 30) + 70,
        freshness: Math.floor(Math.random() * 30) + 70,
        uniqueness: Math.floor(Math.random() * 30) + 70,
      },
      profiledAt: new Date().toISOString(),
      columns: this.getMockColumnProfiles(),
    };
  }

  private getMockDataSourceProfiles(dataSourceId: string): AssetProfile[] {
    const tables = ['customers', 'orders', 'products', 'transactions', 'users'];
    return tables.map((table, index) => ({
      assetId: index + 1,
      assetName: `public.${table}`,
      dataSourceId,
      rowCount: Math.floor(Math.random() * 100000) + 10000,
      columnCount: Math.floor(Math.random() * 15) + 5,
      qualityScore: Math.floor(Math.random() * 30) + 65,
      dimensionScores: {
        completeness: Math.floor(Math.random() * 25) + 75,
        accuracy: Math.floor(Math.random() * 30) + 65,
        consistency: Math.floor(Math.random() * 20) + 75,
        validity: Math.floor(Math.random() * 25) + 70,
        freshness: Math.floor(Math.random() * 15) + 80,
        uniqueness: Math.floor(Math.random() * 20) + 75,
      },
      profiledAt: new Date().toISOString(),
      columns: this.getMockColumnProfiles(),
    }));
  }

  private getMockColumnProfiles(): ColumnProfile[] {
    const columns = ['id', 'email', 'created_at', 'status', 'amount'];
    return columns.map(col => ({
      name: col,
      dataType: col === 'id' ? 'integer' : col === 'email' ? 'varchar' : col === 'created_at' ? 'timestamp' : col === 'amount' ? 'decimal' : 'varchar',
      nullable: col !== 'id',
      nullCount: Math.floor(Math.random() * 100),
      nullRate: Math.random() * 0.1,
      distinctCount: Math.floor(Math.random() * 1000) + 100,
      uniqueRate: col === 'id' ? 1 : Math.random() * 0.5 + 0.5,
      topValues: [],
      anomalies: Math.random() > 0.7 ? [`High null rate detected`] : [],
      suggestedRules: [],
    }));
  }

  private getMockSuggestions(assetId: number): RuleSuggestion[] {
    return [
      {
        name: 'Email Format Validation',
        description: 'Validate email column format',
        dimension: 'validity',
        severity: 'high',
        ruleType: 'pattern',
        config: { pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' },
        columnName: 'email',
        autoGenerated: true,
      },
      {
        name: 'ID Uniqueness Check',
        description: 'Ensure ID column is unique',
        dimension: 'uniqueness',
        severity: 'critical',
        ruleType: 'threshold',
        config: { metric: 'unique_rate', operator: '>=', value: 0.99 },
        columnName: 'id',
        autoGenerated: true,
      },
      {
        name: 'Null Rate Threshold',
        description: 'Check null rate is below 5%',
        dimension: 'completeness',
        severity: 'medium',
        ruleType: 'threshold',
        config: { metric: 'null_rate', operator: '<', value: 0.05 },
        autoGenerated: true,
      },
    ];
  }

  private getMockRules(): QualityRule[] {
    return [
      {
        id: '1',
        name: 'Customer Email Validation',
        description: 'Ensure all customer emails are valid',
        dimension: 'validity',
        severity: 'high',
        ruleType: 'pattern',
        enabled: true,
        passRate: 98.5,
        executionCount: 142,
        avgExecutionTimeMs: 45,
        lastRunAt: new Date(Date.now() - 3600000).toISOString(),
      },
      {
        id: '2',
        name: 'Order ID Uniqueness',
        description: 'Verify order IDs are unique',
        dimension: 'uniqueness',
        severity: 'critical',
        ruleType: 'threshold',
        enabled: true,
        passRate: 100,
        executionCount: 89,
        avgExecutionTimeMs: 32,
        lastRunAt: new Date(Date.now() - 7200000).toISOString(),
      },
      {
        id: '3',
        name: 'Transaction Date Freshness',
        description: 'Check transaction data is recent',
        dimension: 'freshness',
        severity: 'medium',
        ruleType: 'freshness_check',
        enabled: false,
        passRate: 95.2,
        executionCount: 56,
        avgExecutionTimeMs: 78,
      },
    ];
  }

  private getMockExecutionResult(ruleId: string): RuleExecutionResult {
    const passed = Math.random() > 0.3;
    return {
      id: Math.random().toString(36),
      ruleId,
      status: passed ? 'passed' : 'failed',
      metricValue: Math.random() * 100,
      thresholdValue: 95,
      rowsChecked: Math.floor(Math.random() * 10000),
      rowsFailed: passed ? 0 : Math.floor(Math.random() * 100),
      executionTimeMs: Math.floor(Math.random() * 100) + 20,
    };
  }

  private getMockScanResult(dataSourceId: string): ScanResult {
    const totalRules = 10;
    const passed = Math.floor(Math.random() * 7) + 3;
    const failed = totalRules - passed;

    return {
      dataSourceId,
      totalRules,
      executedRules: totalRules,
      passed,
      failed,
      errors: 0,
      duration: Math.floor(Math.random() * 2000) + 500,
      results: Array.from({ length: totalRules }, (_, i) => ({
        id: `result-${i}`,
        ruleId: `rule-${i}`,
        status: i < passed ? 'passed' : 'failed',
        metricValue: Math.random() * 100,
        thresholdValue: 95,
        rowsChecked: Math.floor(Math.random() * 10000),
        rowsFailed: i < passed ? 0 : Math.floor(Math.random() * 100),
        executionTimeMs: Math.floor(Math.random() * 100) + 20,
      })),
    };
  }

  private getMockIssues(): { issues: QualityIssue[]; total: number } {
    const issues: QualityIssue[] = [
      {
        id: '1',
        ruleId: 'rule-1',
        ruleName: 'Email Validation',
        title: 'Invalid email formats detected',
        description: '245 rows contain invalid email addresses',
        severity: 'high',
        dimension: 'validity',
        status: 'open',
        affectedRows: 245,
        tableName: 'customers',
        schemaName: 'public',
        rootCause: 'Data import from legacy system did not validate email format. The CSV parser accepted malformed emails.',
        remediationPlan: '1. Run email validation script\n2. Update invalid emails from CRM\n3. Add validation to import process',
        firstSeenAt: new Date(Date.now() - 86400000).toISOString(),
        lastSeenAt: new Date().toISOString(),
        occurrenceCount: 3,
      },
      {
        id: '2',
        ruleId: 'rule-2',
        ruleName: 'Null Check',
        title: 'High null rate in required column',
        description: 'Phone number column has 18% null values',
        severity: 'medium',
        dimension: 'completeness',
        status: 'acknowledged',
        affectedRows: 1823,
        tableName: 'users',
        schemaName: 'public',
        rootCause: 'Optional field in signup form allows users to skip phone number.',
        remediationPlan: '1. Make phone number required in signup\n2. Run campaign to collect missing phones\n3. Update database constraint',
        firstSeenAt: new Date(Date.now() - 172800000).toISOString(),
        lastSeenAt: new Date().toISOString(),
        occurrenceCount: 5,
      },
    ];

    return { issues, total: issues.length };
  }

  private getMockTrends(): QualityTrend[] {
    const now = Date.now();
    const trends: QualityTrend[] = [];

    for (let i = 29; i >= 0; i--) {
      const timestamp = new Date(now - i * 86400000);
      const baseScore = 75 + Math.sin(i / 5) * 10 + Math.random() * 5;

      trends.push({
        timestamp: timestamp.toISOString(),
        overallScore: Math.round(baseScore),
        dimensionScores: {
          completeness: Math.round(baseScore + Math.random() * 10),
          accuracy: Math.round(baseScore - Math.random() * 5),
          consistency: Math.round(baseScore + Math.random() * 8),
          validity: Math.round(baseScore - Math.random() * 3),
          freshness: Math.round(baseScore + Math.random() * 12),
          uniqueness: Math.round(baseScore + Math.random() * 5),
        },
        issueCount: Math.floor(Math.random() * 20) + 5,
        passRate: Math.round(baseScore + Math.random() * 15),
      });
    }

    return trends;
  }

  private generateMockRuleFromPrompt(prompt: string): QualityRule {
    const lowerPrompt = prompt.toLowerCase();

    let dimension = 'validity';
    let severity: 'low' | 'medium' | 'high' | 'critical' = 'medium';
    let ruleType = 'threshold';
    let name = prompt.substring(0, 50);

    if (lowerPrompt.includes('email')) {
      dimension = 'validity';
      severity = 'high';
      ruleType = 'pattern';
      name = 'Email Format Validation';
    } else if (lowerPrompt.includes('null') || lowerPrompt.includes('missing')) {
      dimension = 'completeness';
      severity = 'medium';
      ruleType = 'threshold';
      name = 'Null Rate Check';
    } else if (lowerPrompt.includes('duplicate') || lowerPrompt.includes('unique')) {
      dimension = 'uniqueness';
      severity = 'critical';
      ruleType = 'threshold';
      name = 'Uniqueness Validation';
    } else if (lowerPrompt.includes('fresh') || lowerPrompt.includes('recent') || lowerPrompt.includes('stale')) {
      dimension = 'freshness';
      severity = 'medium';
      ruleType = 'freshness_check';
      name = 'Data Freshness Check';
    }

    return {
      id: Math.random().toString(36).substring(7),
      name,
      description: `AI-generated rule from: ${prompt}`,
      dimension,
      severity,
      ruleType,
      enabled: true,
      createdAt: new Date().toISOString(),
      ruleConfig: {},
    };
  }
}

export const qualityAPI = new QualityAPI();