// frontend/src/services/api/quality.ts
// Complete Quality API Service with all endpoints

// Use direct service endpoint for better reliability during development
const API_BASE = import.meta.env.DEV ? 'http://localhost:3002/api' : '/api';

export interface AssetProfile {
  assetId: number;
  assetName: string;
  dataSourceId: string;
  rowCount: number;
  columnCount: number;
  sizeBytes?: number;
  qualityScore: number;
  dimensionScores: {
    completeness: number;
    accuracy: number;
    consistency: number;
    validity: number;
    freshness: number;
    uniqueness: number;
  };
  profiledAt: string;
  columns: ColumnProfile[];
}

export interface ColumnProfile {
  name: string;
  dataType: string;
  nullable: boolean;
  nullCount: number;
  nullRate: number;
  distinctCount: number;
  uniqueRate: number;
  min?: any;
  max?: any;
  avg?: number;
  stdDev?: number;
  topValues: Array<{ value: any; count: number; percentage: number }>;
  anomalies: string[];
  suggestedRules: RuleSuggestion[];
}

export interface RuleSuggestion {
  name: string;
  description: string;
  dimension: string;
  severity: string;
  ruleType: string;
  config: any;
  columnName?: string;
  autoGenerated: boolean;
}

export interface QualityRule {
  id: string;
  name: string;
  description?: string;
  rule_type: string;
  dimension: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  data_source_id?: string;
  asset_id?: number;
  table_name?: string;
  column_name?: string;
  expression?: string;
  threshold?: number;
  parameters?: any;
  enabled: boolean;
  created_at?: string;
  updated_at?: string;
  last_executed_at?: string | null;
  execution_count?: number;
  last_result?: {
    status: 'passed' | 'failed' | 'error';
    issues_found?: number;
    pass_rate?: number;
    execution_time_ms?: number;
    message?: string;
    database_type?: string;
  } | null;
  // Legacy fields for backwards compatibility
  ruleType?: string;
  ruleConfig?: any;
  assetId?: number;
  dataSourceId?: string;
  columnName?: string;
  lastRunAt?: string;
  passRate?: number;
  avgExecutionTimeMs?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface QualityIssue {
  id: string;
  ruleId: string;
  ruleName: string;
  title: string;
  description?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  dimension: string;
  status: 'open' | 'acknowledged' | 'in_progress' | 'resolved' | 'false_positive' | 'wont_fix';
  assetId?: number;
  assetName?: string;
  tableName?: string;
  schemaName?: string;
  dataSourceName?: string;
  affectedRows: number;
  affectedColumns?: string[];
  sampleData?: any[];
  rootCause?: string;
  remediationPlan?: string;
  firstSeenAt: string;
  lastSeenAt: string;
  occurrenceCount: number;
  assignedTo?: string;
  resolvedAt?: string;
}

export interface ScanResult {
  dataSourceId: string;
  totalRules: number;
  executedRules: number;
  passed: number;
  failed: number;
  errors: number;
  duration: number;
  results: RuleExecutionResult[];
}

export interface RuleExecutionResult {
  id: string;
  ruleId: string;
  status: 'passed' | 'failed' | 'warning' | 'error' | 'timeout';
  metricValue?: number;
  thresholdValue?: number;
  rowsChecked?: number;
  rowsFailed?: number;
  executionTimeMs: number;
  errorMessage?: string;
  sampleFailures?: any[];
}

export interface QualityTrend {
  timestamp: string;
  overallScore: number;
  dimensionScores: {
    completeness: number;
    accuracy: number;
    consistency: number;
    validity: number;
    freshness: number;
    uniqueness: number;
  };
  issueCount: number;
  passRate: number;
}

export interface RuleTemplate {
  id: string;
  name: string;
  description: string;
  dimension: 'completeness' | 'accuracy' | 'consistency' | 'validity' | 'freshness' | 'uniqueness';
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  sqlTemplate: string;
  parameters: {
    name: string;
    description: string;
    type: 'table' | 'column' | 'threshold' | 'pattern' | 'number' | 'string';
    required: boolean;
    defaultValue?: any;
  }[];
  examples: string[];
  bestPractices: string;
}

class QualityAPI {
  private getAuthHeaders(): HeadersInit {
    const token = localStorage.getItem('token');
    return {
      'Content-Type': 'application/json',
      ...(token && { 'Authorization': `Bearer ${token}` }),
    };
  }

  // ============================================================================
  // PROFILING ENDPOINTS
  // ============================================================================

  async profileAsset(assetId: number): Promise<AssetProfile> {
    try {
      const response = await fetch(`${API_BASE}/quality/profile/asset/${assetId}`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to profile asset: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Profile asset error:', error);
      // Return mock data for demo
      return this.getMockAssetProfile(assetId);
    }
  }

  async profileDataSource(dataSourceId: string, database?: string): Promise<any> {
    try {
      const options: RequestInit = {
        method: 'POST',
        headers: this.getAuthHeaders(),
      };

      if (database) {
        options.body = JSON.stringify({ database });
      }

      const response = await fetch(`${API_BASE}/quality/profile/datasource/${dataSourceId}`, options);

      if (!response.ok) {
        throw new Error(`Failed to profile data source: ${response.statusText}`);
      }

      const result = await response.json();

      // Return the full response data which includes profileCount, successfulProfiles, etc.
      return result.data || { profiles: [], profileCount: 0, successfulProfiles: 0, failedProfiles: 0, averageQualityScore: 0 };
    } catch (error) {
      console.error('Profile data source error:', error);
      // Return mock data for demo
      return {
        profiles: this.getMockDataSourceProfiles(dataSourceId),
        profileCount: 5,
        successfulProfiles: 5,
        failedProfiles: 0,
        averageQualityScore: 80
      };
    }
  }

  async getProfileSuggestions(assetId: number): Promise<RuleSuggestion[]> {
    try {
      const response = await fetch(`${API_BASE}/quality/profile/asset/${assetId}/suggestions`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get suggestions: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.suggestions || [];
    } catch (error) {
      console.error('Get suggestions error:', error);
      return this.getMockSuggestions(assetId);
    }
  }

  // ============================================================================
  // RULES ENDPOINTS
  // ============================================================================

  async getRules(filters?: {
    dataSourceId?: string;
    assetId?: number;
    enabled?: boolean;
    severity?: string;
  }): Promise<QualityRule[]> {
    try {
      const params = new URLSearchParams();
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      if (filters?.assetId) params.append('assetId', filters.assetId.toString());
      if (filters?.enabled !== undefined) params.append('enabled', filters.enabled.toString());
      if (filters?.severity) params.append('severity', filters.severity);

      const response = await fetch(`${API_BASE}/quality/rules?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get rules: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.rules || [];
    } catch (error) {
      console.error('Get rules error:', error);
      return this.getMockRules();
    }
  }

  async createRule(rule: Partial<QualityRule>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(rule),
      });

      if (!response.ok) {
        throw new Error(`Failed to create rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Create rule error:', error);
      // Return mock created rule
      return {
        ...rule,
        id: Math.random().toString(36).substring(7),
        createdAt: new Date().toISOString(),
        enabled: true,
      } as QualityRule;
    }
  }

  async updateRule(ruleId: string, updates: Partial<QualityRule>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}`, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(updates),
      });

      if (!response.ok) {
        throw new Error(`Failed to update rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Update rule error:', error);
      return { id: ruleId, ...updates } as QualityRule;
    }
  }

  async deleteRule(ruleId: string): Promise<void> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}`, {
        method: 'DELETE',
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to delete rule: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Delete rule error:', error);
    }
  }

  async executeRule(ruleId: string, options?: { databaseType?: string }): Promise<RuleExecutionResult> {
    try {
      const response = await fetch(`${API_BASE}/quality/rules/${ruleId}/execute/v2`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({
          databaseType: options?.databaseType || 'postgresql'
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to execute rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Execute rule error:', error);
      return this.getMockExecutionResult(ruleId);
    }
  }

  // ============================================================================
  // SCANNING ENDPOINTS
  // ============================================================================

  async scanDataSource(dataSourceId: string, ruleIds?: string[]): Promise<ScanResult> {
    try {
      const response = await fetch(`${API_BASE}/quality/scan/${dataSourceId}`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ ruleIds }),
      });

      if (!response.ok) {
        throw new Error(`Failed to scan data source: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Scan data source error:', error);
      return this.getMockScanResult(dataSourceId);
    }
  }

  // ============================================================================
  // ISSUES ENDPOINTS
  // ============================================================================

  async getIssues(filters?: {
    status?: string;
    severity?: string;
    dataSourceId?: string;
    database?: string;
    databases?: string; // Support multiple databases (comma-separated) like Data Catalog
    assetId?: number;
    page?: number;
    limit?: number;
  }): Promise<{ issues: QualityIssue[]; pagination: { total: number; page: number; limit: number } }> {
    try {
      const params = new URLSearchParams();
      if (filters?.status) params.append('status', filters.status);
      if (filters?.severity) params.append('severity', filters.severity);
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      // Support both singular and plural database parameter (Data Catalog compatibility)
      if (filters?.databases) params.append('databases', filters.databases);
      else if (filters?.database) params.append('database', filters.database);
      if (filters?.assetId) params.append('assetId', filters.assetId.toString());
      params.append('page', (filters?.page || 1).toString());
      params.append('limit', (filters?.limit || 50).toString());

      const response = await fetch(`${API_BASE}/quality/issues?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get issues: ${response.statusText}`);
      }

      const data = await response.json();
      return {
        issues: data.data.issues || [],
        pagination: data.data.pagination || { total: 0, page: 1, limit: 50 },
      };
    } catch (error) {
      console.error('Get issues error:', error);
      return this.getMockIssues();
    }
  }

  async updateIssueStatus(issueId: string, status: string, notes?: string): Promise<void> {
    try {
      const response = await fetch(`${API_BASE}/quality/issues/${issueId}/status`, {
        method: 'PATCH',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ status, notes }),
      });

      if (!response.ok) {
        throw new Error(`Failed to update issue: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Update issue error:', error);
    }
  }

  // ============================================================================
  // SUMMARY ENDPOINTS
  // ============================================================================

  async getQualitySummary(filters?: {
    dataSourceId?: string;
    database?: string;
    databases?: string; // Support multiple databases (comma-separated) like Data Catalog
    timeframe?: string;
    assetType?: string;
  }): Promise<any> {
    try {
      const params = new URLSearchParams();
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      // Support both singular and plural database parameter (Data Catalog compatibility)
      if (filters?.databases) params.append('databases', filters.databases);
      else if (filters?.database) params.append('database', filters.database);
      if (filters?.timeframe) params.append('timeframe', filters.timeframe);
      if (filters?.assetType) params.append('assetType', filters.assetType);

      const response = await fetch(`${API_BASE}/quality/summary?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get summary: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data || {};
    } catch (error) {
      console.error('Get summary error:', error);
      return this.getMockSummary();
    }
  }

  // ============================================================================
  // BUSINESS IMPACT ENDPOINT
  // ============================================================================

  async getBusinessImpact(filters?: {
    dataSourceId?: string;
    database?: string;
    databases?: string;
  }): Promise<any> {
    try {
      const params = new URLSearchParams();
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      if (filters?.databases) params.append('databases', filters.databases);
      else if (filters?.database) params.append('database', filters.database);

      const response = await fetch(`${API_BASE}/quality/business-impact?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get business impact: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data || {
        totalRevenueImpact: 0,
        totalUserImpact: 0,
        criticalIssues: 0,
        highIssues: 0,
        mediumIssues: 0,
        totalFailedScans: 0,
        estimatedDowntimeMinutes: 0,
        assetsImpacted: 0
      };
    } catch (error) {
      console.error('Get business impact error:', error);
      return {
        totalRevenueImpact: 0,
        totalUserImpact: 0,
        criticalIssues: 0,
        highIssues: 0,
        mediumIssues: 0,
        totalFailedScans: 0,
        estimatedDowntimeMinutes: 0,
        assetsImpacted: 0
      };
    }
  }

  // ============================================================================
  // CRITICAL ALERTS ENDPOINT
  // ============================================================================

  async getCriticalAlerts(filters?: {
    dataSourceId?: string;
    database?: string;
    databases?: string;
    limit?: number;
  }): Promise<any[]> {
    try {
      const params = new URLSearchParams();
      if (filters?.dataSourceId) params.append('dataSourceId', filters.dataSourceId);
      if (filters?.database) params.append('database', filters.database);
      if (filters?.databases) params.append('databases', filters.databases);
      if (filters?.limit) params.append('limit', filters.limit.toString());

      const response = await fetch(`${API_BASE}/quality/critical-alerts?${params.toString()}`, {
        headers: {
          ...this.getAuthHeaders(),
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        },
        cache: 'no-store'
      });

      if (!response.ok) {
        console.error('Failed to fetch critical alerts:', response.statusText);
        return [];
      }

      const result = await response.json();
      console.log('[QualityAPI] Critical alerts loaded:', {
        count: result.data?.length,
        autoFixAvailable: result.data?.filter((a: any) => a.autoFixAvailable).length,
        emptyTables: result.data?.filter((a: any) => a.isEmptyTableAlert).length
      });
      return result.data || [];
    } catch (error) {
      console.error('Error fetching critical alerts:', error);
      return [];
    }
  }

  // ============================================================================
  // TRENDS ENDPOINTS
  // ============================================================================

  async getQualityTrends(
    dataSourceId?: string,
    timeframe: '24h' | '7d' | '30d' | '90d' = '7d'
  ): Promise<QualityTrend[]> {
    try {
      const params = new URLSearchParams();
      if (dataSourceId) params.append('dataSourceId', dataSourceId);
      params.append('timeframe', timeframe);

      const response = await fetch(`${API_BASE}/quality/trends?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get trends: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data || [];
    } catch (error) {
      console.error('Get trends error:', error);
      return this.getMockTrends();
    }
  }

  // ============================================================================
  // AI ENDPOINTS
  // ============================================================================

  async generateRuleFromText(prompt: string, context?: {
    dataSourceId?: string;
    assetId?: number;
  }): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/ai/generate-rule`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ prompt, context }),
      });

      if (!response.ok) {
        throw new Error(`Failed to generate rule: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data;
    } catch (error) {
      console.error('Generate rule error:', error);
      // Generate mock rule from prompt
      return this.generateMockRuleFromPrompt(prompt);
    }
  }

  // ============================================================================
  // TEMPLATE ENDPOINTS
  // ============================================================================

  async getRuleTemplates(filters?: {
    dimension?: string;
    category?: string;
    search?: string;
  }): Promise<RuleTemplate[]> {
    try {
      const params = new URLSearchParams();
      if (filters?.dimension) params.append('dimension', filters.dimension);
      if (filters?.category) params.append('category', filters.category);
      if (filters?.search) params.append('search', filters.search);

      const response = await fetch(`${API_BASE}/quality/rule-templates?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Failed to get templates: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.templates || [];
    } catch (error) {
      console.error('Get templates error:', error);
      return [];
    }
  }

  async applyRuleTemplate(templateId: string, parameters: Record<string, any>): Promise<QualityRule> {
    try {
      const response = await fetch(`${API_BASE}/quality/rule-templates/${templateId}/apply`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ parameters }),
      });

      if (!response.ok) {
        throw new Error(`Failed to apply template: ${response.statusText}`);
      }

      const data = await response.json();
      return data.data.rule;
    } catch (error) {
      console.error('Apply template error:', error);
      throw error;
    }
  }

  // ============================================================================
  // MOCK DATA GENERATORS
  // ============================================================================

  private getMockAssetProfile(assetId: number): AssetProfile {
    return {
      assetId,
      assetName: `table_${assetId}`,
      dataSourceId: 'mock-datasource',
      rowCount: Math.floor(Math.random() * 100000),
      columnCount: Math.floor(Math.random() * 20) + 5,
      qualityScore: Math.floor(Math.random() * 40) + 60,
      dimensionScores: {
        completeness: Math.floor(Math.random() * 30) + 70,
        accuracy: Math.floor(Math.random() * 30) + 70,
        consistency: Math.floor(Math.random() * 30) + 70,
        validity: Math.floor(Math.random() * 30) + 70,
        freshness: Math.floor(Math.random() * 30) + 70,
        uniqueness: Math.floor(Math.random() * 30) + 70,
      },
      profiledAt: new Date().toISOString(),
      columns: this.getMockColumnProfiles(),
    };
  }

  private getMockDataSourceProfiles(dataSourceId: string): AssetProfile[] {
    const tables = ['customers', 'orders', 'products', 'transactions', 'users'];
    return tables.map((table, index) => ({
      assetId: index + 1,
      assetName: `public.${table}`,
      dataSourceId,
      rowCount: Math.floor(Math.random() * 100000) + 10000,
      columnCount: Math.floor(Math.random() * 15) + 5,
      qualityScore: Math.floor(Math.random() * 30) + 65,
      dimensionScores: {
        completeness: Math.floor(Math.random() * 25) + 75,
        accuracy: Math.floor(Math.random() * 30) + 65,
        consistency: Math.floor(Math.random() * 20) + 75,
        validity: Math.floor(Math.random() * 25) + 70,
        freshness: Math.floor(Math.random() * 15) + 80,
        uniqueness: Math.floor(Math.random() * 20) + 75,
      },
      profiledAt: new Date().toISOString(),
      columns: this.getMockColumnProfiles(),
    }));
  }

  private getMockColumnProfiles(): ColumnProfile[] {
    const columns = ['id', 'email', 'created_at', 'status', 'amount'];
    return columns.map(col => ({
      name: col,
      dataType: col === 'id' ? 'integer' : col === 'email' ? 'varchar' : col === 'created_at' ? 'timestamp' : col === 'amount' ? 'decimal' : 'varchar',
      nullable: col !== 'id',
      nullCount: Math.floor(Math.random() * 100),
      nullRate: Math.random() * 0.1,
      distinctCount: Math.floor(Math.random() * 1000) + 100,
      uniqueRate: col === 'id' ? 1 : Math.random() * 0.5 + 0.5,
      topValues: [],
      anomalies: Math.random() > 0.7 ? [`High null rate detected`] : [],
      suggestedRules: [],
    }));
  }

  private getMockSuggestions(assetId: number): RuleSuggestion[] {
    return [
      {
        name: 'Email Format Validation',
        description: 'Validate email column format',
        dimension: 'validity',
        severity: 'high',
        ruleType: 'pattern',
        config: { pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$' },
        columnName: 'email',
        autoGenerated: true,
      },
      {
        name: 'ID Uniqueness Check',
        description: 'Ensure ID column is unique',
        dimension: 'uniqueness',
        severity: 'critical',
        ruleType: 'threshold',
        config: { metric: 'unique_rate', operator: '>=', value: 0.99 },
        columnName: 'id',
        autoGenerated: true,
      },
      {
        name: 'Null Rate Threshold',
        description: 'Check null rate is below 5%',
        dimension: 'completeness',
        severity: 'medium',
        ruleType: 'threshold',
        config: { metric: 'null_rate', operator: '<', value: 0.05 },
        autoGenerated: true,
      },
    ];
  }

  private getMockRules(): QualityRule[] {
    return [
      {
        id: '1',
        name: 'Customer Email Validation',
        description: 'Ensure all customer emails are valid',
        rule_type: 'pattern',
        dimension: 'validity',
        severity: 'high',
        data_source_id: 'ds-001',
        table_name: 'customers',
        column_name: 'email',
        expression: "email REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z]{2,}$'",
        enabled: true,
        created_at: new Date(Date.now() - 86400000 * 7).toISOString(),
        last_executed_at: new Date(Date.now() - 3600000).toISOString(),
        execution_count: 142,
        last_result: {
          status: 'passed',
          issues_found: 2,
          pass_rate: 98.5,
          execution_time_ms: 45,
          message: 'Rule executed successfully'
        }
      },
      {
        id: '2',
        name: 'Order ID Uniqueness',
        description: 'Verify order IDs are unique across the system',
        rule_type: 'uniqueness',
        dimension: 'uniqueness',
        severity: 'critical',
        data_source_id: 'ds-001',
        table_name: 'orders',
        column_name: 'order_id',
        expression: 'COUNT(DISTINCT order_id) = COUNT(order_id)',
        enabled: true,
        created_at: new Date(Date.now() - 86400000 * 14).toISOString(),
        last_executed_at: new Date(Date.now() - 7200000).toISOString(),
        execution_count: 89,
        last_result: {
          status: 'passed',
          issues_found: 0,
          pass_rate: 100,
          execution_time_ms: 32,
          message: 'No duplicates found'
        }
      },
      {
        id: '3',
        name: 'Transaction Date Freshness',
        description: 'Check transaction data is recent (within 30 days)',
        rule_type: 'freshness',
        dimension: 'freshness',
        severity: 'medium',
        data_source_id: 'ds-001',
        table_name: 'transactions',
        column_name: 'transaction_date',
        expression: "DATEDIFF(NOW(), transaction_date) <= 30",
        enabled: false,
        created_at: new Date(Date.now() - 86400000 * 21).toISOString(),
        last_executed_at: new Date(Date.now() - 86400000 * 2).toISOString(),
        execution_count: 56,
        last_result: {
          status: 'failed',
          issues_found: 45,
          pass_rate: 95.2,
          execution_time_ms: 78,
          message: 'Found 45 stale records'
        }
      },
      {
        id: '4',
        name: 'Product Price Range Check',
        description: 'Ensure product prices are within acceptable range',
        rule_type: 'range',
        dimension: 'validity',
        severity: 'high',
        data_source_id: 'ds-001',
        table_name: 'products',
        column_name: 'price',
        expression: 'price BETWEEN 0 AND 10000',
        enabled: true,
        created_at: new Date(Date.now() - 86400000 * 10).toISOString(),
        last_executed_at: new Date(Date.now() - 3600000 * 5).toISOString(),
        execution_count: 234,
        last_result: {
          status: 'failed',
          issues_found: 12,
          pass_rate: 87.5,
          execution_time_ms: 120,
          message: 'Found 12 products with invalid prices'
        }
      },
      {
        id: '5',
        name: 'Customer Phone Format',
        description: 'Validate phone numbers follow E.164 format',
        rule_type: 'pattern',
        dimension: 'validity',
        severity: 'medium',
        data_source_id: 'ds-001',
        table_name: 'customers',
        column_name: 'phone',
        expression: "phone REGEXP '^\\+[1-9]\\d{1,14}$'",
        enabled: true,
        created_at: new Date(Date.now() - 86400000 * 5).toISOString(),
        last_executed_at: new Date(Date.now() - 3600000 * 2).toISOString(),
        execution_count: 67,
        last_result: {
          status: 'failed',
          issues_found: 156,
          pass_rate: 72.3,
          execution_time_ms: 89,
          message: 'Found 156 invalid phone numbers'
        }
      },
      {
        id: '6',
        name: 'Inventory Count Non-Negative',
        description: 'Ensure inventory counts are never negative',
        rule_type: 'range',
        dimension: 'validity',
        severity: 'critical',
        data_source_id: 'ds-001',
        table_name: 'inventory',
        column_name: 'quantity',
        expression: 'quantity >= 0',
        enabled: true,
        created_at: new Date(Date.now() - 86400000 * 3).toISOString(),
        last_executed_at: null,
        execution_count: 0,
        last_result: null
      },
      {
        id: '7',
        name: 'User Account Status Consistency',
        description: 'Check that deleted accounts have no recent activity',
        rule_type: 'custom',
        dimension: 'consistency',
        severity: 'high',
        data_source_id: 'ds-001',
        table_name: 'users',
        column_name: 'status',
        expression: "NOT (status = 'deleted' AND last_activity > DATE_SUB(NOW(), INTERVAL 30 DAY))",
        enabled: true,
        created_at: new Date(Date.now() - 86400000).toISOString(),
        last_executed_at: new Date(Date.now() - 3600000 * 8).toISOString(),
        execution_count: 23,
        last_result: {
          status: 'error',
          issues_found: 0,
          pass_rate: 0,
          execution_time_ms: 5,
          message: 'Connection timeout'
        }
      },
      {
        id: '8',
        name: '[Autopilot] Missing Values Check',
        description: 'Auto-generated rule to detect NULL values in required fields',
        rule_type: 'completeness',
        dimension: 'completeness',
        severity: 'high',
        data_source_id: 'ds-001',
        table_name: 'customers',
        column_name: 'customer_id',
        expression: 'customer_id IS NOT NULL',
        enabled: true,
        created_at: new Date(Date.now() - 3600000 * 4).toISOString(),
        last_executed_at: new Date(Date.now() - 1800000).toISOString(),
        execution_count: 12,
        last_result: {
          status: 'passed',
          issues_found: 0,
          pass_rate: 100,
          execution_time_ms: 23,
          message: 'No NULL values found'
        }
      }
    ];
  }

  private getMockExecutionResult(ruleId: string): RuleExecutionResult {
    const passed = Math.random() > 0.3;
    return {
      id: Math.random().toString(36),
      ruleId,
      status: passed ? 'passed' : 'failed',
      metricValue: Math.random() * 100,
      thresholdValue: 95,
      rowsChecked: Math.floor(Math.random() * 10000),
      rowsFailed: passed ? 0 : Math.floor(Math.random() * 100),
      executionTimeMs: Math.floor(Math.random() * 100) + 20,
    };
  }

  private getMockScanResult(dataSourceId: string): ScanResult {
    const totalRules = 10;
    const passed = Math.floor(Math.random() * 7) + 3;
    const failed = totalRules - passed;

    return {
      dataSourceId,
      totalRules,
      executedRules: totalRules,
      passed,
      failed,
      errors: 0,
      duration: Math.floor(Math.random() * 2000) + 500,
      results: Array.from({ length: totalRules }, (_, i) => ({
        id: `result-${i}`,
        ruleId: `rule-${i}`,
        status: i < passed ? 'passed' : 'failed',
        metricValue: Math.random() * 100,
        thresholdValue: 95,
        rowsChecked: Math.floor(Math.random() * 10000),
        rowsFailed: i < passed ? 0 : Math.floor(Math.random() * 100),
        executionTimeMs: Math.floor(Math.random() * 100) + 20,
      })),
    };
  }

  private getMockIssues(): { issues: QualityIssue[]; pagination: { total: number; page: number; limit: number } } {
    const issues: QualityIssue[] = [
      {
        id: '1',
        ruleId: 'rule-1',
        ruleName: 'Email Validation',
        title: 'Invalid email formats detected',
        description: '245 rows contain invalid email addresses',
        severity: 'high',
        dimension: 'validity',
        status: 'open',
        affectedRows: 245,
        tableName: 'customers',
        schemaName: 'public',
        rootCause: 'Data import from legacy system did not validate email format. The CSV parser accepted malformed emails.',
        remediationPlan: '1. Run email validation script\n2. Update invalid emails from CRM\n3. Add validation to import process',
        firstSeenAt: new Date(Date.now() - 86400000).toISOString(),
        lastSeenAt: new Date().toISOString(),
        occurrenceCount: 3,
      },
      {
        id: '2',
        ruleId: 'rule-2',
        ruleName: 'Null Check',
        title: 'High null rate in required column',
        description: 'Phone number column has 18% null values',
        severity: 'medium',
        dimension: 'completeness',
        status: 'acknowledged',
        affectedRows: 1823,
        tableName: 'users',
        schemaName: 'public',
        rootCause: 'Optional field in signup form allows users to skip phone number.',
        remediationPlan: '1. Make phone number required in signup\n2. Run campaign to collect missing phones\n3. Update database constraint',
        firstSeenAt: new Date(Date.now() - 172800000).toISOString(),
        lastSeenAt: new Date().toISOString(),
        occurrenceCount: 5,
      },
    ];

    return {
      issues,
      pagination: {
        total: issues.length,
        page: 1,
        limit: 50
      }
    };
  }

  private getMockSummary(): any {
    return {
      overallScore: 82,
      dimensions: {
        completeness: 88,
        accuracy: 79,
        consistency: 85,
        validity: 76,
        uniqueness: 91,
        freshness: 73
      },
      assetCoverage: {
        totalAssets: 45,
        monitoredAssets: 38,
        coveragePercentage: 84
      },
      ruleMetrics: {
        totalRules: 127,
        activeRules: 98,
        passedRules: 89,
        failedRules: 9
      },
      issueMetrics: {
        total: 23,
        bySeverity: {
          critical: 2,
          high: 7,
          medium: 9,
          low: 5
        },
        byStatus: {
          open: 15,
          acknowledged: 6,
          resolved: 2
        }
      }
    };
  }

  private getMockTrends(): QualityTrend[] {
    const now = Date.now();
    const trends: QualityTrend[] = [];

    for (let i = 29; i >= 0; i--) {
      const timestamp = new Date(now - i * 86400000);
      const baseScore = 75 + Math.sin(i / 5) * 10 + Math.random() * 5;

      trends.push({
        timestamp: timestamp.toISOString(),
        overallScore: Math.round(baseScore),
        dimensionScores: {
          completeness: Math.round(baseScore + Math.random() * 10),
          accuracy: Math.round(baseScore - Math.random() * 5),
          consistency: Math.round(baseScore + Math.random() * 8),
          validity: Math.round(baseScore - Math.random() * 3),
          freshness: Math.round(baseScore + Math.random() * 12),
          uniqueness: Math.round(baseScore + Math.random() * 5),
        },
        issueCount: Math.floor(Math.random() * 20) + 5,
        passRate: Math.round(baseScore + Math.random() * 15),
      });
    }

    return trends;
  }

  private generateMockRuleFromPrompt(prompt: string): QualityRule {
    const lowerPrompt = prompt.toLowerCase();

    let dimension = 'validity';
    let severity: 'low' | 'medium' | 'high' | 'critical' = 'medium';
    let ruleType = 'threshold';
    let name = prompt.substring(0, 50);

    if (lowerPrompt.includes('email')) {
      dimension = 'validity';
      severity = 'high';
      ruleType = 'pattern';
      name = 'Email Format Validation';
    } else if (lowerPrompt.includes('null') || lowerPrompt.includes('missing')) {
      dimension = 'completeness';
      severity = 'medium';
      ruleType = 'threshold';
      name = 'Null Rate Check';
    } else if (lowerPrompt.includes('duplicate') || lowerPrompt.includes('unique')) {
      dimension = 'uniqueness';
      severity = 'critical';
      ruleType = 'threshold';
      name = 'Uniqueness Validation';
    } else if (lowerPrompt.includes('fresh') || lowerPrompt.includes('recent') || lowerPrompt.includes('stale')) {
      dimension = 'freshness';
      severity = 'medium';
      ruleType = 'freshness_check';
      name = 'Data Freshness Check';
    }

    return {
      id: Math.random().toString(36).substring(7),
      name,
      description: `AI-generated rule from: ${prompt}`,
      dimension,
      severity,
      ruleType,
      enabled: true,
      createdAt: new Date().toISOString(),
      ruleConfig: {},
    };
  }
}

export const qualityAPI = new QualityAPI();